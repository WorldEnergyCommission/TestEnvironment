<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_EM_Beckhoff_KL3403_T" Id="{6b8da059-d417-4628-9ca0-80c4e627b5a5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_EM_Beckhoff_KL3403_T
VAR_INPUT PERSISTENT
	bEnable							: BOOL;											//Enable the function
	bChannel1Invers					: BOOL;											//Invert the Output data from Channel 1. = L1
	bChannel2Invers					: BOOL;											//Invert the Output data from Channel 2. = L2
	bChannel3Invers					: BOOL;											//Invert the Output data from Channel 3. = L3
	uiCurrentTransformerRatioL1		: UINT;											//Current Transformer Ratio for Channel 1 (L1)
	uiCurrentTransformerRatioL2		: UINT;											//Current Transformer Ratio for Channel 2 (L2)
	uiCurrentTransformerRatioL3		: UINT;											//Current Transformer Ratio for Channel 3 (L3)
END_VAR
VAR_INPUT
	uiKBusState_IN					: UINT;											//K-Bus State from the K-Bus Box on wich the Terminal is connected. (Connect with FB_K_Bus_state)
END_VAR
VAR_OUTPUT
	stDataEMPower					: ST_ElectricMeter_Output_Power;				//Output structure with Data from Electric Meter (Power Data)
	stDataEMCounter					: ST_ElectricMeter_Output_Counter;				//Output structure with Data from Electric Meter (Counter Data)
	stDataEMPowerRealTime			: ST_ElectricMeter_Output_Power;				//Output structure with Data from Electric Meter (Power Data RealTime)
	stDataEMCounterRealTime			: ST_ElectricMeter_Output_Counter;				//Output structure with Data from Electric Meter (Counter Data RealTime)
	diNrOfEM_OUT					: DINT;											//Active Number from the Electric Meter for using on other functions
	lrPowerfactorL1					: LREAL;
	lrPowerfactorL2					: LREAL;
	lrPowerfactorL3					: LREAL;
	lrApparentPowerL1				: LREAL;
	lrApparentPowerL2				: LREAL;
	lrApparentPowerL3				: LREAL;
	lrReactivePowerL1				: LREAL;
	lrReactivePowerL2				: LREAL;
	lrReactivePowerL3				: LREAL;
END_VAR
VAR
	{attribute 'conditionalshow'}
	fbEM							: FB_ElectricMeter;								//Electric Meter Function
	{attribute 'conditionalshow'}
	fbEnergyCounter					: FB_EnergyCounter;								//FB energy Counter, because the KL3403 has no nice logic for the Energy value
	{attribute 'hide'}
	fbNumberDevice					: FB_NumberOfDevice;							//Function block to calcualte the number of the Device
	fbKL3403						: FB_KL3403_SimpleProcessImage;					//Function KL3403
	{attribute 'hide'}
	stDataL1						: ST_KL3403;									//Data from Channel 1 (L1)
	{attribute 'hide'}
	stDataL2						: ST_KL3403;									//Data from Channel 2 (L2)
	{attribute 'hide'}
	stDataL3						: ST_KL3403;									//Data from Channel 3 (L3)
	{attribute 'hide'}
	timDissableFunctions			: TON;											//Timer to dissable the Function after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days without connection to the Lynus Cloud
	{attribute 'hide'}
	timResetConnectionOnGVL			: TON;											//Timer to try reset the connection Flag on the GVL. (When somebody delete the Connection Function and make only a onlinechange)
	{attribute 'hide'}
	timSetCounterValues				: TON;											//Timer to set the counter values from the KL3403 Function to the EM Function
	{attribute 'hide'}
	arrPD							: ARRAY[1..7] OF FB_PersistentData_Number;		//Function to save persistent data
	{attribute 'hide'}
	byWaitInStep					: BYTE;											//Wait in Step before start to clean data on PLC
	{attribute 'hide'}
	iStateGVLData					: INT;											//State machine to handle the data on the GVL
	{attribute 'hide'}
	diCounterForGVL					: DINT;											//Counter to clean old data on GVL
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Kai Ebensperger
//Company : Lynus AG
//Date : 04.10.2021
//Version : 1.0.0.0

//Stefan: Addes S and Q calculation

//With this function is possible to read out all Information from a KL3403
//This Function support only the Simple Process Image and the Ratio in the Terminal register must be Set allways to 1.

//NOTE for diNr.....Designation => 
//_IN = Here Data come in from other Functions or go out to other functions about the GVL
//_OUT = Here Data go out to other functions about the GVL

(*-------------------------------------------------------------Calcualte the number of EM---------------------------------------------------------------*)

fbNumberDevice(
	diActualNumberOfDevices:= Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters, 
	diMaxNumberOfDevices:= Constants_Energy.diMaxNumberOfElectricMeters, 
	udiCounterOnlineChange:= TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, 
	bNumberIsCalculatet=> , 
	bFPNumberIsCalculatet=> , 
	bOnlineChange=> , 
	diNumberForThisDevice=> diNrOfEM_OUT, 
	diNumberOfTotalDevices=> );

//Write new Numer on GVL
IF fbNumberDevice.bFPNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters := fbNumberDevice.diNumberOfTotalDevices;	
END_IF

//Delete old Number on GVL
IF fbNumberDevice.bOnlineChange THEN 
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters := diNrOfEM_OUT;	
		iStateGVLData := 1; 
END_IF

(*-------------------------------------------------------------Service from Backend is ready and check the connection to backen for dissabel/enable Function---------------------------------------------------------------*)

//Try to reset the variable for connection on the GVL. When all is normal then the Lynus Mqtt connection function set this variable to true in the next cycle
//When we have no connection to the backend then after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions days the Function is dissabled with all of his functionalities
timResetConnectionOnGVL(IN:= NOT timResetConnectionOnGVL.Q, PT:= T#1H, Q=> , ET=> );
	IF timResetConnectionOnGVL.Q THEN Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := FALSE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions THEN timDissableFunctions.IN := TRUE; ELSE timDissableFunctions.IN := FALSE; END_IF  
			timDissableFunctions(IN:= , PT:= Lynus_Standards.Constants_General.tTimeDissableLynusFunctions, Q=> , ET=> );

(*----------------------------------------------------------------------------------------KL3403 Communication----------------------------------------------------------------------------------------------*)

fbKL3403(
	uiKBusState_IN:= uiKBusState_IN, 
	uiCurrentTransformerRatioL1:= uiCurrentTransformerRatioL1,
	uiCurrentTransformerRatioL2:= uiCurrentTransformerRatioL2,
	uiCurrentTransformerRatioL3:= uiCurrentTransformerRatioL3,
	rResolutionCurrent:= 0.001,
	rResolutionPower:= 0.1,
	rResolutionEnergy:= 0.01,
	stDataL1=> , 
	stDataL2=> ,
	stDataL3=> );

//Invert the Output data, because it is possible that the current transformers have been mounted in different mounting positions.
IF NOT bChannel1Invers THEN
	stDataL1 := fbKL3403.stDataL1;
ELSE
	stDataL1.byErrorWarning := fbKL3403.stDataL1.byErrorWarning;
	stDataL1.rCurrent := fbKL3403.stDataL1.rCurrent;
	stDataL1.rVoltage := fbKL3403.stDataL1.rVoltage;
	stDataL1.rPower := fbKL3403.stDataL1.rPower * - 1;
	stDataL1.rPowerfactor := fbKL3403.stDataL1.rPowerfactor;
	stDataL1.rEnergy := fbKL3403.stDataL1.rEnergy;
	stDataL1.rFrequency := fbKL3403.stDataL1.rFrequency;
	stDataL1.rPeakValueCurrent := fbKL3403.stDataL1.rPeakValueCurrent;
	stDataL1.rPeakValueVoltage := fbKL3403.stDataL1.rPeakValueVoltage;
	stDataL1.rPeakValuePower := fbKL3403.stDataL1.rPeakValuePower * - 1;
	stDataL1.rMinValueCurrent := fbKL3403.stDataL1.rMinValueCurrent;
	stDataL1.rMinValueVoltage := fbKL3403.stDataL1.rMinValueVoltage;
	stDataL1.rMinValuePower := fbKL3403.stDataL1.rMinValuePower * - 1;
END_IF

IF NOT bChannel2Invers THEN
	stDataL2 := fbKL3403.stDataL2;
ELSE
	stDataL2.byErrorWarning := fbKL3403.stDataL2.byErrorWarning;
	stDataL2.rCurrent := fbKL3403.stDataL2.rCurrent;
	stDataL2.rVoltage := fbKL3403.stDataL2.rVoltage;
	stDataL2.rPower := fbKL3403.stDataL2.rPower * - 1;
	stDataL2.rPowerfactor := fbKL3403.stDataL2.rPowerfactor;
	stDataL2.rEnergy := fbKL3403.stDataL2.rEnergy;
	stDataL2.rFrequency := fbKL3403.stDataL2.rFrequency;
	stDataL2.rPeakValueCurrent := fbKL3403.stDataL2.rPeakValueCurrent;
	stDataL2.rPeakValueVoltage := fbKL3403.stDataL2.rPeakValueVoltage;
	stDataL2.rPeakValuePower := fbKL3403.stDataL2.rPeakValuePower * - 1;
	stDataL2.rMinValueCurrent := fbKL3403.stDataL2.rMinValueCurrent;
	stDataL2.rMinValueVoltage := fbKL3403.stDataL2.rMinValueVoltage;
	stDataL2.rMinValuePower := fbKL3403.stDataL2.rMinValuePower * - 1;
END_IF

IF NOT bChannel3Invers THEN
	stDataL3 := fbKL3403.stDataL3;
ELSE
	stDataL3.byErrorWarning := fbKL3403.stDataL3.byErrorWarning;
	stDataL3.rCurrent := fbKL3403.stDataL3.rCurrent;
	stDataL3.rVoltage := fbKL3403.stDataL3.rVoltage;
	stDataL3.rPower := fbKL3403.stDataL3.rPower * - 1;
	stDataL3.rPowerfactor := fbKL3403.stDataL3.rPowerfactor;
	stDataL3.rEnergy := fbKL3403.stDataL3.rEnergy;
	stDataL3.rFrequency := fbKL3403.stDataL3.rFrequency;
	stDataL3.rPeakValueCurrent := fbKL3403.stDataL3.rPeakValueCurrent;
	stDataL3.rPeakValueVoltage := fbKL3403.stDataL3.rPeakValueVoltage;
	stDataL3.rPeakValuePower := fbKL3403.stDataL3.rPeakValuePower * - 1;
	stDataL3.rMinValueCurrent := fbKL3403.stDataL3.rMinValueCurrent;
	stDataL3.rMinValueVoltage := fbKL3403.stDataL3.rMinValueVoltage;
	stDataL3.rMinValuePower := fbKL3403.stDataL3.rMinValuePower * - 1;
END_IF
	
(*----------------------------------------------------------------------------------------Energy Counter Function----------------------------------------------------------------------------------------------*)

//For the KL3403 we use a external Energy Counter Function. So we can count Import and Export Energy with the KL3403.
//Attetntion, the KL3403 is not MID Conform. Thus, these values must not be used for billing.
fbEnergyCounter(
	byActiveTariff:= 1, 
	lrPowerInput:= (stDataL1.rPower + stDataL2.rPower + stDataL3.rPower) / 1000, 
	lrTotalCounterEnergy_Consumption=> , 
	lrTotalCounterEnergy_Production=> , 
	lrCounterEnergyT1_Consumption=> , 
	lrCounterEnergyT2_Consumption=> , 
	lrCounterEnergyT1_Production=> , 
	lrCounterEnergyT2_Production=> );

(*----------------------------------------------------------------------------------------Electric Meter Function----------------------------------------------------------------------------------------------*)

//Error
IF timDissableFunctions.Q THEN fbEM.bWarning := TRUE; fbEM.iWarningCode := 0; ELSE fbEM.bWarning := FALSE; END_IF 
	IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters > Constants_Energy.diMaxNumberOfElectricMeters OR 
		stDataL1.byErrorWarning = 2 OR stDataL2.byErrorWarning = 2 OR stDataL3.byErrorWarning = 2 THEN 
			fbEM.bError := TRUE; 
	ELSE 
			fbEM.bError := FALSE; 
	END_IF
		IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters > Constants_Energy.diMaxNumberOfElectricMeters THEN fbEM.iErrorCode := 1;
		ELSIF stDataL1.byErrorWarning = 2 OR stDataL2.byErrorWarning = 2 OR stDataL3.byErrorWarning = 2 THEN fbEM.iErrorCode := 0;
		END_IF

timSetCounterValues(IN:= bEnable AND NOT timSetCounterValues.Q, PT:= T#2S, Q=> , ET=> );		

//Function
fbEM(
	bEnable:= bEnable AND NOT timDissableFunctions.Q, 
	bError:= , 
	bEnableReadOutFunction:= FALSE, 
	bWriteWithDelay:= TRUE, 
	bPowerDataInvers:= FALSE,
	bReadOutDataDone:= timSetCounterValues.Q,
	iTimeReadOutInterval:= 0, 
	iErrorCode:= , 
	iWarningCode:= , 
	lrTotalCounterEnergy_Consumption:= fbEnergyCounter.lrTotalCounterEnergy_Consumption,
	lrTotalCounterEnergy_Production:= fbEnergyCounter.lrTotalCounterEnergy_Production, 
	lrCounterEnergyT1_Consumption:= fbEnergyCounter.lrCounterEnergyT1_Consumption,
	lrCounterEnergyT2_Consumption:= fbEnergyCounter.lrCounterEnergyT2_Consumption,
	lrCounterEnergyT1_Production:= fbEnergyCounter.lrCounterEnergyT1_Production, 
	lrCounterEnergyT2_Production:= fbEnergyCounter.lrCounterEnergyT2_Production, 
	lrCurrentL1:= stDataL1.rCurrent, 
	lrVoltageL1N:= stDataL1.rVoltage, 
	lrVoltageL1L2:= stDataL1.rVoltage*SQRT(3), 
	lrPowerL1:= stDataL1.rPower, 
	lrCurrentL2:= stDataL2.rCurrent, 
	lrVoltageL2N:= stDataL2.rVoltage, 
	lrVoltageL2L3:= stDataL2.rVoltage*SQRT(3), 
	lrPowerL2:= stDataL2.rPower, 
	lrCurrentL3:= stDataL3.rCurrent, 
	lrVoltageL3N:= stDataL3.rVoltage, 
	lrVoltageL3L1:= stDataL3.rVoltage*SQRT(3), 
	lrPowerL3:= stDataL3.rPower, 
	lrPowerTotal:= stDataL1.rPower + stDataL2.rPower + stDataL3.rPower, 
	lrFrequency:= (stDataL1.rFrequency + stDataL2.rFrequency + stDataL3.rFrequency) / 3, 
 	lrApparentPowerTotal:=,
	lrReactivePowerTotal:=, 
	tTimDelayOutput:= T#5S, 
	stDataEMOutPower=> stDataEMPowerRealTime, 
	stDataEMOutPowerDelay=> stDataEMPower, 
	stDataEMOutCounter=> stDataEMCounterRealTime,
	stDataEMOutCounterDelay=> stDataEMCounter,
	bReadOutMeter=> );


	//calculate total apparant power in VA
	fbEM.lrApparentPowerTotal := fbEM.lrVoltageL1N * fbEM.lrCurrentL1 + fbEM.lrVoltageL2N * fbEM.lrCurrentL2 +  fbEM.lrVoltageL3N * fbEM.lrCurrentL3;
	
	IF fbEM.lrApparentPowerTotal<>0 AND fbEM.lrPowerTotal<>0 AND fbEM.lrApparentPowerTotal> ABS(fbEM.lrPowerTotal) THEN
		fbEM.lrReactivePowerTotal:= SQRT(ABS(fbEM.lrApparentPowerTotal*fbEM.lrApparentPowerTotal - ABS(fbEM.lrPowerTotal*fbEM.lrPowerTotal)));	
	END_IF
	IF stDataL1.rPowerfactor<>0 AND stDataL2.rPowerfactor <>0 AND stDataL3.rPowerfactor<>0 THEN 	// check that not all cos phi are not 0
		IF (stDataL1.rPowerfactor+stDataL2.rPowerfactor+stDataL3.rPowerfactor)<>0 THEN				// check that the sum is not 0	
			IF 	(stDataL1.rPowerfactor+stDataL2.rPowerfactor+stDataL3.rPowerfactor)/3<0 THEN		// check is the average is below 0 / capacitive
				fbEM.lrReactivePowerTotal:=fbEM.lrReactivePowerTotal*(-1);
			END_IF
		END_IF	
	END_IF
	
	//added Powerfactor output
	lrPowerfactorL1 := stDataL1.rPowerfactor;
	lrPowerfactorL2 := stDataL2.rPowerfactor;
	lrPowerfactorL3 := stDataL3.rPowerfactor;
	
	//added Apparent Power per Phase output
	lrApparentPowerL1 := (fbEM.lrVoltageL1N * fbEM.lrCurrentL1) / 1000;
	lrApparentPowerL2 := (fbEM.lrVoltageL2N * fbEM.lrCurrentL2) / 1000;
	lrApparentPowerL3 := (fbEM.lrVoltageL3N * fbEM.lrCurrentL3) / 1000;
	
	//added Reactive Power per Phase output
	lrReactivePowerL1 := SQRT(ABS(lrApparentPowerL1*lrApparentPowerL1 - ABS(fbEM.lrPowerL1 *fbEM.lrPowerL1))) / 1000;
	lrReactivePowerL2 := SQRT(ABS(lrApparentPowerL2*lrApparentPowerL2 - ABS(fbEM.lrPowerL2 *fbEM.lrPowerL2))) / 1000;
	lrReactivePowerL3 := SQRT(ABS(lrApparentPowerL3*lrApparentPowerL3 - ABS(fbEM.lrPowerL3 *fbEM.lrPowerL3))) / 1000;
	
(*-----------------------------------------------------------Handle data to Global structure for Electric Meter-----------------------------------------------------------------*)

CASE iStateGVLData OF
	
	0://Init Step
		byWaitInStep := 0;
			diCounterForGVL := 1;
	
	1://Wait for 4 Steps before clean al Data on GVL
		byWaitInStep := byWaitInStep + 1;
			IF byWaitInStep >= 4 AND fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 2; END_IF
				//To much Devices, back to the Init step
				IF byWaitInStep >= 4 AND NOT fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 0; END_IF	
			
	2://Clear all Data in GVL
		Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].bEnabled := FALSE;	
			Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].byErrorWarning := 0;
				Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrCounterEnergyT1_Consumption := 0;
					Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrCounterEnergyT1_Production := 0;
						Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrCounterEnergyT2_Consumption := 0;
							Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrCounterEnergyT2_Production := 0;
								Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrPower := 0;
									Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrPowerConsumption := 0;
										Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrPowerProduction := 0;
											Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrTotalCounterEnergy_Consumption := 0;
												Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrTotalCounterEnergy_Production := 0;
		
		//Electric Meters
		diCounterForGVL := diCounterForGVL + 1;
			diCounterForGVL := LIMIT(0,diCounterForGVL,Constants_Energy.diMaxNumberOfElectricMeters);
				//Back to the init step
				IF diCounterForGVL >= Constants_Energy.diMaxNumberOfElectricMeters THEN iStateGVLData := 0; END_IF

END_CASE 	 

//Write Data on GVL for Electric Meter
IF diNrOfEM_OUT > 0 AND fbNumberDevice.bNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].bEnabled := fbEM.stDataEMOutPower.bEnabled;
		Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].byErrorWarning := fbEM.stDataEMOutPower.byErrorWarning;
			Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrCounterEnergyT1_Consumption := fbEM.stDataEMOutCounter.lrCounterEnergyT1_Consumption;
				Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrCounterEnergyT1_Production := fbEM.stDataEMOutCounter.lrCounterEnergyT1_Production;
					Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrCounterEnergyT2_Consumption := fbEM.stDataEMOutCounter.lrCounterEnergyT2_Consumption;
						Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrCounterEnergyT2_Production := fbEM.stDataEMOutCounter.lrCounterEnergyT2_Production;		
							Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrPower := fbEM.stDataEMOutPower.lrPowerTotal;
								Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrPowerConsumption := fbEM.stDataEMOutPower.lrPowerConsumption;
									Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrPowerProduction := fbEM.stDataEMOutPower.lrPowerProduction;
										Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrTotalCounterEnergy_Consumption := fbEM.stDataEMOutCounter.lrTotalCounterEnergy_Consumption;
											Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrTotalCounterEnergy_Production := fbEM.stDataEMOutCounter.lrTotalCounterEnergy_Production;
END_IF

(*----------------------------------------------------------Save persistent data----------------------------------------------------------------*)

arrPD[1](lrValue:= BOOL_TO_LREAL(bEnable), bEventBasedActive=> );
arrPD[2](lrValue:= UINT_TO_LREAL(uiCurrentTransformerRatioL1), bEventBasedActive=> );
arrPD[3](lrValue:= UINT_TO_LREAL(uiCurrentTransformerRatioL2), bEventBasedActive=> );
arrPD[4](lrValue:= UINT_TO_LREAL(uiCurrentTransformerRatioL3), bEventBasedActive=> );
arrPD[5](lrValue:= BOOL_TO_LREAL(bChannel1Invers), bEventBasedActive=> );
arrPD[6](lrValue:= BOOL_TO_LREAL(bChannel2Invers), bEventBasedActive=> );
arrPD[7](lrValue:= BOOL_TO_LREAL(bChannel3Invers), bEventBasedActive=> );]]></ST>
    </Implementation>
    <LineIds Name="FB_EM_Beckhoff_KL3403_T">
      <LineId Id="774" Count="3" />
      <LineId Id="1065" Count="0" />
      <LineId Id="1064" Count="0" />
      <LineId Id="778" Count="169" />
      <LineId Id="1069" Count="0" />
      <LineId Id="1066" Count="0" />
      <LineId Id="949" Count="0" />
      <LineId Id="951" Count="4" />
      <LineId Id="1346" Count="0" />
      <LineId Id="1343" Count="0" />
      <LineId Id="1235" Count="0" />
      <LineId Id="1342" Count="0" />
      <LineId Id="1341" Count="0" />
      <LineId Id="1234" Count="0" />
      <LineId Id="1180" Count="2" />
      <LineId Id="1288" Count="1" />
      <LineId Id="1183" Count="0" />
      <LineId Id="1290" Count="1" />
      <LineId Id="1126" Count="0" />
      <LineId Id="1448" Count="0" />
      <LineId Id="1450" Count="3" />
      <LineId Id="1460" Count="6" />
      <LineId Id="1449" Count="0" />
      <LineId Id="1467" Count="2" />
      <LineId Id="957" Count="57" />
      <LineId Id="673" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>