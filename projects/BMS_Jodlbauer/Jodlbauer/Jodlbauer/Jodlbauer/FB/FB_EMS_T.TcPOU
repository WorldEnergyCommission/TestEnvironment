<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_EMS_T" Id="{ab7151de-b2cd-42de-bf9c-faf0df9970c2}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_EMS_T
VAR_INPUT PERSISTENT
	bEnable										: BOOL;																								//{#lynus.ag#()} //Enable and dissable this function
	diNrOfEM_IN_ECS								: DINT;																								//Number of the electric meter for incoming power data. (Its for the complete consumption of all charging stations)
	stSetupEMS									: ST_Setup_EMS := (uiUpdateTime := 15);																//{#lynus.ag#()} //Setup EMS
	eOperationMode								: E_OperatingMode_EMS;																				//{#lynus.ag#()} //Operation Mode EMS
	eSpeedModeBackendController					: E_SpeedModeBackendController_EMS;																	//Speed for the Controller what discharge the Battery when the commands come from the Backend
	eSpeedModeLocalController					: E_SpeedModeLocalController_EMS;																	//Speed for the local Controller for charge and discharge the Battery
	b_ZeroPowerRegulation						: BOOL;																								//{#lynus.ag#()} // activates the Battery discharging before using the mains during LoadManagement; Line 1728/1732/1738 
	b_EnableBatteryChargingControl				: BOOL;																								//{#lynus.ag#()} //  
	b_StartReleaseBatteryCharging				: BOOL;																								//{#lynus.ag#()} //  
	b_StopReleaseBatteryCharging				: BOOL;																								//{#lynus.ag#()} //  
END_VAR
VAR_INPUT
	bActivateHP									: BOOL;																								//{#lynus.ag#()} //Activate the Heating pumps when the Backend deliver the signal. NOT OVERRIDE
	bControllingState							: BOOL;																								//{#lynus.ag#()} //The control state of the service is linked here. NOT OVERRIDE
	rHeartbeat									: REAL;																								//{#lynus.ag#()} //Heartbeat from the Service. NOT OVERRIDE
	rErrorWarning								: REAL;																								//{#lynus.ag#()} //Error or Warning from the Service. NOT OVERRIDE
	rEnergyOptReady								: REAL;																								//{#lynus.ag#()} //Energy Optimization Service Ready. NOT OVERRIDE
	rNewBattPower								: REAL;																								//{#lynus.ag#()} //New Battery Power from Backend Service. NOT OVERRIDE
	rMaxBattChargingPower						: REAL:=100;																								// Maximum Battery Charging power in percent
	rPeakDetectionforCalculation				: REAL:=3;																								// Value for Peak detection, was original 3 but caused issues with fast changing loads (e.g. industrie)
END_VAR
VAR_OUTPUT
	eMessageEMS									: Lynus_Standards.E_Message_EMS;																	//EMS Message
	bStateEnable								: BOOL;																								//{#lynus.ag#()} //Show if the ems function is enabled or not
	bStateAllowChrgFromGrid						: BOOL;																								//{#lynus.ag#()} //Show the State if the charging from grid is allowed or not
	bMissingPowerData							: BOOL;																								//Missing data on the max power setup from one ore more devices
	bSurplusAvailable							: BOOL;																								//Variable that indicates if there is surplus or not
	byProgress									: BYTE;																								//Shows the Progress from the new Calculation when we have Surplus. When we have no Surplus and we discharge the batterys this Value is on 100
	uiState_OUT									: UINT;																								//Actual State
	diNrOfEMS_OUT								: DINT;																								//Active Number from the EMS Function for using on other functions
	arrMinPrioReached							: ARRAY[1..5] OF BOOL;																				//Shows if all different devices types are set to 0% with the target power ([1] = Battery, [2] = HP, [3] = EHE, [4] = OBC, [5] = ECS)
	arrMaxPrioReached							: ARRAY[1..5] OF BOOL;																				//Shows if all different devices types are set to 100% with the target power ([1] = Battery, [2] = HP, [3] = EHE, [4] = OBC, [5] = ECS)	
	b_TimeBasedReleaseChargingBattery			: BOOL;																								//
END_VAR	
VAR
	(*-----------------------------------------------------------------------Internal Variables and Functions for connection to the Backend--------------------------------------------------------------------------------*)
	fbPIDDischrgCmdFromBackend					: FB_PID;																							//PID Contrller what controll the discharging power from the Battery when the controlling from backend is activated
	timDissableFunctions						: TON;																								//Timer to dissable the Function after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days without connection to the Lynus Cloud
	timResetConnectionOnGVL						: TON;																								//Timer to try reset the connection Flag on the GVL. (When somebody delete the Connection Function and make only a onlinechange)
	timHB										: TON;																								//Timer to check the Heartbeat from the Backendservice
	timPIDDischrgCmdFromBackend					: TON;																								//Timer to set the output from the pid controller to 0 due to internal control deviations (Backend Mode)
	timCorrectionSetpoint						: TOF;																								//Timer to make the correction on the Setpoint for Battery power. This is neccessary to give time to the inverter and Grid to adjust on the new values
	timErrorWarning								: TON;																								//Timer to enable the Function Backend Mode after a Error or Warning
	timEnergyOptReady							: TON;																								//Timer to enable the Function Backend Mode after the Backend Service is ready
	timControlingState							: TON;																								//Timer to enable the controlling over the Backend Mode
	timResetActivateHP							: TON;																								//Timer to reset the Activate HP Command from the Backend Service
	FPEnablePID									: R_TRIG;																							//Internal positive edge
	FPMakeCorrection							: R_TRIG;																							//Internal positive edge
	bDischrgCmdFromBackendOK					: BOOL;																								//Allowed to controll the Devices from Backend
	rHeartbeat_CP								: REAL;																								//Compare the Heartbeat from the Backend
	rControllerQPIDDischrgCmdFromBackend		: REAL;																								//Controller output from pid controll over Backend Mode
	rNewBattPower_CP							: REAL;																								//New Battery power to ckeck if we have received a new Value in kW
	lrActualPowerBatterys						: LREAL;																							//Actual Power from the Batterys in kW
	lrErrorPIDCorrectionDischrgCmdFromBackend	: LREAL;																							//Limit the Error on the pid controller for discahrge the battery on the controll over Backend Mode
	lrNewBatteryPowerWithCorrection				: LREAL;																							//The New Battery power from the Backend with correction that we dont insert power in the Grid
	liLPDischrgCmdFromBackend					: LINT;																								//Loop to send the command from Backend to the Devices
	(*-----------------------------------------------------------------------------------Rest of internal Variabels and Functions---------------------------------------------------------------------------------------*)
	fbMessagesEMS								: FB_EMS_Message;																					//FB to create the Messages for this Function
	fbNumberDevice								: FB_NumberOfDevice;																				//Function block to calcualte the number of the Device
	fbTaskIndex									: GETCURTASKINDEX;																					//Function to read out the Task Index in witch the function is running
	fbPIDBatterySC								: FB_PID;																							//PID Controller to discharge the battery in the self consumption mode
	fbPIDBatteryEPO								: FB_PID;																							//PID Controller to discharge the battery in the emergency power mode
	fbPIDBatteryPLCLM_Dischrg					: FB_PID;																							//PID Controller to Dischage the battery on load management mode and peak shaving mode
	fbPIDBatteryPLCLM_Chrg						: FB_PID;																							//PID Controller to Charge the battery on load management mode and peak shaving mode
	timCalculateNewPowerValue					: TON;																								//Timer to start a new session to calculate the new power value for the devices
	timPIDSC									: TON;																								//Timer to set the output from the pid controller to 0 due to internal control deviations (Self consumption mode)
	timPIDEPO									: TON;																								//Timer to set the output from the pid controller to 0 due to internal control deviations (Emergency power mode)
	timCorrectionECS							: TON;																								//Timer for make the correction for ECS in the Load management and peak capping mode with use the separate fuse
	timErrorGridMessurement						: TON;																								//Timer with delay to stop the EMS Function if we have a error on the Grid messurement
	timTimeout									: TON;																								//Timer for Timout
	timCutPeaks									: TOF;																								//Timer to cut peaks on the grid. The system waits for this time for strong and short peaks before regulating.
	timDelayStart								: TOF;																								//Timer with the delay to start the ems function after a online change
	timResetDisableECS							: TOF;																								//Timer to reset the dissbling the ECS after a Error from the Electric Meter what messure the power from all ECS
	FPEPO										: R_TRIG;																							//Internal positive edge
	FNEPO										: F_TRIG;																							//Internal negative edge
	eOperationModeEMS_CP						: E_OperatingMode_EMS;																				//Operation Mode EMS/Battery to compare with the original variable
	arrPD										: ARRAY[1..12] OF FB_PersistentData_Number;															//Function to save persistent data
	arrTimBatterysAreFull						: ARRAY[1..Constants_Energy.diMaxNumberOfBatteryInverters] OF TON;									//Timer start for each Battery when is full
	arrActualStepInTurn_CP						: ARRAY[1..2] OF BYTE;																				//Actual Step in turn to compare with original variable
	arrActualPrioInTurn							: ARRAY[1..5] OF BYTE;																				//Actual Priority (1-255) that is currently in turn ([1] = Battery, [2] = HP, [3] = EHE, [4] = OBC, [5] = ECS)
	arrActualStepInTurn							: ARRAY[1..2] OF BYTE;																				//Actual Step (1-10) from step switched devices that is currently in turn ([1] = HP, [2] = EHE)
	arrLPPrioZeroSetToZeroP						: ARRAY[1..5] OF LINT;																				//Array with loop to set each device with priority 0 to the target power value 
	arrCTCheckActivePrio						: ARRAY[1..5] OF LINT;																				//Array with loop to check the actual prioritys
	bEPMActive									: BOOL;																								//Emergency power mode is active
	bChargePrioBatterysOnEPO					: BOOL;																								//Load batterys that made a island grid first to the adjustable SOC before start with al other devices
	bStepWasOn100								: BOOL;																								//Its true when the actual step from step switched devices was on 100%
	bECSPrio255									: BOOL;																								//True when we reached the max prio of the charging stations
	bStopAll									: BOOL;																								//Stop the EMS when we some is happend what make trouble
	bDisableECS									: BOOL;																								//Dissable the ECS when the EM what messure the power from all ECS has a error
	bErrorOnGridMessurement						: BOOL;																								//Shows if on the Grid Messurement is a error and stop then the EMS Function
	bNoPowerForECS								: BOOL;																								//Variable what shows that we dont can give more power on the ECS because we have to much power on the Fuse line on wich the ECS is connected
	bySmGrActiveCommonPrio_CP					: BYTE;																								//Smalest or greatest active common priority of the devices to compare with the original varible
	byLPSmActiveCommonPrio						: BYTE;																								//Loop to check the smalest active common priority
	bySmGrActiveCommonPrio						: BYTE;																								//Smalest or greatest active common priority of the devices
	bySearchBigestPrio							: BYTE;																								//Search the biggest Prio for each device in the Steps in what we choose the prio
	uiState										: UINT;																								//Actual State
	uiState_CP									: UINT;																								//Actual State to compare for activating the timout timer
	diNumberOfDevicesFromEachType				: DINT;																								//Count the Number of each Device what has a priority <> 0
	diMemCmpOperationState						: DINT;																								//Variable to compare the operation state			
	diNumberOfActiveBatterys					: DINT;																								//Number of active batterys
	diNumberOfBatteryInverterInEPO				: DINT;																								//Number of battery inverters that work in Emergency Power operation 
	diNrOfEM_IN_CS_CP							: DINT;																								//Number of the electric meter for receive data. (Its for the complete consumption of all charging stations to compare)
	diNumberOfECS								: DINT;																								//Number of total charging stations on what the power must reduced with the max fuse power
	diBiggestNumberOfDeviceConstants			: DINT;																								//Biggest Number of the constants for the several device types. Needs to calcualte the delay for the timout timer
	dwSumSOC									: DWORD;																							//Sum of the SOC from all batterys
	dwSumSOCInEPO								: DWORD;																							//Sum of the SOC from all batterys that make a island mode at the moment
	dwAvarageBatterySOC							: DWORD;																							//Actual avarage Battery SOC from each Battery
	dwAvarageBatterySOCInEPO					: DWORD;																							//Actual avarage Battery SOC from each Battery that make a island mode at the moment
	udiCounterOnlineChange_CP					: UDINT;																							//Counter for online change to comapre it	
	udiCycleTime								: UDINT;																							//Cycle time in wich the function is running. Needs to calculate the delay for the timout timer
	rValuePercentToControllableDevices			: REAL;																								//Percent value to set the target power to controllable devices
	rValuePercentToStepSwitchedDevices			: REAL;																								//Percent value to set the target power to on/off or step switched devices
	rControllerQPIDSC							: REAL;																								//Controller output from pid self consumption
	rControllerQPIDEPO							: REAL;																								//Controller output from pid emergency power operation
	rSizeMainFuseCS_CP							: REAL;																								//Size of the main fuse form the charging stations to compare with the original varialbe
	lrTargetPowerCorrectionECS					: LREAL;																							//New Target power for chargign station after correction with max fuse power
	lrPowerDiffFuseECS							: LREAL;																							//Power difference between max fuse power charging station and actual power for all charging stations 
	lrPowerForCalculateECS						: LREAL;																							//Power to calcualte the % for each charging station
	lrGridPower									: LREAL;																							//Grid power in kW
	lrGridPower_CP								: LREAL;																							//Grid power in kW to compare for correction when the backend is controlling the battery
	lrSizeBatteryPowerInEPO						: LREAL;																							//Power in kW of all Battery inverters that are made a island mode at the moment
	lrSizeGridConnection						: LREAL;																							//Size of the complete grid connection
	lrActualSurplusOrConsumption				: LREAL;																							//Actual surplus or consumption in kW
	lrActualSurplusOrConsumptionOld				: LREAL;																							//Old value from last step with surplus or consumption in kW
	lrMaxPowerDevicesWithActualPrio				: LREAL;																							//Actual complete max power from all devices with the same priority
	lrErrorPIDCorrectionBattSC					: LREAL;																							//Limit the Error on the pid controller for discahrge the battery on the self consumption mode
	lrErrorPIDCorrectionBattEPO					: LREAL;																							//Limit the Error on the pid controller for discahrge the battery on the emergency power operation mode
	lrErrorPIDCorrectionBattPLCLM_Dischrg		: LREAL;																							//Limit the Error on the pid controller for discahrge the battery on the load management mode and peak shaving mode
	lrErrorPIDCorrectionBattPLCLM_Chrg			: LREAL;																							//Limit the Error on the pid controller for charge the battery on the load management mode and peak shaving mode
	liCounterCkeckDeviceAndPrio					: LINT;																								//Counter to ckeck the device and Prio in the Steps for HP and EHE. Here we didn't can use a loop regarding performance problems on small PLC
	liNrOfNotDoneDevices						: LINT;																								//Shows the Numer of Devices what are not controlled with the minimum or the maximum power when we have a actual Prio from 1 or 255. That we can set the min reached or max reached Flag
	liLPCheckDeviceAndPrio						: LINT;																								//Loop to ckeck the Number of Devices and the Prio
	liLPGridData								: LINT;																								//Loop to check some grid data
	liLPActualSurplusOrConsumption				: LINT;																								//Loop to check actual surplus or consumption
	liLPBatterysSetupData						: LINT;																								//Loop to copy the setup data from the battery inverters
	liLPBatteryData								: LINT;																								//Loop to check some data from batterys
	liLPSumSOCInEPO								: LINT;																								//Loop to calculate the sum of the SOC from all batterys that buils a island mode at the moment
	liLPInEPO									: LINT;																								//Loop to check if 1 or more battery inverters build a island grid
	liLPCheckMaxPower							: LINT;																								//Loop to ckeck the max power from each device
	liLPSetPercentPower							: LINT;																								//Loop to set the calculatet percetn power to the device
	liLPCorrectionPowerCS						: LINT;																								//Loop to make a correction on the target power from the charging stations in dependence of the max fuse power 
	liLPDataBatteryInverter						: LINT;																								//Loop to check or set data from battery inverters
	RS_BatteryChargingControl: RS;
	mtest1: BOOL;
	mtest2: BOOL;
	mTest3: BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Zeile 116			bStopAll := FALSE;				gehört gelöst


//Creator : Kai Ebensperger + add on Stefan  V2.0.0.1
//Company : Lynus AG
//Date : 29.05.2021
//Version : 2.0.0.1

//With this FB the EMS control can be realized on the PLC. 
//This divides the excess energy among the devices according to priority
//Devices with priority 0 received as target power 0
//If we have less or no surplus, then the target power will be reduced or remains on the same value
//The EMS function can handle batterie devices, controllable devices, On/Off devices and step switched devices. 
//If we have no surplus, and all devices has a target power from 0, then the battery try to balancing the consumption.
//This depends what operation mode is active
//If the mode load managemant is active, for the charging station the max power from the fuse is neccessary, because the ems dont can use all the power from the max. grid power for the charging stations.  
//When a Batteryinverter or Batterysystem is in Island mode, then ems send to this system automatic -100%. The rest must be regulate the function from the batteryinverter. 
//All other battery inverters or battery systems that do not do islanding are treated by the EMS as normal devices with their priorities.
//This EMS can handle 5 device types (Battery, Heating Pump, Electric heating element, Electric charging station and other big consumers)
//This Function receive also Data from a Backend System. In this Backend System runs different ML-Models.
//So its possible that the Backend System controlls the Heating Pumps when its neccessary and also the discharging from the Batterys.
//This make sense when we have bad wheater, less PV-power in the next 24h to switch on the Heating Pumps or cover the consumption.......
//This EMS Function work only with our Backend Communication Library. After 11 Days no communication to our Backend system or no received new HB the Function dissable automatically and set a Message for this at the output
//When we receiven no HB, no Backend Service Ready Flag or an Error from the Backend Service then the Controlling over the Backend is dissabled and the EMS Function run in his "normal" Mode.

//NOTE for diNr.....Designation => 
//_IN = Here Data come in from other Functions or go out to other functions about the GVL
//_OUT = Here Data go out to other functions about the GVL

// V2.0.0.1
// added option b_ZeroPowerRegulation (Line 1728/1732/1738) 
// added option for disable charging the battery (e.g. for only charging in the night) line 1811 (b_EnableBatteryChargingControl) and 2179 ff(b_EnableBatteryChargingControl,b_StartReleaseBatteryCharging,b_StopReleaseBatteryCharging)
(*------------------------------------------------------------Limits----------------------------------------------------------------------------------*)

stSetupEMS.rSizeMainFuseCS := LIMIT(0,stSetupEMS.rSizeMainFuseCS,500);
	stSetupEMS.uiUpdateTime := LIMIT(1,stSetupEMS.uiUpdateTime,600);
		stSetupEMS.byResChrgfromGridToBatt := LIMIT(0,stSetupEMS.byResChrgfromGridToBatt,100);
			diNrOfEM_IN_ECS := LIMIT(0,diNrOfEM_IN_ECS,Constants_Energy.diMaxNumberOfElectricMeters);
				rHeartbeat := LIMIT(0,rHeartbeat,1);
					rErrorWarning := LIMIT(0,rErrorWarning,2);
						rEnergyOptReady := LIMIT(0,rEnergyOptReady,1);
							rNewBattPower := LIMIT(0,rNewBattPower,100000);				
								rMaxBattChargingPower := LIMIT(0,rMaxBattChargingPower,100);
									rPeakDetectionforCalculation := LIMIT(3,rPeakDetectionforCalculation,100); 

stSetupEMS.rSizeMainFuseCS := DINT_TO_REAL(REAL_TO_DINT(stSetupEMS.rSizeMainFuseCS * 10)) / 10;
		
IF stSetupEMS.byMaxDepthOfDischrgEPO > stSetupEMS.byReserveSOCEPO THEN stSetupEMS.byReserveSOCEPO := stSetupEMS.byMaxDepthOfDischrgEPO + 1; END_IF
	IF stSetupEMS.byMaxDepthOfDischrgEPO > stSetupEMS.byPrioMinChrgBattSOCInEPO THEN stSetupEMS.byPrioMinChrgBattSOCInEPO := stSetupEMS.byMaxDepthOfDischrgEPO + 1; END_IF
		IF stSetupEMS.byReserveSOCEPO > stSetupEMS.byPrioMinChrgBattSOCInEPO THEN stSetupEMS.byPrioMinChrgBattSOCInEPO := stSetupEMS.byReserveSOCEPO + 1; END_IF
		
stSetupEMS.byMaxDepthOfDischrgEPO := LIMIT(0,stSetupEMS.byMaxDepthOfDischrgEPO,100);
	stSetupEMS.byReserveSOCEPO := LIMIT(0,stSetupEMS.byReserveSOCEPO,100);
		stSetupEMS.byPrioMinChrgBattSOCInEPO := LIMIT(20,stSetupEMS.byPrioMinChrgBattSOCInEPO,75);

(*-------------------------------------------------------------Calcualte the number of EMS---------------------------------------------------------------*)

//Online change
timDelayStart(IN:= udiCounterOnlineChange_CP <> TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, PT:= T#15S, Q=> , ET=> );

fbNumberDevice(
	diActualNumberOfDevices:= Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfEMS, 
	diMaxNumberOfDevices:= Constants_Energy.diMaxNumberOfEMS, 
	udiCounterOnlineChange:= TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, 
	bNumberIsCalculatet=> , 
	bFPNumberIsCalculatet=> , 
	bOnlineChange=> , 
	diNumberForThisDevice=> diNrOfEMS_OUT, 
	diNumberOfTotalDevices=> );

//Write new Numer on GVL
IF fbNumberDevice.bFPNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfEMS := fbNumberDevice.diNumberOfTotalDevices;	
END_IF 

//Delete old Number on GVL
IF fbNumberDevice.bOnlineChange THEN 
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfEMS := diNrOfEMS_OUT;	
		udiCounterOnlineChange_CP := TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt; 
END_IF

(*-------------------------------------------------------------Service from Backend is ready and check the connection to backen for dissabel/enable EMS Function---------------------------------------------------------------*)

//Try to reset the variable for connection on the GVL. When all is normal then the Lynus Mqtt connection function set this variable to true in the next cycle
//When we have no connection to the backend or no HB from the Service then after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions days the EMS is dissabled with all of his functionalities
timResetConnectionOnGVL(IN:= NOT timResetConnectionOnGVL.Q, PT:= T#1H, Q=> , ET=> );
	IF timResetConnectionOnGVL.Q THEN Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := FALSE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions OR rHeartbeat_CP = rHeartbeat THEN timDissableFunctions.IN := TRUE; ELSE timDissableFunctions.IN := FALSE; END_IF  
			timDissableFunctions(IN:= , PT:= Lynus_Standards.Constants_General.tTimeDissableLynusFunctions, Q=> , ET=> );
	
//Heartbeat, Service Ready and ErrorWarning from Service
timHB(IN:= , PT:= T#130S, Q=> , ET=> );	
	IF rHeartbeat <> rHeartbeat_CP THEN 
		timHB.IN := FALSE; rHeartbeat_CP := rHeartbeat; 
	ELSE 
		timHB.IN := TRUE; 
	END_IF

//Error/Warning Timer and Service Ready Timer
timErrorWarning(IN:= rErrorWarning = 0, PT:= T#10S, Q=> , ET=> );
	timEnergyOptReady(IN:= rEnergyOptReady <> 0, PT:= T#10S, Q=> , ET=> );
		timControlingState(IN:= bControllingState, PT:= T#10S, Q=> , ET=> );
	
IF timErrorWarning.Q AND timEnergyOptReady.Q AND NOT bControllingState AND NOT timHB.Q AND NOT timDissableFunctions.Q THEN bDischrgCmdFromBackendOK := TRUE; END_IF
	IF rErrorWarning <> 0 OR rEnergyOptReady = 0 OR timControlingState.Q OR timHB.Q OR timDissableFunctions.Q OR NOT bEnable OR eOperationMode = E_OperatingMode_EMS.eAllOff THEN bDischrgCmdFromBackendOK := FALSE; END_IF
	
(*-------------------------------------------------------------Check the number of the device types what are neccessary for EMS---------------------------------------------------------------*)	
	
//To much Devices, Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days no connection to the backend or Error on the Grid Messurement stop the EMS and set al target power to 0
IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfEMS > Constants_Energy.diMaxNumberOfEMS OR Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfBatteryInverters > Constants_Energy.diMaxNumberOfBatteryInverters OR
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfBatterys > Constants_Energy.diMaxNumberOfBatterys OR Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS > Constants_Energy.diMaxNumberOfElectricChargingStations OR
		Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfEHE > Constants_Energy.diMaxNumberOfElectricHeatingElements OR Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters > Constants_Energy.diMaxNumberOfElectricMeters OR
			Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfGenerators > Constants_Energy.diMaxNumberOfGenerators OR Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfGrids > Constants_Energy.diMaxNumberOfGridConnections OR
				Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfHouseConsumption > Constants_Energy.diMaxNumberOfHouseConsumptions OR Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfHP > Constants_Energy.diMaxNumberOfHeatingPumps OR
					Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfOBC > Constants_Energy.diMaxNumberOfOtherBigConsumers OR Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfPvSystems > Constants_Energy.diMaxNumberOfPvSystems OR
						Lynus_Standards.GVL_Sensors.diNumberOfTemperatureSensors > Constants_Sensors.diMaxNumberOfTemperatureSensors OR timDelayStart.Q OR timDissableFunctions.Q OR timErrorGridMessurement.Q THEN 
							bStopAll := TRUE; 
							ELSE 
							bStopAll := FALSE;
END_IF

(*------------------------------------------------------------------------Enable-------------------------------------------------------------------------------*)		
		
bStateEnable := bEnable;

(*--------------------------------------------------------------Allow charging from grid-----------------------------------------------------------------------*)		
		
bStateAllowChrgFromGrid := stSetupEMS.bAllowChrgFromGrid;

(*--------------------------------------------------------------calcualte battery data-----------------------------------------------------------------------*)		
		
//Calcualte the total SOC if we have more then 1 battery in our system
	
diNumberOfActiveBatterys := 0;
	dwSumSOC := 0;
		FOR liLPBatteryData := 1 TO Constants_Energy.diMaxNumberOfBatterys BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_OUT,liLPBatteryData].bEnabled THEN diNumberOfActiveBatterys := diNumberOfActiveBatterys + 1; END_IF
				dwSumSOC := dwSumSOC + Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_OUT,liLPBatteryData].dwSOC;
		END_FOR
	
dwSumSOCInEPO := 0;
	FOR liLPSumSOCInEPO := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
		IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSumSOCInEPO].bWorkOnIslandMode THEN dwSumSOCInEPO := dwSumSOCInEPO + Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSumSOCInEPO].dwBatterySOC; END_IF
	END_FOR		
		
IF diNumberOfActiveBatterys > 0 THEN
	dwAvarageBatterySOC := DINT_TO_DWORD(DWORD_TO_DINT(dwSumSOC) / diNumberOfActiveBatterys);
END_IF

//Check if one or more Batterysystems or batteryinverter make island mode

diNumberOfBatteryInverterInEPO := 0;
	FOR liLPInEPO := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
		IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPInEPO].bWorkOnIslandMode THEN bEPMActive := TRUE; diNumberOfBatteryInverterInEPO := diNumberOfBatteryInverterInEPO + 1; END_IF
	END_FOR 

IF diNumberOfBatteryInverterInEPO > 0 THEN
	dwAvarageBatterySOCInEPO := DINT_TO_DWORD(DWORD_TO_DINT(dwSumSOCInEPO) / diNumberOfBatteryInverterInEPO);
ELSE
	dwAvarageBatterySOCInEPO := 0;
END_IF
	
IF diNumberOfBatteryInverterInEPO <= 0 THEN bEPMActive := FALSE; END_IF

//Check the max. power of the grid connection and the sum of grid power
lrSizeGridConnection := 0;
	lrGridPower := 0;
		bErrorOnGridMessurement := FALSE;
			FOR liLPGridData := 1 TO Constants_Energy.diMaxNumberOfGridConnections BY 1 DO
				lrSizeGridConnection := lrSizeGridConnection + Lynus_Standards.GVL_Energy.stDataGridConnections[diNrOfEMS_OUT,liLPGridData].rSizeGridConn;
					lrGridPower := lrGridPower + Lynus_Standards.GVL_Energy.stDataGridConnections[diNrOfEMS_OUT,liLPGridData].lrPower;
						IF Lynus_Standards.GVL_Energy.stDataGridConnections[diNrOfEMS_OUT,liLPGridData].byErrorWarning = 2 THEN bErrorOnGridMessurement := TRUE; END_IF 
			END_FOR

//Error on Grid Messurement. (Stop the EMS Function)
timErrorGridMessurement(IN:= bErrorOnGridMessurement, PT:= T#30S, Q=> , ET=> );
	
//Timer for peaks to cut this
timCutPeaks(IN:= , PT:= T#2.5S, Q=> , ET=> );	

(*--------------------------------------------------------------Timeout-----------------------------------------------------------------------*)	

//Timout is using to go on next step if somthing goes wrong in the steps in what we check the next priority from the several devices
IF uiState = uiState_CP AND uiState >= 30 AND uiState <= 110 THEN timTimeout.IN := TRUE; ELSE timTimeout.IN := FALSE; END_IF
	//Choose the right Delay. Depending from the maximum of allowed Devices
	diBiggestNumberOfDeviceConstants := 0;
		IF Constants_Energy.diMaxNumberOfBatterys > diBiggestNumberOfDeviceConstants THEN diBiggestNumberOfDeviceConstants := Constants_Energy.diMaxNumberOfBatterys; END_IF
		IF Constants_Energy.diMaxNumberOfBatteryInverters > diBiggestNumberOfDeviceConstants THEN diBiggestNumberOfDeviceConstants := Constants_Energy.diMaxNumberOfBatteryInverters; END_IF 
		IF Constants_Energy.diMaxNumberOfElectricHeatingElements > diBiggestNumberOfDeviceConstants THEN diBiggestNumberOfDeviceConstants := Constants_Energy.diMaxNumberOfElectricHeatingElements; END_IF
		IF Constants_Energy.diMaxNumberOfHeatingPumps > diBiggestNumberOfDeviceConstants THEN diBiggestNumberOfDeviceConstants := Constants_Energy.diMaxNumberOfHeatingPumps; END_IF
		IF Constants_Energy.diMaxNumberOfElectricChargingStations > diBiggestNumberOfDeviceConstants THEN diBiggestNumberOfDeviceConstants := Constants_Energy.diMaxNumberOfElectricChargingStations; END_IF
		IF Constants_Energy.diMaxNumberOfOtherBigConsumers > diBiggestNumberOfDeviceConstants THEN diBiggestNumberOfDeviceConstants := Constants_Energy.diMaxNumberOfOtherBigConsumers; END_IF 
			//Cycletime in MS
			fbTaskIndex(index=> );
				udiCycleTime := TwinCAT_SystemInfoVarList._TaskInfo[fbTaskIndex.index].CycleTime / 10000;
					//Make a caculation with max Prio Number of 255, the cycle time and the biggest number. Because in the dumbest case it can take so long in one step until all priorities are gone through.
					timTimeout.PT := (T#1MS * udiCycleTime * 255 * diBiggestNumberOfDeviceConstants) + T#10S; 
						timTimeout(IN:= , PT:= , Q=> , ET=> );

(*--------------------------------------------------------------Timer for Battery-----------------------------------------------------------------------*)

//This timer ensures that the respective battery is full and thus in case of surplus or no surplus the power setting is directly regulated to 0% or -99.99% to accelerate the process.
//See in Step 131
//Only important in the self consumption mode

FOR liLPDataBatteryInverter := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
	IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].dwBatterySOC >= 100 THEN
		arrTimBatterysAreFull[liLPDataBatteryInverter](IN:= TRUE, PT:= T#2M, Q=> , ET=> );
	ELSE
		arrTimBatterysAreFull[liLPDataBatteryInverter](IN:= FALSE, PT:= T#2M, Q=> , ET=> );
	END_IF						
END_FOR
	
(*-------------------------------------------------------------Logic form the ems function to manage the devices-----------------------------------------------------------------------------------*)		
		
timCalculateNewPowerValue(IN:= bEnable AND NOT timCalculateNewPowerValue.Q AND uiState = 10, PT:= (T#1S * stSetupEMS.uiUpdateTime) , Q=> , ET=> );		

IF NOT bEnable OR FPEPO.Q OR FNEPO.Q OR diMemCmpOperationState <> 0 OR eOperationMode = E_OperatingMode_EMS.eAllOff OR bStopAll THEN uiState := 0; END_IF
	IF stSetupEMS.rSizeMainFuseCS <> rSizeMainFuseCS_CP OR diNrOfEM_IN_ECS <> diNrOfEM_IN_CS_CP THEN uiState := 1; END_IF

CASE uiState OF
	
	0: //Init Step
		
		byProgress := 0;
	
		eOperationModeEMS_CP := eOperationMode;
	
		IF bEnable AND eOperationMode <> E_OperatingMode_EMS.eAllOff AND NOT bStopAll THEN 
			uiState := 10; 
				arrActualPrioInTurn[1] := 1; arrActualPrioInTurn[2] := 1; arrActualPrioInTurn[3] := 1; arrActualPrioInTurn[4] := 1; arrActualPrioInTurn[5] := 1;
					arrActualStepInTurn[1] := 1; arrActualStepInTurn[2] := 1; 
						arrActualStepInTurn_CP[1]:= arrActualStepInTurn[1];
							arrActualStepInTurn_CP[2] := arrActualStepInTurn[2];
								bySmGrActiveCommonPrio_CP := 1;	liCounterCkeckDeviceAndPrio := 0;
									arrCTCheckActivePrio[1] := 0; arrCTCheckActivePrio[2] := 0; arrCTCheckActivePrio[3] := 0; arrCTCheckActivePrio[4] := 0; arrCTCheckActivePrio[5] := 0; liNrOfNotDoneDevices := 0; diNumberOfDevicesFromEachType := 0;
										timCutPeaks.IN := FALSE;
											arrMinPrioReached[1] := TRUE; arrMinPrioReached[2] := TRUE; arrMinPrioReached[3] := TRUE; arrMinPrioReached[4] := TRUE; arrMinPrioReached[5] := TRUE;
												arrMaxPrioReached[1] := FALSE; arrMaxPrioReached[2] := FALSE; arrMaxPrioReached[3] := FALSE; arrMaxPrioReached[4] := FALSE; arrMaxPrioReached[5] := FALSE;
		END_IF
		
	1: 	//Set the battery to Init if some Inputs are missing between the operation	
		arrActualPrioInTurn[1] := 1;
			bySmGrActiveCommonPrio_CP := 1;	
				arrCTCheckActivePrio[1] := 0; arrCTCheckActivePrio[2] := 0; arrCTCheckActivePrio[3] := 0; arrCTCheckActivePrio[4] := 0; arrCTCheckActivePrio[5] := 0; liNrOfNotDoneDevices := 0; diNumberOfDevicesFromEachType := 0; liCounterCkeckDeviceAndPrio := 0;
					timCutPeaks.IN := FALSE;
						arrMinPrioReached[1] := TRUE;
							arrMaxPrioReached[1] := FALSE;
								rSizeMainFuseCS_CP := stSetupEMS.rSizeMainFuseCS;
									diNrOfEM_IN_CS_CP := diNrOfEM_IN_ECS;
										uiState := 10;
		
	10: //After the timer is expired then ckeck if we have surplus or not
		//Surplus calculation in the Self consumption mode 
		IF NOT bEPMActive AND eOperationMode = E_OperatingMode_EMS.eSelfConsumption THEN	
			lrActualSurplusOrConsumption := 0;
				FOR liLPActualSurplusOrConsumption := 1 TO Constants_Energy.diMaxNumberOfGridConnections BY 1 DO
					lrActualSurplusOrConsumption := lrActualSurplusOrConsumption + Lynus_Standards.GVL_Energy.stDataGridConnections[diNrOfEMS_OUT,liLPActualSurplusOrConsumption].lrPower;
				END_FOR
					IF lrActualSurplusOrConsumption < - Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := TRUE; END_IF
						IF lrActualSurplusOrConsumption >= Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := FALSE; END_IF
							IF lrActualSurplusOrConsumption >= - Constants_Energy.rToleranceSurplusConsumption AND lrActualSurplusOrConsumption < Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := FALSE; lrActualSurplusOrConsumption := 0; END_IF
			
			//Peaks from <> 3 KW activate timer to wait 2.5 seconds before calculate
			IF lrActualSurplusOrConsumption >= (lrActualSurplusOrConsumptionOld + rPeakDetectionforCalculation) OR lrActualSurplusOrConsumption <= (lrActualSurplusOrConsumptionOld - rPeakDetectionforCalculation) THEN timCutPeaks.IN := TRUE; ELSE timCutPeaks.IN := FALSE; END_IF 
				lrActualSurplusOrConsumptionOld := lrActualSurplusOrConsumption;	
				
			IF timCalculateNewPowerValue.Q AND NOT timCutPeaks.Q AND rControllerQPIDSC <= 0 AND NOT fbPIDDischrgCmdFromBackend.bEnable THEN uiState := 30; END_IF
		END_IF
		
		//Surplus calculation in the peak load capping mode 
		IF NOT bEPMActive AND eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping THEN	
			lrActualSurplusOrConsumption := 0;
				FOR liLPActualSurplusOrConsumption := 1 TO Constants_Energy.diMaxNumberOfGridConnections BY 1 DO
					lrActualSurplusOrConsumption := lrActualSurplusOrConsumption + Lynus_Standards.GVL_Energy.stDataGridConnections[diNrOfEMS_OUT,liLPActualSurplusOrConsumption].lrPower;
				END_FOR
				
				lrActualSurplusOrConsumption := (lrSizeGridConnection) - lrActualSurplusOrConsumption;
					lrActualSurplusOrConsumption := lrActualSurplusOrConsumption * - 1;
				
					IF lrActualSurplusOrConsumption < - Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := TRUE; END_IF
						IF lrActualSurplusOrConsumption >= Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := FALSE; END_IF	
							IF lrActualSurplusOrConsumption >= - Constants_Energy.rToleranceSurplusConsumption AND lrActualSurplusOrConsumption < Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := FALSE; lrActualSurplusOrConsumption := 0; END_IF
				
			//Peaks from <> 3 KW activate timer to wait 2.5 seconds before calculate
			IF lrActualSurplusOrConsumption >= (lrActualSurplusOrConsumptionOld + rPeakDetectionforCalculation) OR lrActualSurplusOrConsumption <= (lrActualSurplusOrConsumptionOld - rPeakDetectionforCalculation) THEN timCutPeaks.IN := TRUE; ELSE timCutPeaks.IN := FALSE; END_IF 
				lrActualSurplusOrConsumptionOld := lrActualSurplusOrConsumption;
		
			IF timCalculateNewPowerValue.Q AND NOT timCutPeaks.Q THEN 
				uiState := 50; 
					//Set here to 0 because if other devices has Prio 1 or 255 the EMS not can finsih the Step why we leave Step 30
					liNrOfNotDoneDevices := 0; 
						//On this Operation Mode the batterys are always active. So we dont need the Step 30. See the PID Controllers for this mode
						IF ((bSurplusAvailable AND diNumberOfDevicesFromEachType = 0) OR (diNumberOfActiveBatterys = 0 AND bSurplusAvailable) OR (diNumberOfActiveBatterys <> 0 AND bSurplusAvailable)) THEN arrActualPrioInTurn[1] := 255; arrMinPrioReached[1] := FALSE; arrMaxPrioReached[1] := TRUE; END_IF
							IF ((NOT bSurplusAvailable AND diNumberOfDevicesFromEachType = 0) OR (diNumberOfActiveBatterys = 0 AND NOT bSurplusAvailable) OR (diNumberOfActiveBatterys <> 0 AND NOT bSurplusAvailable)) THEN arrActualPrioInTurn[1] := 1; arrMinPrioReached[1] := TRUE; arrMaxPrioReached[1] := FALSE; END_IF
			END_IF;
		END_IF
		
		//Surplus calculation in the load managemant mode 
		IF NOT bEPMActive AND eOperationMode = E_OperatingMode_EMS.eLoadManagement THEN	
			lrActualSurplusOrConsumption := 0;
				FOR liLPActualSurplusOrConsumption := 1 TO Constants_Energy.diMaxNumberOfGridConnections BY 1 DO
					lrActualSurplusOrConsumption := lrActualSurplusOrConsumption + Lynus_Standards.GVL_Energy.stDataGridConnections[diNrOfEMS_OUT,liLPActualSurplusOrConsumption].lrPower;
				END_FOR
				lrActualSurplusOrConsumption := (lrSizeGridConnection) - lrActualSurplusOrConsumption;
					lrActualSurplusOrConsumption := lrActualSurplusOrConsumption * - 1;
				
					IF lrActualSurplusOrConsumption < - Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := TRUE; END_IF
						IF lrActualSurplusOrConsumption >= Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := FALSE; END_IF	
							IF lrActualSurplusOrConsumption >= - Constants_Energy.rToleranceSurplusConsumption AND lrActualSurplusOrConsumption < Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := FALSE; lrActualSurplusOrConsumption := 0; END_IF
			
			//Peaks from <> 3 KW activate timer to wait 2.5 seconds before calculate
			IF lrActualSurplusOrConsumption >= (lrActualSurplusOrConsumptionOld + rPeakDetectionforCalculation) OR lrActualSurplusOrConsumption <= (lrActualSurplusOrConsumptionOld - rPeakDetectionforCalculation) THEN timCutPeaks.IN := TRUE; ELSE timCutPeaks.IN := FALSE; END_IF 
				lrActualSurplusOrConsumptionOld := lrActualSurplusOrConsumption;
			IF timCalculateNewPowerValue.Q AND NOT timCutPeaks.Q THEN 
				uiState := 50; 
					//Set here to 0 because if other devices has Prio 1 or 255 the EMS not can finsih the Step why we leave Step 30
					liNrOfNotDoneDevices := 0; 
						//On this Operation Mode the batterys are always active. So we dont need the Step 30. See the PID Controllers for this mode
						IF ((bSurplusAvailable AND diNumberOfDevicesFromEachType = 0) OR (diNumberOfActiveBatterys = 0 AND bSurplusAvailable) OR (diNumberOfActiveBatterys <> 0 AND bSurplusAvailable)) THEN arrActualPrioInTurn[1] := 255; arrMinPrioReached[1] := FALSE; arrMaxPrioReached[1] := TRUE; END_IF
							IF ((NOT bSurplusAvailable AND diNumberOfDevicesFromEachType = 0) OR (diNumberOfActiveBatterys = 0 AND NOT bSurplusAvailable) OR (diNumberOfActiveBatterys <> 0 AND NOT bSurplusAvailable)) THEN arrActualPrioInTurn[1] := 1; arrMinPrioReached[1] := TRUE; arrMaxPrioReached[1] := FALSE; END_IF
			END_IF
		END_IF
		
		//Surplus calculation in the emergency power mode
		IF bEPMActive THEN	
			lrActualSurplusOrConsumption := 0;
				FOR liLPActualSurplusOrConsumption := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
					IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPActualSurplusOrConsumption].bWorkOnIslandMode THEN lrActualSurplusOrConsumption := lrActualSurplusOrConsumption + Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPActualSurplusOrConsumption].lrPowerOnIslandMode; END_IF
				END_FOR
					IF lrActualSurplusOrConsumption < - Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := TRUE; END_IF
						IF lrActualSurplusOrConsumption >= Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := FALSE; END_IF
							IF lrActualSurplusOrConsumption >= - Constants_Energy.rToleranceSurplusConsumption AND lrActualSurplusOrConsumption < Constants_Energy.rToleranceSurplusConsumption THEN bSurplusAvailable := FALSE; lrActualSurplusOrConsumption := 0; END_IF
			
			//Peaks from <> x KW activate timer to wait 2.5 seconds before calculate
			IF lrActualSurplusOrConsumption >= (lrActualSurplusOrConsumptionOld + rPeakDetectionforCalculation) OR lrActualSurplusOrConsumption <= (lrActualSurplusOrConsumptionOld - rPeakDetectionforCalculation) THEN timCutPeaks.IN := TRUE; ELSE timCutPeaks.IN := FALSE; END_IF 
				lrActualSurplusOrConsumptionOld := lrActualSurplusOrConsumption;
			
			IF timCalculateNewPowerValue.Q AND NOT timCutPeaks.Q AND rControllerQPIDEPO <= 0 THEN uiState := 21; END_IF;
		END_IF
		
	21:	//If emergency power is active then first charge batteries that are build the island mode until byPrioMinChargeBattSOCInEPO, only then start normal mode according to priorities. 
		//Batterys or battery inverters that do not work on island mode, are only loaded afterwards based on the priority.  
		//As long as this SOC from byPrioMinChargeBattSOCInEPO is undercut, all other devices are regulated to 0.
		IF dwAvarageBatterySOCInEPO < stSetupEMS.byPrioMinChrgBattSOCInEPO THEN
			uiState := 0;
				bSurplusAvailable := FALSE;
					lrActualSurplusOrConsumption := 0;
						arrMinPrioReached[1] := TRUE; arrMinPrioReached[2] := TRUE; arrMinPrioReached[3] := TRUE; arrMinPrioReached[4] := TRUE; arrMinPrioReached[5] := TRUE;
							arrMaxPrioReached[1] := FALSE; arrMaxPrioReached[2] := FALSE; arrMaxPrioReached[3] := FALSE; arrMaxPrioReached[4] := FALSE; arrMaxPrioReached[5] := FALSE;
								bChargePrioBatterysOnEPO := TRUE;
		END_IF
			IF (dwAvarageBatterySOCInEPO >= (stSetupEMS.byPrioMinChrgBattSOCInEPO + 1) AND stSetupEMS.byPrioMinChrgBattSOCInEPO < 75) OR
				(dwAvarageBatterySOCInEPO >= stSetupEMS.byPrioMinChrgBattSOCInEPO AND stSetupEMS.byPrioMinChrgBattSOCInEPO >= 75) THEN
					bChargePrioBatterysOnEPO := FALSE;
						uiState := 30;
			END_IF
		
	30: //Check the priority for battery or battery inverters to controll (Batterys they are in island mode are not considered here)
		uiState_CP := uiState;
		//First check if we have min 1 of this Device Type. If not, complete this Device Type and go to the next step
		//Check also the bigest Priority of this Device Type
		diNumberOfDevicesFromEachType := 0; bySearchBigestPrio := 0;
		FOR liLPCheckDeviceAndPrio := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority <> 0 THEN diNumberOfDevicesFromEachType := diNumberOfDevicesFromEachType + 1; END_IF
			 IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority > bySearchBigestPrio THEN bySearchBigestPrio := Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority; END_IF  	
		END_FOR 
			IF bSurplusAvailable AND arrActualPrioInTurn[1] > bySearchBigestPrio AND uiState = 30 THEN arrActualPrioInTurn[1] := 255; END_IF
				IF NOT bSurplusAvailable AND arrActualPrioInTurn[1] > bySearchBigestPrio AND uiState = 30 THEN arrActualPrioInTurn[1] := bySearchBigestPrio; END_IF     
		
			IF bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[1] := 255; END_IF
				IF NOT bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[1] := 1; END_IF
		
		//Count up each Device
		arrCTCheckActivePrio[1] := arrCTCheckActivePrio[1] + 1;
			arrCTCheckActivePrio[1] := LIMIT(1,arrCTCheckActivePrio[1],Constants_Energy.diMaxNumberOfBatteryInverters);		
				
			//Surplus
			IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrCTCheckActivePrio[1]].byPriority = arrActualPrioInTurn[1] AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrCTCheckActivePrio[1]].rTargetPowerEMS > -100 AND NOT Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrCTCheckActivePrio[1]].bWorkOnIslandMode THEN
				arrMaxPrioReached[1] := FALSE;
					arrMinPrioReached[1] := FALSE;
						arrCTCheckActivePrio[1] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0; //Set here to 0 because in next Step we dont can work with a loop (performance Problems on small PLC)
							uiState := 50;
			ELSE
				IF bSurplusAvailable AND arrActualPrioInTurn[1] < 255 AND uiState = 30 AND arrCTCheckActivePrio[1] = Constants_Energy.diMaxNumberOfBatteryInverters THEN arrActualPrioInTurn[1] := arrActualPrioInTurn[1] + 1; arrCTCheckActivePrio[1] := 0; END_IF
			END_IF
				//No surplus
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrCTCheckActivePrio[1]].byPriority = arrActualPrioInTurn[1] AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrCTCheckActivePrio[1]].rTargetPowerEMS < 0 AND NOT Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrCTCheckActivePrio[1]].bWorkOnIslandMode THEN
					arrMaxPrioReached[1] := FALSE;
						arrMinPrioReached[1] := FALSE;
							arrCTCheckActivePrio[1] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
								uiState := 50;
				ELSE
					IF NOT bSurplusAvailable AND arrActualPrioInTurn[1] > 1 AND uiState = 30 AND arrCTCheckActivePrio[1] = Constants_Energy.diMaxNumberOfBatteryInverters THEN arrActualPrioInTurn[1] := arrActualPrioInTurn[1] - 1; arrCTCheckActivePrio[1] := 0; END_IF
				END_IF
		
		//Go to next step if we are on min prio or on max prio and the target power is just set to the min or to the max value.
		liNrOfNotDoneDevices := 0;
			IF uiState = 30 THEN
				FOR liLPCheckDeviceAndPrio := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
					IF arrActualPrioInTurn[1] = 1 AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].rTargetPowerEMS <> 0 AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority = 1 THEN
						liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1;	
					END_IF
						IF arrActualPrioInTurn[1] = 255 AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].rTargetPowerEMS > - 100 AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority = 255 THEN
							liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1;	
						END_IF
				END_FOR	
			END_IF
		
		IF arrActualPrioInTurn[1] = 1 AND uiState = 30 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[1] = Constants_Energy.diMaxNumberOfBatteryInverters THEN 
			arrMinPrioReached[1] := TRUE; arrMaxPrioReached[1] := FALSE; liNrOfNotDoneDevices := 0; uiState := 50; arrCTCheckActivePrio[1] := 0; liCounterCkeckDeviceAndPrio := 0;
		END_IF
		IF arrActualPrioInTurn[1] = 255 AND uiState = 30 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[1] = Constants_Energy.diMaxNumberOfBatteryInverters THEN 
			arrMaxPrioReached[1] := TRUE; arrMinPrioReached[1] := FALSE; liNrOfNotDoneDevices := 0; uiState := 50; arrCTCheckActivePrio[1] := 0; liCounterCkeckDeviceAndPrio := 0;
		END_IF
		
		//Timout, go to next step
		IF timTimeout.Q AND uiState = 30 THEN uiState := 50; END_IF
		
	50: //Check the priority for the heating pump incl. the steps to controll it
		uiState_CP := uiState;	
	
		//Counter to ckeck if we reached at the min or the max prio
		IF uiState = 50 THEN liCounterCkeckDeviceAndPrio := liCounterCkeckDeviceAndPrio + 1; END_IF
	
		//First check if we have min 1 of this Device Type. If not, complete this Device Type and go to the next step
		//Check also the bigest Priority of this Device Type
		diNumberOfDevicesFromEachType := 0; bySearchBigestPrio := 0;
		FOR liLPCheckDeviceAndPrio := 1 TO Constants_Energy.diMaxNumberOfHeatingPumps BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority <> 0 THEN diNumberOfDevicesFromEachType := diNumberOfDevicesFromEachType + 1; END_IF
				IF Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority > bySearchBigestPrio THEN bySearchBigestPrio := Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority; END_IF  
		END_FOR 
			IF bSurplusAvailable AND arrActualPrioInTurn[2] > bySearchBigestPrio AND uiState = 50 THEN arrActualPrioInTurn[2] := 255; END_IF
				IF NOT bSurplusAvailable AND arrActualPrioInTurn[2] > bySearchBigestPrio AND uiState = 50 THEN arrActualPrioInTurn[2] := bySearchBigestPrio; END_IF
		
			IF bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[2] := 255; END_IF
				IF NOT bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[2] := 1; END_IF
		
		//Count up each Device
		arrCTCheckActivePrio[2] := arrCTCheckActivePrio[2] + 1;
			arrCTCheckActivePrio[2] := LIMIT(1,arrCTCheckActivePrio[2],Constants_Energy.diMaxNumberOfHeatingPumps);
	
			//Surplus
			IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND NOT Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsStepSwitched AND NOT 
				Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] < 100 THEN
					arrActualStepInTurn[1] := 1;	
						arrMaxPrioReached[2] := FALSE;
							arrMinPrioReached[2] := FALSE;
								arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0; //Set here to 0 because in next Step we dont can work with a loop (performance Problems on small PLC)
									uiState := 70;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byNumberOfSteps = 0 AND
				Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] < 100 THEN 
					arrActualStepInTurn[1] := 1;	
						arrMaxPrioReached[2] := FALSE;
							arrMinPrioReached[2] := FALSE;
								arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
									uiState := 70;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND NOT Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] < 100 THEN 
					arrActualStepInTurn[1] := 1;	
						arrMaxPrioReached[2] := FALSE;
							arrMinPrioReached[2] := FALSE;
								arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
									uiState := 70;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byNumberOfSteps = 1 AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] < 100 THEN 
					arrActualStepInTurn[1] := 1;	
						arrMaxPrioReached[2] := FALSE;
							arrMinPrioReached[2] := FALSE;
								arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
									uiState := 70;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byNumberOfSteps = 2 AND (Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[2] < 100) THEN 
					IF Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[1] := 2; ELSE arrActualStepInTurn[1] := 1; END_IF
						arrMaxPrioReached[2] := FALSE; 
							arrMinPrioReached[2] := FALSE;
								arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
									uiState := 70;
			ELSE
				IF bSurplusAvailable AND arrActualPrioInTurn[2] < 255 AND uiState = 50 AND arrCTCheckActivePrio[2] = Constants_Energy.diMaxNumberOfHeatingPumps THEN 
					arrActualPrioInTurn[2] := arrActualPrioInTurn[2] + 1; arrCTCheckActivePrio[2] := 0; liCounterCkeckDeviceAndPrio := 0; liNrOfNotDoneDevices := 0; 
				END_IF
			END_IF
				//No surplus
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND NOT Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsStepSwitched AND NOT 
					Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] > 0 THEN
						arrActualStepInTurn[1] := 1;	
							arrMaxPrioReached[2] := FALSE;
								arrMinPrioReached[2] := FALSE;
									arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
										uiState := 70;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byNumberOfSteps = 0 AND 
					Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] > 0 THEN
						arrActualStepInTurn[1] := 1;	
							arrMaxPrioReached[2] := FALSE;
								arrMinPrioReached[2] := FALSE;
									arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
										uiState := 70;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND NOT Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] > 0 THEN
						arrActualStepInTurn[1] := 1;	
							arrMaxPrioReached[2] := FALSE;
								arrMinPrioReached[2] := FALSE;
									arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
										uiState := 70;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byNumberOfSteps = 1 AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] > 0 THEN
						arrActualStepInTurn[1] := 1;	
							arrMaxPrioReached[2] := FALSE;
								arrMinPrioReached[2] := FALSE;
									arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
										uiState := 70;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byPriority = arrActualPrioInTurn[2] AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].byNumberOfSteps = 2 AND (Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[2] > 0) THEN
						IF Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrCTCheckActivePrio[2]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[1] := 1; ELSE arrActualStepInTurn[1] := 2; END_IF
							arrMaxPrioReached[2] := FALSE;
								arrMinPrioReached[2] := FALSE;	
									arrCTCheckActivePrio[2] := 0; liNrOfNotDoneDevices := 0; liCounterCkeckDeviceAndPrio := 0;
										uiState := 70;
				ELSE
					IF NOT bSurplusAvailable AND arrActualPrioInTurn[2] > 1 AND uiState = 50 AND arrCTCheckActivePrio[2] = Constants_Energy.diMaxNumberOfHeatingPumps THEN 
						arrActualPrioInTurn[2] := arrActualPrioInTurn[2] - 1; arrCTCheckActivePrio[2] := 0; liCounterCkeckDeviceAndPrio := 0;  liNrOfNotDoneDevices := 0; 
					END_IF
				END_IF 	  
		
		//Go to next step if we are on min prio or on max prio and the target power is just set to the min or to the max value.
		liCounterCkeckDeviceAndPrio := LIMIT(0,liCounterCkeckDeviceAndPrio,Constants_Energy.diMaxNumberOfHeatingPumps);
		
			IF arrActualPrioInTurn[2] = 1 AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 1 AND
				(Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] <> 0 OR Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] <> 0) THEN 
					liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
			END_IF
				//1 Step
				IF arrActualPrioInTurn[2] = 255 AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 1 AND  
					Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 THEN 
						liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				//2 Steps
				ELSIF arrActualPrioInTurn[2] = 255 AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 2 AND  
					(Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100) THEN 
						liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				END_IF
			
		
		IF arrActualPrioInTurn[2] = 1 AND uiState = 50 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[2] = Constants_Energy.diMaxNumberOfHeatingPumps AND liCounterCkeckDeviceAndPrio = Constants_Energy.diMaxNumberOfHeatingPumps THEN 
			arrMinPrioReached[2] := TRUE; arrMaxPrioReached[2] := FALSE; liNrOfNotDoneDevices := 0; uiState := 70; arrCTCheckActivePrio[2] := 0; liCounterCkeckDeviceAndPrio := 0; 
		END_IF
		IF arrActualPrioInTurn[2] = 255 AND uiState = 50 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[2] = Constants_Energy.diMaxNumberOfHeatingPumps AND  liCounterCkeckDeviceAndPrio = Constants_Energy.diMaxNumberOfHeatingPumps THEN 
			arrMaxPrioReached[2] := TRUE; arrMinPrioReached[2] := FALSE; liNrOfNotDoneDevices := 0; uiState := 70; arrCTCheckActivePrio[2] := 0; liCounterCkeckDeviceAndPrio := 0;
		END_IF
		
		//Timout, go to next step
		IF timTimeout.Q AND uiState = 50 THEN uiState := 70; END_IF
		
	70: //Check the priority for the electric heating element incl. the steps to controll it
		uiState_CP := uiState;
	
		//Counter to ckeck if we reached at the min or the max prio
		IF uiState = 70 THEN liCounterCkeckDeviceAndPrio := liCounterCkeckDeviceAndPrio + 1; END_IF
	
		//First check if we have min 1 of this Device Type. If not, complete this Device Type and go to the next step
		//Check also the bigest Priority of this Device Type
		diNumberOfDevicesFromEachType := 0; bySearchBigestPrio := 0;
		FOR liLPCheckDeviceAndPrio := 1 TO Constants_Energy.diMaxNumberOfElectricHeatingElements BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority <> 0 THEN diNumberOfDevicesFromEachType := diNumberOfDevicesFromEachType + 1; END_IF
				IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority > bySearchBigestPrio THEN bySearchBigestPrio := Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority; END_IF   
		END_FOR 
			IF bSurplusAvailable AND arrActualPrioInTurn[3] > bySearchBigestPrio AND uiState = 70 THEN arrActualPrioInTurn[3] := 255; END_IF
				IF NOT bSurplusAvailable AND arrActualPrioInTurn[3] > bySearchBigestPrio AND uiState = 70 THEN arrActualPrioInTurn[3] := bySearchBigestPrio; END_IF
		
			IF bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[3] := 255; END_IF
				IF NOT bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[3] := 1; END_IF
		
		//Count up each Device
		arrCTCheckActivePrio[3] := arrCTCheckActivePrio[3] + 1;
			arrCTCheckActivePrio[3] := LIMIT(1,arrCTCheckActivePrio[3],Constants_Energy.diMaxNumberOfElectricHeatingElements);
		
			//Surplus
			IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND NOT Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND NOT 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN
					arrActualStepInTurn[2] := 1;	
						arrMaxPrioReached[3] := FALSE;
							arrMinPrioReached[3] := FALSE;
								arrCTCheckActivePrio[3] := 0;
									uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 0 AND
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN 
					arrActualStepInTurn[2] := 1;	
						arrMaxPrioReached[3] := FALSE;
							arrMinPrioReached[3] := FALSE;
								arrCTCheckActivePrio[3] := 0;
									uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND NOT Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN
					arrActualStepInTurn[2] := 1;	
						arrMaxPrioReached[3] := FALSE;
							arrMinPrioReached[3] := FALSE;
								arrCTCheckActivePrio[3] := 0;
									uiState := 90;	
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 1 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN 
					arrActualStepInTurn[2] := 1;	
						arrMaxPrioReached[3] := FALSE;
							arrMinPrioReached[3] := FALSE;
								arrCTCheckActivePrio[3] := 0;
									uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 2 AND (Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] < 100) THEN
					IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; ELSE arrActualStepInTurn[2] := 1; END_IF
						arrMaxPrioReached[3] := FALSE;
							arrMinPrioReached[3] := FALSE;
								arrCTCheckActivePrio[3] := 0;
									uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 3 AND (Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] < 100) THEN
					IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN arrActualStepInTurn[2] := 1; END_IF
					IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; END_IF
					IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] >= 100 THEN arrActualStepInTurn[2] := 3; END_IF
						arrMaxPrioReached[3] := FALSE;
							arrMinPrioReached[3] := FALSE;
								arrCTCheckActivePrio[3] := 0;
									uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 4 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] < 100) THEN
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN arrActualStepInTurn[2] := 1; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] >= 100 THEN arrActualStepInTurn[2] := 3; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] >= 100 THEN arrActualStepInTurn[2] := 4; END_IF
								arrMaxPrioReached[3] := FALSE;
									arrMinPrioReached[3] := FALSE;
										arrCTCheckActivePrio[3] := 0;
											uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 5 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] < 100) THEN
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN arrActualStepInTurn[2] := 1; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] >= 100 THEN arrActualStepInTurn[2] := 3; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] >= 100 THEN arrActualStepInTurn[2] := 4; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] >= 100 THEN arrActualStepInTurn[2] := 5; END_IF
								arrMaxPrioReached[3] := FALSE;
									arrMinPrioReached[3] := FALSE;
										arrCTCheckActivePrio[3] := 0;
											uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 6 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2]< 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3]< 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] < 100) THEN
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN arrActualStepInTurn[2] := 1; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] >= 100 THEN arrActualStepInTurn[2] := 3; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] >= 100 THEN arrActualStepInTurn[2] := 4; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] >= 100 THEN arrActualStepInTurn[2] := 5; END_IF
							IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] >= 100 THEN arrActualStepInTurn[2] := 6; END_IF
								arrMaxPrioReached[3] := FALSE;
									arrMinPrioReached[3] := FALSE;
										arrCTCheckActivePrio[3] := 0;
											uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps= 7 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] < 100) THEN
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN arrActualStepInTurn[2] := 1; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] >= 100 THEN arrActualStepInTurn[2] := 3; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] >= 100 THEN arrActualStepInTurn[2] := 4; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] >= 100 THEN arrActualStepInTurn[2] := 5; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] >= 100 THEN arrActualStepInTurn[2] := 6; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] >= 100 THEN arrActualStepInTurn[2] := 7; END_IF
									arrMaxPrioReached[3] := FALSE;
										arrMinPrioReached[3] := FALSE;
											arrCTCheckActivePrio[3] := 0;
												uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 8 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] < 100) THEN
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN arrActualStepInTurn[2] := 1; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] >= 100 THEN arrActualStepInTurn[2] := 3; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] >= 100 THEN arrActualStepInTurn[2] := 4; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] >= 100 THEN arrActualStepInTurn[2] := 5; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] >= 100 THEN arrActualStepInTurn[2] := 6; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] >= 100 THEN arrActualStepInTurn[2] := 7; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] >= 100 THEN arrActualStepInTurn[2] := 8; END_IF
									arrMaxPrioReached[3] := FALSE;
										arrMinPrioReached[3] := FALSE;
											arrCTCheckActivePrio[3] := 0;
												uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 9 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[9] < 100) THEN
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN arrActualStepInTurn[2] := 1; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] >= 100 THEN arrActualStepInTurn[2] := 3; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] >= 100 THEN arrActualStepInTurn[2] := 4; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] >= 100 THEN arrActualStepInTurn[2] := 5; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] >= 100 THEN arrActualStepInTurn[2] := 6; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] >= 100 THEN arrActualStepInTurn[2] := 7; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] >= 100 THEN arrActualStepInTurn[2] := 8; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] >= 100 THEN arrActualStepInTurn[2] := 9; END_IF
									arrMaxPrioReached[3] := FALSE;
										arrMinPrioReached[3] := FALSE;
											arrCTCheckActivePrio[3] := 0;
												uiState := 90;
			ELSIF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
				Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 10 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[9] < 100 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[10] < 100) THEN
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] < 100 THEN arrActualStepInTurn[2] := 1; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] >= 100 THEN arrActualStepInTurn[2] := 2; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] >= 100 THEN arrActualStepInTurn[2] := 3; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] >= 100 THEN arrActualStepInTurn[2] := 4; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] >= 100 THEN arrActualStepInTurn[2] := 5; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] >= 100 THEN arrActualStepInTurn[2] := 6; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] >= 100 THEN arrActualStepInTurn[2] := 7; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] >= 100 THEN arrActualStepInTurn[2] := 8; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] >= 100 THEN arrActualStepInTurn[2] := 9; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[9] >= 100 THEN arrActualStepInTurn[2] := 10; END_IF
										arrMaxPrioReached[3] := FALSE;
											arrMinPrioReached[3] := FALSE;
												arrCTCheckActivePrio[3] := 0;
													uiState := 90;
			ELSE
				IF bSurplusAvailable AND arrActualPrioInTurn[3] < 255 AND uiState = 70 AND arrCTCheckActivePrio[3] = Constants_Energy.diMaxNumberOfElectricHeatingElements THEN 
					arrActualPrioInTurn[3] := arrActualPrioInTurn[3] + 1; arrCTCheckActivePrio[3] := 0; liCounterCkeckDeviceAndPrio := 0; liNrOfNotDoneDevices := 0; 
				END_IF
			END_IF
				//No surplus
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND NOT Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND NOT 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 THEN
						arrActualStepInTurn[2] := 1;	
							arrMaxPrioReached[3] := FALSE;
								arrMinPrioReached[3] := FALSE;
									arrCTCheckActivePrio[3] := 0;
										uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 0 AND
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 THEN 
						arrActualStepInTurn[2] := 1;	
							arrMaxPrioReached[3] := FALSE;
								arrMinPrioReached[3] := FALSE;
									arrCTCheckActivePrio[3] := 0;
										uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND NOT Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 THEN
						arrActualStepInTurn[2] := 1;	
							arrMaxPrioReached[3] := FALSE;
								arrMinPrioReached[3] := FALSE;
									arrCTCheckActivePrio[3] := 0;
										uiState := 90;	
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 1 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 THEN 
						arrActualStepInTurn[2] := 1;	
							arrMaxPrioReached[3] := FALSE;
								arrMinPrioReached[3] := FALSE;
									arrCTCheckActivePrio[3] := 0;
										uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 2 AND (Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0) THEN
						IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; ELSE arrActualStepInTurn[2] := 2; END_IF
							arrMaxPrioReached[3] := FALSE;
								arrMinPrioReached[3] := FALSE;
									arrCTCheckActivePrio[3] := 0;
										uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 3 AND (Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0) THEN
						IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; END_IF
						IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 THEN arrActualStepInTurn[2] := 2; END_IF
						IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 THEN arrActualStepInTurn[2] := 3; END_IF
							arrMaxPrioReached[3] := FALSE;
								arrMinPrioReached[3] := FALSE;
									arrCTCheckActivePrio[3] := 0;
										uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 4 AND 
						(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0) THEN
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 THEN arrActualStepInTurn[2] := 2; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 THEN arrActualStepInTurn[2] := 3; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 THEN arrActualStepInTurn[2] := 4; END_IF
									arrMaxPrioReached[3] := FALSE;
										arrMinPrioReached[3] := FALSE;
											arrCTCheckActivePrio[3] := 0;
												uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 5 AND 
						(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0) THEN
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 THEN arrActualStepInTurn[2] := 2; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 THEN arrActualStepInTurn[2] := 3; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 THEN arrActualStepInTurn[2] := 4; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 THEN arrActualStepInTurn[2] := 5; END_IF
									arrMaxPrioReached[3] := FALSE;
										arrMinPrioReached[3] := FALSE;
											arrCTCheckActivePrio[3] := 0;
												uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 6 AND 
						(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0) THEN
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 THEN arrActualStepInTurn[2] := 2; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 THEN arrActualStepInTurn[2] := 3; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 THEN arrActualStepInTurn[2] := 4; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 THEN arrActualStepInTurn[2] := 5; END_IF
								IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 THEN arrActualStepInTurn[2] := 6; END_IF
									arrMaxPrioReached[3] := FALSE;
										arrMinPrioReached[3] := FALSE;
											arrCTCheckActivePrio[3] := 0;
												uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 7 AND 
						(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] > 0) THEN
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 THEN arrActualStepInTurn[2] := 2; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 THEN arrActualStepInTurn[2] := 3; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 THEN arrActualStepInTurn[2] := 4; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 THEN arrActualStepInTurn[2] := 5; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 THEN arrActualStepInTurn[2] := 6; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] > 0 THEN arrActualStepInTurn[2] := 7; END_IF
										arrMaxPrioReached[3] := FALSE;
											arrMinPrioReached[3] := FALSE;
												arrCTCheckActivePrio[3] := 0;
													uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 8 AND 
						(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] > 0) THEN
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 THEN arrActualStepInTurn[2] := 2; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 THEN arrActualStepInTurn[2] := 3; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 THEN arrActualStepInTurn[2] := 4; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 THEN arrActualStepInTurn[2] := 5; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 THEN arrActualStepInTurn[2] := 6; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] > 0 THEN arrActualStepInTurn[2] := 7; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] > 0 THEN arrActualStepInTurn[2] := 8; END_IF
										arrMaxPrioReached[3] := FALSE;
											arrMinPrioReached[3] := FALSE;
												arrCTCheckActivePrio[3] := 0;
													uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 9 AND 
						(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[9] > 0) THEN
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 THEN arrActualStepInTurn[2] := 2; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 THEN arrActualStepInTurn[2] := 3; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 THEN arrActualStepInTurn[2] := 4; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 THEN arrActualStepInTurn[2] := 5; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 THEN arrActualStepInTurn[2] := 6; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] > 0 THEN arrActualStepInTurn[2] := 7; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] > 0 THEN arrActualStepInTurn[2] := 8; END_IF
									IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[9] > 0 THEN arrActualStepInTurn[2] := 9; END_IF
										arrMaxPrioReached[3] := FALSE;
											arrMinPrioReached[3] := FALSE;
												arrCTCheckActivePrio[3] := 0;
													uiState := 90;
				ELSIF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byPriority = arrActualPrioInTurn[3] AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsStepSwitched AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].byNumberOfSteps = 10 AND 
						(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[1] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] > 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[9] > 0 OR
									Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[10] > 0) THEN
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] <= 0 THEN arrActualStepInTurn[2] := 1; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[2] > 0 THEN arrActualStepInTurn[2] := 2; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[3] > 0 THEN arrActualStepInTurn[2] := 3; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[4] > 0 THEN arrActualStepInTurn[2] := 4; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[5] > 0 THEN arrActualStepInTurn[2] := 5; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[6] > 0 THEN arrActualStepInTurn[2] := 6; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[7] > 0 THEN arrActualStepInTurn[2] := 7; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[8] > 0 THEN arrActualStepInTurn[2] := 8; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[9] > 0 THEN arrActualStepInTurn[2] := 9; END_IF
										IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrCTCheckActivePrio[3]].arrTargetPowerEMS[10] > 0 THEN arrActualStepInTurn[2] := 10; END_IF
											arrMaxPrioReached[3] := FALSE;
												arrMinPrioReached[3] := FALSE;
													arrCTCheckActivePrio[3] := 0;
														uiState := 90;
				ELSE
					IF NOT bSurplusAvailable AND arrActualPrioInTurn[3] > 1 AND uiState = 70 AND arrCTCheckActivePrio[3] = Constants_Energy.diMaxNumberOfElectricHeatingElements THEN 
						arrActualPrioInTurn[3] := arrActualPrioInTurn[3] - 1; arrCTCheckActivePrio[3] := 0; liCounterCkeckDeviceAndPrio := 0; liNrOfNotDoneDevices := 0; 
					END_IF
				END_IF
		
		//Go to next step if we are on min prio or on max prio and the target power is just set to the min or to the max value.
		liCounterCkeckDeviceAndPrio := LIMIT(1,liCounterCkeckDeviceAndPrio,Constants_Energy.diMaxNumberOfElectricHeatingElements);
		
			IF arrActualPrioInTurn[3] = 1 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 1 AND
				(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] <> 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] <> 0 OR
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] <> 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[4] <> 0 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[5] <> 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[6] <> 0 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[7] <> 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[8] <> 0 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[9] <> 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[10] <> 0) THEN 
									liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
			END_IF
				//1 Step
				IF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 1 AND 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 THEN 
						liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				//2 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 2 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100) THEN 
						liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				//3 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 3 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] < 100) THEN 
							liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1;
				//4 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 4 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[4] < 100) THEN 
							liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1;  
				//5 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 5 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[4] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[5] < 100) THEN 
								liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				//6 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 6 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[4] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[6] < 100) THEN 
								liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				//7 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 7 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[4] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[6] < 100 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[7] < 100) THEN 
									liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				//8 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 8 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[4] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[6] < 100 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[7] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[8] < 100) THEN 
									liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				//9 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 9 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[4] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[6] < 100 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[7] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[8] < 100 OR
									Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[9] < 100) THEN 
										liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				//10 Steps
				ELSIF arrActualPrioInTurn[3] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byPriority = 255 AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].byNumberOfSteps = 10 AND 
					(Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[1] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[2] < 100 OR
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[3] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[4] < 100 OR
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[5] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[6] < 100 OR
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[7] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[8] < 100 OR
									Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[9] < 100 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liCounterCkeckDeviceAndPrio].arrTargetPowerEMS[10] < 100) THEN 
										liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1; 
				END_IF
		
		IF arrActualPrioInTurn[3] = 1 AND uiState = 70 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[3] = Constants_Energy.diMaxNumberOfElectricHeatingElements AND liCounterCkeckDeviceAndPrio = Constants_Energy.diMaxNumberOfElectricHeatingElements THEN 
			arrMinPrioReached[3] := TRUE; arrMaxPrioReached[3] := FALSE; liNrOfNotDoneDevices := 0; uiState := 90; arrCTCheckActivePrio[3] := 0; liCounterCkeckDeviceAndPrio := 0; 
		END_IF
		IF arrActualPrioInTurn[3] = 255 AND uiState = 70 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[3] = Constants_Energy.diMaxNumberOfElectricHeatingElements AND liCounterCkeckDeviceAndPrio = Constants_Energy.diMaxNumberOfElectricHeatingElements THEN 
			arrMaxPrioReached[3] := TRUE; arrMinPrioReached[3] := FALSE; liNrOfNotDoneDevices := 0; uiState := 90; arrCTCheckActivePrio[3] := 0; liCounterCkeckDeviceAndPrio := 0; 
		END_IF
		
		//Timout, go to next step
		IF timTimeout.Q AND uiState = 70 THEN uiState := 90; END_IF
		
	90: //Check the priority for the big consumer to controll it
		uiState_CP := uiState;
	
		//First check if we have min 1 of this Device Type. If not, complete this Device Type and go to the next step
		//Check also the bigest Priority of this Device Type
		diNumberOfDevicesFromEachType := 0; bySearchBigestPrio := 0;
		FOR liLPCheckDeviceAndPrio := 1 TO Constants_Energy.diMaxNumberOfOtherBigConsumers BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority <> 0 THEN diNumberOfDevicesFromEachType := diNumberOfDevicesFromEachType + 1; END_IF
				IF Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority > bySearchBigestPrio THEN bySearchBigestPrio := Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority; END_IF   
		END_FOR 
			IF bSurplusAvailable AND arrActualPrioInTurn[4] > bySearchBigestPrio AND uiState = 90 THEN arrActualPrioInTurn[4] := 255; END_IF
				IF NOT bSurplusAvailable AND arrActualPrioInTurn[4] > bySearchBigestPrio AND uiState = 90 THEN arrActualPrioInTurn[4] := bySearchBigestPrio; END_IF
		
			IF bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[4] := 255; END_IF
				IF NOT bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[4] := 1; END_IF
		
		//Count up each Device
		arrCTCheckActivePrio[4] := arrCTCheckActivePrio[4] + 1;
			arrCTCheckActivePrio[4] := LIMIT(1,arrCTCheckActivePrio[4],Constants_Energy.diMaxNumberOfOtherBigConsumers);
		
			//Surplus
			IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,arrCTCheckActivePrio[4]].byPriority = arrActualPrioInTurn[4] AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,arrCTCheckActivePrio[4]].rTargetPowerEMS < 100 THEN
				arrMaxPrioReached[4] := FALSE;
					arrMinPrioReached[4] := FALSE;
						arrCTCheckActivePrio[4] := 0;
							uiState := 109; 
			ELSE
				IF bSurplusAvailable AND arrActualPrioInTurn[4] < 255 AND uiState = 90 AND arrCTCheckActivePrio[4] = Constants_Energy.diMaxNumberOfOtherBigConsumers THEN arrActualPrioInTurn[4] := arrActualPrioInTurn[4] + 1; arrCTCheckActivePrio[4] := 0; END_IF
			END_IF
				//No surplus
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,arrCTCheckActivePrio[4]].byPriority = arrActualPrioInTurn[4] AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,arrCTCheckActivePrio[4]].rTargetPowerEMS > 0 THEN
					arrMaxPrioReached[4] := FALSE;
						arrMinPrioReached[4] := FALSE;
							arrCTCheckActivePrio[4] := 0;
								uiState := 109;
				ELSE
					IF NOT bSurplusAvailable AND arrActualPrioInTurn[4] > 1 AND uiState = 90 AND arrCTCheckActivePrio[4] = Constants_Energy.diMaxNumberOfOtherBigConsumers THEN arrActualPrioInTurn[4] := arrActualPrioInTurn[4] - 1; arrCTCheckActivePrio[4] := 0; END_IF
				END_IF
		
		
		//Go to next step if we are on min prio or on max prio and the target power is just set to the min or to the max value.
		liNrOfNotDoneDevices := 0;
			FOR liLPCheckDeviceAndPrio := 1 TO Constants_Energy.diMaxNumberOfOtherBigConsumers BY 1 DO
				IF arrActualPrioInTurn[4] = 1 AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].rTargetPowerEMS <> 0 AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority = 1 THEN
					liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1;	
				END_IF
					IF arrActualPrioInTurn[4] = 255 AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].rTargetPowerEMS < 100 AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority = 255 THEN
						liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1;	
					END_IF
			END_FOR	
		
		IF arrActualPrioInTurn[4] = 1 AND uiState = 90 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[4] = Constants_Energy.diMaxNumberOfOtherBigConsumers THEN 
			arrMinPrioReached[4] := TRUE; arrMaxPrioReached[4] := FALSE; liNrOfNotDoneDevices := 0; uiState := 109; arrCTCheckActivePrio[4] := 0; 
		END_IF
		IF arrActualPrioInTurn[4] = 255 AND uiState = 90 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[4] = Constants_Energy.diMaxNumberOfOtherBigConsumers THEN 
			arrMaxPrioReached[4] := TRUE; arrMinPrioReached[4] := FALSE; liNrOfNotDoneDevices := 0; uiState := 109; arrCTCheckActivePrio[4] := 0; 
		END_IF
		
		//Timout, go to next step
		IF timTimeout.Q AND uiState = 90 THEN uiState := 109; END_IF
		
	109://Check if in Load management mode or Peak shaving mode some electric Fuse Line use to much power when we have here surplus
		uiState_CP := uiState;

		//Count up each Device
		arrCTCheckActivePrio[5] := arrCTCheckActivePrio[5] + 1;
			arrCTCheckActivePrio[5] := LIMIT(1,arrCTCheckActivePrio[5],Constants_Energy.diMaxNumberOfElectricChargingStations);
		
		IF ((eOperationMode = E_OperatingMode_EMS.eLoadManagement OR eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping) AND bSurplusAvailable AND stSetupEMS.bEnableMainFuseFunction) THEN
			IF Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,arrCTCheckActivePrio[5]].byPriority = arrActualPrioInTurn[5] THEN
				//The ECS use to much power. So dont give here more power. Go to next priority
				IF bNoPowerForECS THEN
					//Go to next prio that we can go forward with the other Devices with same priority. Controlling for ECS see down on the Part on wich we limit the charging station about the electric Fuse Line
					IF arrActualPrioInTurn[5] < 255 THEN arrActualPrioInTurn[5] := arrActualPrioInTurn[5] + 1; END_IF
						uiState := 110;
							arrCTCheckActivePrio[5] := 0;	
				END_IF
			END_IF 
		ELSE
			uiState := 110;
				arrCTCheckActivePrio[5] := 0;
		END_IF
		
		//Go to next step if wa have checked every ECS without resluts
		IF arrCTCheckActivePrio[5] >= Constants_Energy.diMaxNumberOfElectricChargingStations AND uiState = 109 THEN
			uiState := 110;
				arrCTCheckActivePrio[5] := 0;
		END_IF 
	 	
		//Timout, go to next step
		IF timTimeout.Q AND uiState = 109 THEN uiState := 110; arrCTCheckActivePrio[5] := 0; END_IF	
		
	110: //Check the priority for the electric charging stations to controll it
		uiState_CP := uiState;
	
		//First check if we have min 1 of this Device Type. If not, complete this Device Type and go to the next step
		//Check also the bigest Priority of this Device Type
		diNumberOfDevicesFromEachType := 0; bySearchBigestPrio := 0;
		FOR liLPCheckDeviceAndPrio := 1 TO Constants_Energy.diMaxNumberOfElectricChargingStations BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority <> 0 THEN diNumberOfDevicesFromEachType := diNumberOfDevicesFromEachType + 1; END_IF
				IF Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority > bySearchBigestPrio THEN bySearchBigestPrio := Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority; END_IF   
		END_FOR 
			IF bSurplusAvailable AND arrActualPrioInTurn[5] > bySearchBigestPrio AND uiState = 110 THEN arrActualPrioInTurn[5] := 255; END_IF
				IF NOT bSurplusAvailable AND arrActualPrioInTurn[5] > bySearchBigestPrio AND uiState = 110 THEN arrActualPrioInTurn[5] := bySearchBigestPrio; END_IF
		
			IF bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[5] := 255; END_IF
				IF NOT bSurplusAvailable AND diNumberOfDevicesFromEachType = 0 THEN arrActualPrioInTurn[5] := 1; END_IF
		
		//Count up each Device
		arrCTCheckActivePrio[5] := arrCTCheckActivePrio[5] + 1;
			arrCTCheckActivePrio[5] := LIMIT(1,arrCTCheckActivePrio[5],Constants_Energy.diMaxNumberOfElectricChargingStations);
		
			//Surplus
			IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,arrCTCheckActivePrio[5]].byPriority = arrActualPrioInTurn[5] AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,arrCTCheckActivePrio[5]].rTargetPowerEMS < 100 THEN
				arrMaxPrioReached[5] := FALSE;
					arrMinPrioReached[5] := FALSE;
						arrCTCheckActivePrio[5] := 0;
							uiState := 130;
			ELSE
				IF bSurplusAvailable AND arrActualPrioInTurn[5] < 255 AND uiState = 110 AND arrCTCheckActivePrio[5] = Constants_Energy.diMaxNumberOfElectricChargingStations THEN arrActualPrioInTurn[5] := arrActualPrioInTurn[5] + 1; arrCTCheckActivePrio[5] := 0; END_IF
			END_IF
				//No surplus
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,arrCTCheckActivePrio[5]].byPriority = arrActualPrioInTurn[5] AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,arrCTCheckActivePrio[5]].rTargetPowerEMS > 0 THEN
					arrMaxPrioReached[5] := FALSE;
						arrMinPrioReached[5] := FALSE;
							arrCTCheckActivePrio[5] := 0;
								uiState := 130;
				ELSE
					IF NOT bSurplusAvailable AND arrActualPrioInTurn[5] > 1 AND uiState = 110 AND arrCTCheckActivePrio[5] = Constants_Energy.diMaxNumberOfElectricChargingStations THEN arrActualPrioInTurn[5] := arrActualPrioInTurn[5] - 1; arrCTCheckActivePrio[5] := 0; END_IF
				END_IF
		
		//Go to next step if we are on min prio or on max prio and the target power is just set to the min or to the max value.
		liNrOfNotDoneDevices := 0;
			FOR liLPCheckDeviceAndPrio := 1 TO Constants_Energy.diMaxNumberOfElectricChargingStations BY 1 DO
				IF arrActualPrioInTurn[5] = 1 AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].rTargetPowerEMS <> 0 AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority = 1 THEN
					liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1;	
				END_IF
					IF arrActualPrioInTurn[5] = 255 AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].rTargetPowerEMS < 100 AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckDeviceAndPrio].byPriority = 255 THEN
						liNrOfNotDoneDevices := liNrOfNotDoneDevices + 1;	
					END_IF
			END_FOR
		
		IF arrActualPrioInTurn[5] = 1 AND uiState = 110 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[5] = Constants_Energy.diMaxNumberOfElectricChargingStations THEN 
			arrMinPrioReached[5] := TRUE; arrMaxPrioReached[5] := FALSE; liNrOfNotDoneDevices := 0; uiState := 130; arrCTCheckActivePrio[5] := 0; 
		END_IF
		IF arrActualPrioInTurn[5] = 255 AND uiState = 110 AND liNrOfNotDoneDevices = 0 AND arrCTCheckActivePrio[5] = Constants_Energy.diMaxNumberOfElectricChargingStations THEN 
			arrMaxPrioReached[5] := TRUE; arrMinPrioReached[5] := FALSE; liNrOfNotDoneDevices := 0; uiState := 130; arrCTCheckActivePrio[5] := 0; 
		END_IF	
		
		//Timout, go to next step
		IF timTimeout.Q AND uiState = 110 THEN uiState := 130; END_IF
		
	130: //Search the smallest/biggest common priority and the number of devices with the same priority  
		IF bSurplusAvailable THEN bySmGrActiveCommonPrio := 255; END_IF
		IF NOT bSurplusAvailable THEN bySmGrActiveCommonPrio := 1; END_IF
	
		FOR byLPSmActiveCommonPrio := 1 TO 5 BY 1 DO
			IF bSurplusAvailable AND arrActualPrioInTurn[byLPSmActiveCommonPrio] < bySmGrActiveCommonPrio THEN bySmGrActiveCommonPrio := arrActualPrioInTurn[byLPSmActiveCommonPrio]; END_IF 
			IF NOT bSurplusAvailable AND arrActualPrioInTurn[byLPSmActiveCommonPrio] > bySmGrActiveCommonPrio THEN bySmGrActiveCommonPrio := arrActualPrioInTurn[byLPSmActiveCommonPrio]; END_IF 
		END_FOR
		
		//Back to the start when complete power is awarded, all power is set on 0 or we haven't common priority 	
		IF (arrMaxPrioReached[1] AND arrMaxPrioReached[2] AND arrMaxPrioReached[3] AND arrMaxPrioReached[4] AND arrMaxPrioReached[5]) OR
			(arrMinPrioReached[1] AND arrMinPrioReached[2] AND arrMinPrioReached[3] AND arrMinPrioReached[4] AND arrMinPrioReached[5]) THEN
				uiState := 10;
		ELSE
				uiState := 131;
		END_IF
		
	131: //Ckeck if the Batterys are full or not when we have no surplus. Thus the problem can be avoided if the battery FB regulates the power internally to 0, but the EMS still sends power to the inverter.
		 //Because otherwise it always takes too long when we have a small consumption and the battery must first be regulated to 0% in the GVL, although you are already full and you can therefore no longer be regulated back.
		 
		IF eOperationMode = E_OperatingMode_EMS.eSelfConsumption THEN 
			FOR liLPDataBatteryInverter := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].byPriority = bySmGrActiveCommonPrio AND 
					arrTimBatterysAreFull[liLPDataBatteryInverter].Q THEN
						Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].rTargetPowerEMS := 0;
				END_IF	  
			END_FOR 
	
			//When we have a surplus again and the battery is full, we control it again with - 99.99%, so that the following devices do not have to wait too long to be controlled. 	
			//It must be set to 99.99, otherwise an error would occur in the next step.
			FOR liLPDataBatteryInverter := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
				IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].byPriority = bySmGrActiveCommonPrio AND 
					arrTimBatterysAreFull[liLPDataBatteryInverter].Q THEN
						Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].rTargetPowerEMS := - 99.99;
				END_IF	  
			END_FOR
		END_IF
		
		//Go to the next Step
		uiState := 150;
		
	150: //Calcualte the % power from each device with the same priority
		lrMaxPowerDevicesWithActualPrio := 0;
			bMissingPowerData := FALSE;
		
		//Batterys are only a "normal" Device, when the self consumption mode is active.
		IF eOperationMode = E_OperatingMode_EMS.eSelfConsumption THEN 
			//Batteryinverters
			FOR liLPCheckMaxPower := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
				IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckMaxPower].rTargetPowerEMS > -100 AND NOT Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckMaxPower].bWorkOnIslandMode THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckMaxPower].rMaxChargePower; END_IF
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckMaxPower].rTargetPowerEMS < 0 AND NOT Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckMaxPower].bWorkOnIslandMode THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPCheckMaxPower].rMaxChargePower; END_IF 
			END_FOR
		END_IF
			//Heating pumps
			IF arrActualStepInTurn[1] >= 1 AND arrActualStepInTurn[1] <= 2 THEN
				FOR liLPCheckMaxPower := 1 TO Constants_Energy.diMaxNumberOfHeatingPumps BY 1 DO
					IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckMaxPower].arrTargetPowerEMS[arrActualStepInTurn[1]] < 100 THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckMaxPower].arrMaxPower[arrActualStepInTurn[1]]; END_IF
					IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckMaxPower].arrTargetPowerEMS[arrActualStepInTurn[1]] > 0 THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPCheckMaxPower].arrMaxPower[arrActualStepInTurn[1]]; END_IF
				END_FOR
			END_IF
				//Electric heating elements
				IF arrActualStepInTurn[2] >= 1 AND arrActualStepInTurn[2] <= 10 THEN
					FOR liLPCheckMaxPower := 1 TO Constants_Energy.diMaxNumberOfElectricHeatingElements BY 1 DO
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckMaxPower].arrTargetPowerEMS[arrActualStepInTurn[2]] < 100 THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckMaxPower].arrMaxPower[arrActualStepInTurn[2]]; END_IF 
						IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckMaxPower].arrTargetPowerEMS[arrActualStepInTurn[2]] > 0 THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPCheckMaxPower].arrMaxPower[arrActualStepInTurn[2]]; END_IF 
					END_FOR	
				END_IF
					//Other big consumer
					FOR liLPCheckMaxPower := 1 TO Constants_Energy.diMaxNumberOfOtherBigConsumers BY 1 DO
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckMaxPower].rTargetPowerEMS < 100 THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckMaxPower].rMaxPower; END_IF
						IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckMaxPower].rTargetPowerEMS > 0 THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPCheckMaxPower].rMaxPower; END_IF
					END_FOR
						//Electric charging stations
						FOR liLPCheckMaxPower := 1 TO Constants_Energy.diMaxNumberOfElectricChargingStations BY 1 DO
							IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckMaxPower].rTargetPowerEMS < 100 THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckMaxPower].rMaxPower; END_IF
							IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckMaxPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckMaxPower].rTargetPowerEMS > 0 THEN lrMaxPowerDevicesWithActualPrio := lrMaxPowerDevicesWithActualPrio + Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCheckMaxPower].rMaxPower; END_IF 
						END_FOR
		
		//Check is somthing has changed at the actual priority or at the actual step 
		//Priority or step now is higher as before
		IF (bSurplusAvailable AND MEMCMP(ADR(bySmGrActiveCommonPrio),ADR(bySmGrActiveCommonPrio_CP),SIZEOF(bySmGrActiveCommonPrio_CP)) <> 0) OR (bSurplusAvailable AND MEMCMP(ADR(arrActualStepInTurn),ADR(arrActualStepInTurn_CP),SIZEOF(arrActualStepInTurn_CP)) <> 0) THEN
			bySmGrActiveCommonPrio_CP := bySmGrActiveCommonPrio;
				arrActualStepInTurn_CP := arrActualStepInTurn;
					bStepWasOn100 := FALSE;		
		END_IF
			//Priority or step now is lower as before
			IF (NOT bSurplusAvailable AND MEMCMP(ADR(bySmGrActiveCommonPrio),ADR(bySmGrActiveCommonPrio_CP),SIZEOF(bySmGrActiveCommonPrio_CP)) <> 0) OR (NOT bSurplusAvailable AND MEMCMP(ADR(arrActualStepInTurn),ADR(arrActualStepInTurn_CP),SIZEOF(arrActualStepInTurn_CP)) <> 0) THEN
				bySmGrActiveCommonPrio_CP := bySmGrActiveCommonPrio;
					arrActualStepInTurn_CP := arrActualStepInTurn;
						bStepWasOn100 := TRUE;			
			END_IF						
						
		IF lrMaxPowerDevicesWithActualPrio > 0 THEN
			//Calcualte the power for the controllable devices
			IF bSurplusAvailable THEN rValuePercentToControllableDevices := LREAL_TO_REAL((100 * (lrActualSurplusOrConsumption * - 1)) / lrMaxPowerDevicesWithActualPrio); END_IF
  			IF NOT bSurplusAvailable THEN rValuePercentToControllableDevices := LREAL_TO_REAL((100 * lrActualSurplusOrConsumption) / lrMaxPowerDevicesWithActualPrio); END_IF
			//Calcualte the power for the On/Off or step switched devices
			IF bSurplusAvailable THEN rValuePercentToStepSwitchedDevices := LREAL_TO_REAL((100 * (lrActualSurplusOrConsumption * - 1)) / lrMaxPowerDevicesWithActualPrio); END_IF
			IF NOT bSurplusAvailable THEN rValuePercentToStepSwitchedDevices := (100 - LREAL_TO_REAL((100 * lrActualSurplusOrConsumption) / lrMaxPowerDevicesWithActualPrio)); END_IF
				IF bSurplusAvailable AND rValuePercentToStepSwitchedDevices >= 100 THEN bStepWasOn100 := TRUE; END_IF
				IF NOT bSurplusAvailable AND rValuePercentToStepSwitchedDevices < Constants_Energy.byTargetOffPowerForOnOffDevices THEN bStepWasOn100 := FALSE; END_IF
					IF bStepWasOn100 THEN rValuePercentToStepSwitchedDevices := 100; END_IF
					IF NOT bStepWasOn100 THEN rValuePercentToStepSwitchedDevices := 0; END_IF		
		ELSE
			//Power inputs from the setups of the devices are missing. Set the target power automatically to 0
			bMissingPowerData := TRUE;
			IF bSurplusAvailable THEN
				rValuePercentToControllableDevices := - 100;
				rValuePercentToStepSwitchedDevices := 0;
			END_IF
				IF NOT bSurplusAvailable THEN
					rValuePercentToControllableDevices := 100;
					rValuePercentToStepSwitchedDevices := 0;
				END_IF
		END_IF
		
		//If we have more surplus than the maximum power of the devices is, then we can set the target power directly to 100%
		IF bSurplusAvailable AND (lrActualSurplusOrConsumption * - 1) >= lrMaxPowerDevicesWithActualPrio AND NOT bMissingPowerData THEN rValuePercentToControllableDevices := 100; END_IF
		IF bSurplusAvailable AND (lrActualSurplusOrConsumption * - 1) >= lrMaxPowerDevicesWithActualPrio AND NOT bMissingPowerData THEN rValuePercentToStepSwitchedDevices := 100; bStepWasOn100 := TRUE; END_IF
		
		//If more power is consumed than the maximum power of the devices, 0% power can be commanded (for controllable devices 100% as it is deducted).
		IF NOT bSurplusAvailable AND lrActualSurplusOrConsumption >= lrMaxPowerDevicesWithActualPrio AND NOT bMissingPowerData THEN rValuePercentToControllableDevices := 100; END_IF
		IF NOT bSurplusAvailable AND lrActualSurplusOrConsumption >= lrMaxPowerDevicesWithActualPrio AND NOT bMissingPowerData THEN rValuePercentToStepSwitchedDevices := 0; bStepWasOn100 := FALSE; END_IF
		
		//Check the limits
		rValuePercentToControllableDevices := LIMIT(0,rValuePercentToControllableDevices,100);
			rValuePercentToStepSwitchedDevices := LIMIT(0,rValuePercentToStepSwitchedDevices,100);
				
		uiState := 170;
		
	170: //Set the target power to each device
		//Batterys or battery inverters
		//Batterys are only a "normal" Device, when the self consumption mode is active.
		IF eOperationMode = E_OperatingMode_EMS.eSelfConsumption THEN 
			FOR liLPSetPercentPower := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
				IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS > -100 THEN 
					Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS - rValuePercentToControllableDevices; 
				END_IF
				IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS < -100 THEN 
					Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := -100; 
				END_IF 
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS < 0 THEN 
					Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS + rValuePercentToControllableDevices;
				
				END_IF
				IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS > 0 THEN 
					Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := 0;
					
				END_IF
				//Power Data is Missing
				IF bMissingPowerData AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio THEN 
					Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := 0;	
				END_IF 
				//Limit
							Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := LIMIT(-100,Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS,100);	
			END_FOR
		END_IF
			//Heating pumps
			IF arrActualStepInTurn[1] >= 1 AND arrActualStepInTurn[1] <= 2 THEN
				FOR liLPSetPercentPower := 1 TO Constants_Energy.diMaxNumberOfHeatingPumps BY 1 DO
					//On/Off
					IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] < 100 AND NOT 
						Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND NOT Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
							Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := rValuePercentToStepSwitchedDevices; 
					END_IF
					//Controllable linear
					IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] < 100 AND 
						Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND NOT Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
							Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] + rValuePercentToControllableDevices; 
					END_IF
					//Step switched
					IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] < 100 AND 
						Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
							Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := rValuePercentToStepSwitchedDevices; 
					END_IF
					IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] > 100 THEN Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := 100; END_IF 
						//On/Off
						IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] > 0 AND NOT 
							Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND NOT Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
								Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := rValuePercentToStepSwitchedDevices; 
						END_IF
						//Controllable linear
						IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] > 0 AND 
							Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND NOT Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
								Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] - rValuePercentToControllableDevices; 
						END_IF
						//Step switched
						IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] > 0 AND 
							Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
								Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := rValuePercentToStepSwitchedDevices; 
						END_IF
						IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] < 0 THEN Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := 0; END_IF
							//Limit
							Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]] := LIMIT(0,Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[1]],100);
				END_FOR
			END_IF
				//electric heating element
				IF arrActualStepInTurn[2] >= 1 AND arrActualStepInTurn[2] <= 10 THEN
					FOR liLPSetPercentPower := 1 TO Constants_Energy.diMaxNumberOfElectricHeatingElements BY 1 DO
						//On/Off
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] < 100 AND NOT
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND NOT Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := rValuePercentToStepSwitchedDevices;
						END_IF
						//Controllable linear
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] < 100 AND
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND NOT Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] + rValuePercentToControllableDevices;
						END_IF
						//Step switched
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] < 100 AND
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := rValuePercentToStepSwitchedDevices;
						END_IF
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] > 100 THEN Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := 100; END_IF
							//On/Off
							IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] > 0 AND NOT
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND NOT Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
									Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := rValuePercentToStepSwitchedDevices;
							END_IF
							//Controllable linear
							IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] > 0 AND
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND NOT Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
									Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] - rValuePercentToControllableDevices;
							END_IF
							//Step switched
							IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] > 0 AND
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].bIsStepSwitched THEN
									Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := rValuePercentToStepSwitchedDevices;
							END_IF	
							IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] < 0 THEN Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := 0; END_IF 
								//Limit
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]] := LIMIT(0,Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,liLPSetPercentPower].arrTargetPowerEMS[arrActualStepInTurn[2]],100);
					END_FOR			
				END_IF
					//Other big consumer
					FOR liLPSetPercentPower := 1 TO Constants_Energy.diMaxNumberOfOtherBigConsumers BY 1 DO
						//On/Off
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS < 100 AND NOT
							Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable THEN Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := rValuePercentToStepSwitchedDevices; 
						END_IF
						//Controllable linear
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS < 100 AND
							Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable THEN Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS + rValuePercentToControllableDevices;
						END_IF
						IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS > 100 THEN Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := 100; END_IF
							//On/Off
							IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS > 0 AND NOT
								Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable THEN Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := rValuePercentToStepSwitchedDevices; 
							END_IF
							//Controllable linear
							IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS > 0 AND
								Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable THEN Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS - rValuePercentToControllableDevices;
							END_IF
							IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS < 0 THEN Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := 0; END_IF
								//Limit
								Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := LIMIT(0,Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS,100);
					END_FOR
						//Electric charging stations
						FOR liLPSetPercentPower := 1 TO Constants_Energy.diMaxNumberOfElectricChargingStations BY 1 DO
							//On/Off
							IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS < 100 AND NOT 
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable THEN 
									//No power on ECS because on the Electric Fuse Line we take to much Power on witch the ECS is conected
									IF NOT bNoPowerForECS THEN 
										Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := rValuePercentToStepSwitchedDevices;	
									END_IF	
							END_IF
							//Controllable linear
							IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS < 100 AND 
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable THEN 
									//No power on ECS because on the Electric Fuse Line we take to much Power on witch the ECS is conected
									IF NOT bNoPowerForECS THEN
										Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS + rValuePercentToControllableDevices;		
									END_IF
							END_IF
							IF bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS > 100 THEN Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := 100; END_IF
								//On/Off
								IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS > 0 AND NOT 
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable THEN Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := rValuePercentToStepSwitchedDevices;		
								END_IF
								//Controllable linear
								IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].byPriority = bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS > 0 AND 
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].bIsControllable THEN Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS - rValuePercentToControllableDevices;		
								END_IF
								IF NOT bSurplusAvailable AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS < 0 THEN Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := 0; END_IF	
									//Limit
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS := LIMIT(0,Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPSetPercentPower].rTargetPowerEMS,100);
						END_FOR 
		uiState := 10;
END_CASE

(*-------------------------------------------------------------------------------------Correction Charging stations regarding max fuse power---------------------------------------------------------------------------------------------------------------*)

//Correction for the charging station power that the target power is not bigger then the maximum of the fuse. Active on mode peak load capping (Index from meter > 0 and fuse value > 0) and load management (always).
//Work only with controllable charging station. Not work for On/off stations.
IF (stSetupEMS.bEnableMainFuseFunction AND bEnable AND (eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping OR eOperationMode = E_OperatingMode_EMS.eLoadManagement)) THEN

IF arrMaxPrioReached[5] THEN bECSPrio255 := TRUE; END_IF
	IF NOT bSurplusAvailable THEN bECSPrio255 := FALSE; END_IF

lrPowerDiffFuseECS := (stSetupEMS.rSizeMainFuseCS * 0.95) - Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].lrPowerConsumption;	
	//Make little tolerance that we dont regulate up and down 
	IF lrPowerDiffFuseECS > 0 AND lrPowerDiffFuseECS <= 0.1 THEN lrPowerDiffFuseECS := 0; END_IF  
		IF lrPowerDiffFuseECS > 0 THEN lrPowerDiffFuseECS := lrPowerDiffFuseECS - 0.1; END_IF 
	
	//No power for ECS on normal EMS Step
	IF lrPowerDiffFuseECS < 0 THEN 
		bNoPowerForECS := TRUE; 
	ELSE
		bNoPowerForECS := FALSE;
	END_IF	
		
	diNumberOfECS := 0;		
		FOR liLPCorrectionPowerCS := 1 TO Constants_Energy.diMaxNumberOfElectricChargingStations BY 1 DO
			//Count number of charging stations when we have surplus on Fuse Line
			IF NOT arrMinPrioReached[5] AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].byPriority <= bySmGrActiveCommonPrio AND 
				Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].bEnabled AND 
					Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rTargetPowerEMS < 100 AND lrPowerDiffFuseECS >= 0 THEN 
						diNumberOfECS := diNumberOfECS + 1; 
			END_IF
				//Count number of charging stations when we have NO surplus on Fuse Line
				IF NOT arrMinPrioReached[5] AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].byPriority <= bySmGrActiveCommonPrio AND 
					Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].bEnabled AND
						Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rTargetPowerEMS > 0 AND lrPowerDiffFuseECS < 0 THEN 
							diNumberOfECS := diNumberOfECS + 1; 
				END_IF 
		END_FOR
			//Calculate the power in % for each charging station
			//Actual Power is <= then stSetupEMS.rSizeMainFuseCS 
			IF diNumberOfECS > 0 AND lrPowerDiffFuseECS >= 0 THEN lrPowerForCalculateECS := lrPowerDiffFuseECS / diNumberOfECS; END_IF  
				//Actual Power is > then stSetupEMS.rSizeMainFuseCS
				IF diNumberOfECS > 0 AND lrPowerDiffFuseECS < 0 THEN lrPowerForCalculateECS := (lrPowerDiffFuseECS * - 1) / diNumberOfECS; END_IF 

//Timer to make the correction for the charging stations
IF (NOT arrMinPrioReached[5] AND NOT timCorrectionECS.Q AND bEnable AND (eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping OR eOperationMode = E_OperatingMode_EMS.eLoadManagement)) THEN  
	timCorrectionECS.IN := TRUE;
ELSE
	timCorrectionECS.IN := FALSE;
END_IF
	//The timer work faster when the value from lrPowerDiffFuseECS is bigger
	//Positive value (Mean more power for ECS)
	IF lrPowerDiffFuseECS >= 0.75 THEN timCorrectionECS.PT := T#2.5S; END_IF
	IF lrPowerDiffFuseECS >= 0.5 AND lrPowerDiffFuseECS < 0.75 THEN timCorrectionECS.PT := T#3S; END_IF
	IF lrPowerDiffFuseECS >= 0.25 AND lrPowerDiffFuseECS < 0.5 THEN timCorrectionECS.PT := T#3.5S; END_IF
	IF lrPowerDiffFuseECS > 0 AND lrPowerDiffFuseECS < 0.25 THEN timCorrectionECS.PT := T#4S; END_IF
		//Value is 0
		IF lrPowerDiffFuseECS = 0 THEN timCorrectionECS.PT := T#5S; END_IF 
			//Negative value (Mean less power for ECS)
			IF lrPowerDiffFuseECS < 0 AND lrPowerDiffFuseECS > - 0.25 THEN timCorrectionECS.PT := T#4S; END_IF
			IF lrPowerDiffFuseECS <= - 0.25 AND lrPowerDiffFuseECS > - 0.5 THEN timCorrectionECS.PT := T#3.5S; END_IF
			IF lrPowerDiffFuseECS <= - 0.5 AND lrPowerDiffFuseECS > - 0.75 THEN timCorrectionECS.PT := T#3S; END_IF
			IF lrPowerDiffFuseECS <= - 0.75 THEN timCorrectionECS.PT := T#2.5S; END_IF
				//Timer
				timCorrectionECS(IN:= , PT:= , Q=> , ET=> );				
				
//Set the new power to the charging stations with priority < common priority in progress
lrTargetPowerCorrectionECS := 0;
	FOR liLPCorrectionPowerCS := 1 TO Constants_Energy.diMaxNumberOfElectricChargingStations BY 1 DO 	
		IF (NOT arrMinPrioReached[5] AND timCorrectionECS.Q AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].byPriority < bySmGrActiveCommonPrio AND eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping AND stSetupEMS.rSizeMainFuseCS > 0 AND Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].bEnabled) OR
			(NOT arrMinPrioReached[5] AND timCorrectionECS.Q AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].byPriority < bySmGrActiveCommonPrio AND eOperationMode = E_OperatingMode_EMS.eLoadManagement AND stSetupEMS.rSizeMainFuseCS > 0 AND Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].bEnabled) OR
				(NOT arrMinPrioReached[5] AND timCorrectionECS.Q AND lrPowerDiffFuseECS < 0 AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].byPriority = bySmGrActiveCommonPrio AND eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping AND stSetupEMS.rSizeMainFuseCS > 0 AND Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].bEnabled) OR
				(NOT arrMinPrioReached[5] AND timCorrectionECS.Q AND lrPowerDiffFuseECS < 0 AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].byPriority = bySmGrActiveCommonPrio AND eOperationMode = E_OperatingMode_EMS.eLoadManagement AND stSetupEMS.rSizeMainFuseCS > 0 AND Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].bEnabled) OR				
					(NOT arrMinPrioReached[5] AND timCorrectionECS.Q AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].byPriority = 255 AND bECSPrio255 AND eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping AND stSetupEMS.rSizeMainFuseCS > 0 AND Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].bEnabled) OR	
					(NOT arrMinPrioReached[5] AND timCorrectionECS.Q AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].byPriority = 255 AND bECSPrio255 AND eOperationMode = E_OperatingMode_EMS.eLoadManagement AND stSetupEMS.rSizeMainFuseCS > 0 AND Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].bEnabled) THEN
						//Calcualte the new % value for each charging station	
						IF Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rMaxPower > 0 THEN 
							lrTargetPowerCorrectionECS := (100 * lrPowerForCalculateECS) / Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rMaxPower;	
								lrTargetPowerCorrectionECS := LIMIT(0,lrTargetPowerCorrectionECS,100);
						ELSE
							//Without power data on the setups from the charging station set target powert to -100 or +100 to dissable the charging station
							IF lrPowerDiffFuseECS >= 0 THEN lrTargetPowerCorrectionECS := - 100; ELSE lrTargetPowerCorrectionECS := 100; END_IF 
						END_IF	
							IF lrPowerDiffFuseECS >= 0 AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].bIsControllable THEN 
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rTargetPowerEMS := Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rTargetPowerEMS + LREAL_TO_REAL(lrTargetPowerCorrectionECS); 
							END_IF
								IF lrPowerDiffFuseECS < 0 AND Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].bIsControllable THEN 
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rTargetPowerEMS := Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rTargetPowerEMS - LREAL_TO_REAL(lrTargetPowerCorrectionECS); 
								END_IF	
									//Limits
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rTargetPowerEMS := LIMIT(0,Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,liLPCorrectionPowerCS].rTargetPowerEMS,100);			
		END_IF
	END_FOR

//Dissable the ECS complete when the EM has a Error
IF (Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].byErrorWarning = 2 AND (eOperationMode = E_OperatingMode_EMS.eLoadManagement OR eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping)) THEN
	timResetDisableECS.IN := TRUE;
ELSE
	timResetDisableECS.IN := FALSE;
END_IF
	timResetDisableECS(IN:= , PT:= T#10S, Q=> , ET=> );	
		IF timResetDisableECS.Q THEN bDisableECS := TRUE; ELSE bDisableECS := FALSE; END_IF

ELSE
	timResetDisableECS.IN := FALSE;
		bDisableECS := FALSE;		
			timCorrectionECS.IN := FALSE;
				bECSPrio255 := FALSE;
					bNoPowerForECS := FALSE;
END_IF		
		
(*-------------------------------------------------------------------------------------Set the power to 0 on each device---------------------------------------------------------------------------------------------------------------*)	
	
//When a device has the priority 0, the priority is bigger then who was at the moment in progress, the EMS function is not enabled, a positv or negative edge came when the emergency power mode start or stop or when the operation mode is changing then the EMS start from new and all devices are set to defaul target power 0.
//Set the target power to 0 where there should no power 

FPEPO(CLK:= bEPMActive, Q=> );
	FNEPO(CLK:= bEPMActive, Q=> );
	
diMemCmpOperationState := MEMCMP(ADR(eOperationMode),ADR(eOperationModeEMS_CP),SIZEOF(eOperationModeEMS_CP)); 	

//Battery	
FOR arrLPPrioZeroSetToZeroP[1] := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
	IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[1]].byPriority = 0 OR Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[1]].byPriority > arrActualPrioInTurn[1] OR arrMinPrioReached[1] OR NOT bEnable OR FPEPO.Q OR FNEPO.Q OR 
		diMemCmpOperationState <> 0 OR eOperationMode = E_OperatingMode_EMS.eAllOff OR bStopAll THEN 
			Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[1]].rTargetPowerEMS := 0; 
	END_IF
END_FOR
	//Heating Pumps
	FOR arrLPPrioZeroSetToZeroP[2] := 1 TO Constants_Energy.diMaxNumberOfHeatingPumps BY 1 DO
		IF Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[2]].byPriority = 0 OR Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[2]].byPriority > arrActualPrioInTurn[2] OR arrMinPrioReached[2] OR NOT bEnable OR FPEPO.Q OR FNEPO.Q OR 
			diMemCmpOperationState <> 0 OR eOperationMode = E_OperatingMode_EMS.eAllOff OR bStopAll THEN
				Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[2]].arrTargetPowerEMS[1] := 0;
					Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[2]].arrTargetPowerEMS[2] := 0;
						//Switch off external on command for heating pumps
						Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[2]].bExternalOnCommand := FALSE;
		END_IF
	END_FOR
		//EHE
		FOR arrLPPrioZeroSetToZeroP[3] := 1 TO Constants_Energy.diMaxNumberOfElectricHeatingElements BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].byPriority = 0 OR Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].byPriority > arrActualPrioInTurn[3] OR arrMinPrioReached[3] OR NOT bEnable OR FPEPO.Q OR FNEPO.Q OR 
				diMemCmpOperationState <> 0 OR eOperationMode = E_OperatingMode_EMS.eAllOff OR bStopAll THEN 
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[1] := 0;
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[2] := 0;
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[3] := 0;
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[4] := 0;
									Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[5] := 0;
					Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[6] := 0;
						Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[7] := 0;
							Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[8] := 0;
								Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[9] := 0;
									Lynus_Standards.GVL_Energy.stDataElectricHeatingElements[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[3]].arrTargetPowerEMS[10] := 0;
			END_IF
		END_FOR
			//OBC
			FOR arrLPPrioZeroSetToZeroP[4] := 1 TO Constants_Energy.diMaxNumberOfOtherBigConsumers BY 1 DO
				IF Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[4]].byPriority = 0 OR Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[4]].byPriority > arrActualPrioInTurn[4] OR arrMinPrioReached[4] OR NOT bEnable OR FPEPO.Q OR 
					FNEPO.Q OR diMemCmpOperationState <> 0 OR eOperationMode = E_OperatingMode_EMS.eAllOff OR bStopAll THEN
						Lynus_Standards.GVL_Energy.stDataOtherBigConsumers[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[4]].rTargetPowerEMS := 0;
				END_IF
			END_FOR
				//ECS
				FOR arrLPPrioZeroSetToZeroP[5] := 1 TO Constants_Energy.diMaxNumberOfElectricChargingStations BY 1 DO
					IF Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[5]].byPriority = 0 OR Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[5]].byPriority > arrActualPrioInTurn[5] OR arrMinPrioReached[5] OR NOT bEnable OR FPEPO.Q OR FNEPO.Q OR 
						diMemCmpOperationState <> 0 OR eOperationMode = E_OperatingMode_EMS.eAllOff OR bStopAll OR 
							((eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping OR eOperationMode = E_OperatingMode_EMS.eLoadManagement) AND stSetupEMS.bEnableMainFuseFunction AND (NOT Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_ECS].bEnabled OR stSetupEMS.rSizeMainFuseCS <= 0 OR bDisableECS)) THEN
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_OUT,arrLPPrioZeroSetToZeroP[5]].rTargetPowerEMS := 0;
					END_IF
				END_FOR

(*----------------------------------------------------------------------------------------------------Controller to discharge/charge the batterys on the different modes----------------------------------------------------------------------------------------------------------*)
(*----------------------------------------------------------------------------------------------------Controller to discharge the battery in the self consumption mode----------------------------------------------------------------------------------------------------------*)

lrErrorPIDCorrectionBattSC := ABS(0 - lrGridPower);

//Controller weighting
IF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eSlow THEN 
	IF lrErrorPIDCorrectionBattSC <= 0.5 THEN fbPIDBatterySC.rPValue := 0.05; fbPIDBatterySC.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattSC > 0.5 AND lrErrorPIDCorrectionBattSC <= 1 THEN fbPIDBatterySC.rPValue := 0.07; fbPIDBatterySC.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattSC > 1 AND lrErrorPIDCorrectionBattSC <= 1.5 THEN fbPIDBatterySC.rPValue := 0.09; fbPIDBatterySC.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionBattSC > 1.5 AND lrErrorPIDCorrectionBattSC <= 2 THEN fbPIDBatterySC.rPValue := 0.11; fbPIDBatterySC.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionBattSC > 2 AND lrErrorPIDCorrectionBattSC <= 2.5 THEN fbPIDBatterySC.rPValue := 0.13; fbPIDBatterySC.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionBattSC > 2.5 AND lrErrorPIDCorrectionBattSC <= 3 THEN fbPIDBatterySC.rPValue := 0.15; fbPIDBatterySC.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionBattSC > 3 AND lrErrorPIDCorrectionBattSC <= 3.5 THEN fbPIDBatterySC.rPValue := 0.17; fbPIDBatterySC.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattSC > 3.5 AND lrErrorPIDCorrectionBattSC <= 4 THEN fbPIDBatterySC.rPValue := 0.19; fbPIDBatterySC.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattSC > 4 AND lrErrorPIDCorrectionBattSC <= 4.5 THEN fbPIDBatterySC.rPValue := 0.21; fbPIDBatterySC.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattSC > 4.5 AND lrErrorPIDCorrectionBattSC <= 5 THEN fbPIDBatterySC.rPValue := 0.23; fbPIDBatterySC.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattSC > 5 THEN fbPIDBatterySC.rPValue := 0.25; fbPIDBatterySC.udiIValue := 900;
	END_IF
ELSIF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eBalanced THEN 
	IF lrErrorPIDCorrectionBattSC <= 0.5 THEN fbPIDBatterySC.rPValue := 0.10; fbPIDBatterySC.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattSC > 0.5 AND lrErrorPIDCorrectionBattSC <= 1 THEN fbPIDBatterySC.rPValue := 0.14; fbPIDBatterySC.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattSC > 1 AND lrErrorPIDCorrectionBattSC <= 1.5 THEN fbPIDBatterySC.rPValue := 0.18; fbPIDBatterySC.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionBattSC > 1.5 AND lrErrorPIDCorrectionBattSC <= 2 THEN fbPIDBatterySC.rPValue := 0.22; fbPIDBatterySC.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionBattSC > 2 AND lrErrorPIDCorrectionBattSC <= 2.5 THEN fbPIDBatterySC.rPValue := 0.26; fbPIDBatterySC.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionBattSC > 2.5 AND lrErrorPIDCorrectionBattSC <= 3 THEN fbPIDBatterySC.rPValue := 0.30; fbPIDBatterySC.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionBattSC > 3 AND lrErrorPIDCorrectionBattSC <= 3.5 THEN fbPIDBatterySC.rPValue := 0.34; fbPIDBatterySC.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattSC > 3.5 AND lrErrorPIDCorrectionBattSC <= 4 THEN fbPIDBatterySC.rPValue := 0.38; fbPIDBatterySC.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattSC > 4 AND lrErrorPIDCorrectionBattSC <= 4.5 THEN fbPIDBatterySC.rPValue := 0.42; fbPIDBatterySC.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattSC > 4.5 AND lrErrorPIDCorrectionBattSC <= 5 THEN fbPIDBatterySC.rPValue := 0.46; fbPIDBatterySC.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattSC > 5 THEN fbPIDBatterySC.rPValue := 0.50; fbPIDBatterySC.udiIValue := 900;
	END_IF
ELSIF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eFast THEN
	IF lrErrorPIDCorrectionBattSC <= 0.5 THEN fbPIDBatterySC.rPValue := 0.30; fbPIDBatterySC.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionBattSC > 0.5 AND lrErrorPIDCorrectionBattSC <= 1 THEN fbPIDBatterySC.rPValue := 0.33; fbPIDBatterySC.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionBattSC > 1 AND lrErrorPIDCorrectionBattSC <= 1.5 THEN fbPIDBatterySC.rPValue := 0.36; fbPIDBatterySC.udiIValue := 275; 
	ELSIF lrErrorPIDCorrectionBattSC > 1.5 AND lrErrorPIDCorrectionBattSC <= 2 THEN fbPIDBatterySC.rPValue := 0.39; fbPIDBatterySC.udiIValue := 275; 	
	ELSIF lrErrorPIDCorrectionBattSC > 2 AND lrErrorPIDCorrectionBattSC <= 2.5 THEN fbPIDBatterySC.rPValue := 0.42; fbPIDBatterySC.udiIValue := 500; 
	ELSIF lrErrorPIDCorrectionBattSC > 2.5 AND lrErrorPIDCorrectionBattSC <= 3 THEN fbPIDBatterySC.rPValue := 0.45; fbPIDBatterySC.udiIValue := 500;
	ELSIF lrErrorPIDCorrectionBattSC > 3 AND lrErrorPIDCorrectionBattSC <= 3.5 THEN fbPIDBatterySC.rPValue := 0.48; fbPIDBatterySC.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattSC > 3.5 AND lrErrorPIDCorrectionBattSC <= 4 THEN fbPIDBatterySC.rPValue := 0.51; fbPIDBatterySC.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattSC > 4 AND lrErrorPIDCorrectionBattSC <= 4.5 THEN fbPIDBatterySC.rPValue := 0.54; fbPIDBatterySC.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattSC > 4.5 AND lrErrorPIDCorrectionBattSC <= 5 THEN fbPIDBatterySC.rPValue := 0.57; fbPIDBatterySC.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattSC > 5 THEN fbPIDBatterySC.rPValue := 0.60; fbPIDBatterySC.udiIValue := 750;
	END_IF
END_IF

IF bEnable AND eOperationMode = E_OperatingMode_EMS.eSelfConsumption AND NOT bEPMActive AND NOT bStopAll AND NOT bDischrgCmdFromBackendOK AND 
	arrMinPrioReached[1] AND arrMinPrioReached[2] AND arrMinPrioReached[3] AND arrMinPrioReached[4] AND arrMinPrioReached[5] THEN
		fbPIDBatterySC.bEnable := TRUE;
ELSE
		fbPIDBatterySC.bEnable := FALSE;
END_IF

fbPIDBatterySC( 
	bEnable:= , 
	rSetpoint:= 0, 
	udiIValue:= , 
	udiDValue:= 0, 
	udiDamping:= 0, 
	rPValue:= , 
	rMaxValue:= 100, 
	rMinValue:= 0, 
	rNeutralZone:= 0.1, 
	bDirection:= TRUE, 
	rActualValue:= LREAL_TO_REAL(lrGridPower), 
	rQController=> rControllerQPIDSC);

//Set the Controller output	to 0 when we have surplus. (Because its possible that the controller output is not set 100% to 0 regarding internal discrepancies)
IF rControllerQPIDSC <= 0.4 AND fbPIDBatterySC.bEnable AND lrGridPower <= - Constants_Energy.rToleranceSurplusConsumption THEN 
	timPIDSC.IN := TRUE;
ELSE
	timPIDSC.IN := FALSE;
END_IF

timPIDSC(IN:= , PT:= T#15S, Q=> , ET=> );
	IF timPIDSC.Q THEN rControllerQPIDSC := 0; END_IF	

FOR liLPDataBatteryInverter := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
	IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].byPriority <> 0 AND NOT bEPMActive AND eOperationMode = E_OperatingMode_EMS.eSelfConsumption AND	
		arrMinPrioReached[1] AND arrMinPrioReached[2] AND arrMinPrioReached[3] AND arrMinPrioReached[4] AND arrMinPrioReached[5] THEN
			Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].rTargetPowerEMS := rControllerQPIDSC;
	END_IF 
END_FOR	

(*----------------------------------------------------------------------------------------------------Controller to charge and discharge the battery in the peak load capping mode and load management mode----------------------------------------------------------------------------------------------------------*)

//IMPORTANT : On this 2 modes the Batterys are allways active.
//This means that in these two modes the battery is not processed via the state machine like other devices.
//They are there to limit the power to the grid connection. The batteries charge according to the release when the power on the grid is below the grid connection or when power is fed back to the grid.
//The 95% are used so that the remaining 5% are still seen as surplus and thus the remaining consumers can still be regulated up to take advantage of the full grid connection.
//The batteries are processed with their priorities during charging. THIS means that only those batteries are active which also match the current active priority in the EMS.

(*--------------------------------------------------------------------------------------------------------------------Discharge the batterys-----------------------------------------------------------------------------------------------------------------------------------------------*)

lrErrorPIDCorrectionBattPLCLM_Dischrg := ABS(lrGridPower - (lrSizeGridConnection * 0.95));

//Controller weighting
IF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eSlow THEN 
	IF lrErrorPIDCorrectionBattPLCLM_Dischrg <= 0.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.05; fbPIDBatteryPLCLM_Dischrg.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 0.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 1 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.07; fbPIDBatteryPLCLM_Dischrg.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 1 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 1.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.09; fbPIDBatteryPLCLM_Dischrg.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 1.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 2 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.11; fbPIDBatteryPLCLM_Dischrg.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 2 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 2.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.13; fbPIDBatteryPLCLM_Dischrg.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 2.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 3 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.15; fbPIDBatteryPLCLM_Dischrg.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 3 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 3.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.17; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 3.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 4 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.19; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 4 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 4.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.21; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 4.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.23; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.25; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	END_IF
ELSIF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eBalanced THEN
	IF lrErrorPIDCorrectionBattPLCLM_Dischrg <= 0.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.10; fbPIDBatteryPLCLM_Dischrg.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 0.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 1 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.14; fbPIDBatteryPLCLM_Dischrg.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 1 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 1.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.18; fbPIDBatteryPLCLM_Dischrg.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 1.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 2 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.22; fbPIDBatteryPLCLM_Dischrg.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 2 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 2.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.26; fbPIDBatteryPLCLM_Dischrg.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 2.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 3 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.30; fbPIDBatteryPLCLM_Dischrg.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 3 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 3.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.34; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 3.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 4 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.38; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 4 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 4.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.42; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 4.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.46; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.50; fbPIDBatteryPLCLM_Dischrg.udiIValue := 900;
	END_IF
ELSIF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eFast THEN
	IF lrErrorPIDCorrectionBattPLCLM_Dischrg <= 0.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.30; fbPIDBatteryPLCLM_Dischrg.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 0.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 1 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.33; fbPIDBatteryPLCLM_Dischrg.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 1 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 1.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.36; fbPIDBatteryPLCLM_Dischrg.udiIValue := 275; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 1.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 2 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.39; fbPIDBatteryPLCLM_Dischrg.udiIValue := 275; 	
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 2 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 2.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.42; fbPIDBatteryPLCLM_Dischrg.udiIValue := 500; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 2.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 3 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.45; fbPIDBatteryPLCLM_Dischrg.udiIValue := 500;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 3 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 3.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.48; fbPIDBatteryPLCLM_Dischrg.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 3.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 4 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.51; fbPIDBatteryPLCLM_Dischrg.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 4 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 4.5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.54; fbPIDBatteryPLCLM_Dischrg.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 4.5 AND lrErrorPIDCorrectionBattPLCLM_Dischrg <= 5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.57; fbPIDBatteryPLCLM_Dischrg.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Dischrg > 5 THEN fbPIDBatteryPLCLM_Dischrg.rPValue := 0.60; fbPIDBatteryPLCLM_Dischrg.udiIValue := 750;
	END_IF
END_IF 

IF (bEnable AND eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping AND NOT bEPMActive AND NOT bStopAll AND NOT bDischrgCmdFromBackendOK AND NOT fbPIDBatteryPLCLM_Chrg.bEnable AND lrGridPower >= (lrSizeGridConnection * 0.95)) OR 
	(bEnable AND eOperationMode = E_OperatingMode_EMS.eLoadManagement AND NOT bEPMActive AND NOT bStopAll AND NOT bDischrgCmdFromBackendOK AND NOT fbPIDBatteryPLCLM_Chrg.bEnable AND lrGridPower >= (SEL(b_ZeroPowerRegulation,lrSizeGridConnection,0) * 0.95)) THEN				
		fbPIDBatteryPLCLM_Dischrg.bEnable := TRUE;
END_IF
	IF NOT bEnable OR diNumberOfActiveBatterys = 0 OR bEPMActive OR bStopAll OR bDischrgCmdFromBackendOK OR fbPIDBatteryPLCLM_Chrg.bEnable OR eOperationMode = E_OperatingMode_EMS.eAllOff OR eOperationMode = E_OperatingMode_EMS.eSelfConsumption OR
		(lrGridPower < (SEL(b_ZeroPowerRegulation,lrSizeGridConnection,0) * 0.95) AND fbPIDBatteryPLCLM_Dischrg.rQController <= 0) THEN
		fbPIDBatteryPLCLM_Dischrg.bEnable := FALSE;
	END_IF    

fbPIDBatteryPLCLM_Dischrg( 
	bEnable:= , 
	rSetpoint:= lreal_to_real(SEL(b_ZeroPowerRegulation,lrSizeGridConnection,0)),		
	udiIValue:= , 
	udiDValue:= 0, 
	udiDamping:= 0, 
	rPValue:= , 
	rMaxValue:= 100, 
	rMinValue:= 0, 
	rNeutralZone:= 0.1, 
	bDirection:= TRUE, 
	rActualValue:= LREAL_TO_REAL(lrGridPower), 
	rQController=> );

FOR liLPDataBatteryInverter := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
	IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].byPriority <> 0 AND NOT bEPMActive AND fbPIDBatteryPLCLM_Dischrg.bEnable THEN
		Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].rTargetPowerEMS := fbPIDBatteryPLCLM_Dischrg.rQController;
	END_IF 
END_FOR	

(*--------------------------------------------------------------------------------------------------------------------Charge the batterys-----------------------------------------------------------------------------------------------------------------------------------------------*)

IF stSetupEMS.bAllowChrgFromGrid THEN 
	lrErrorPIDCorrectionBattPLCLM_Chrg := ABS(lrGridPower - (lrSizeGridConnection * 0.95));
ELSE
	lrErrorPIDCorrectionBattPLCLM_Chrg := ABS(0 - lrGridPower);
END_IF 

//Controller weighting
IF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eSlow THEN 
	IF lrErrorPIDCorrectionBattPLCLM_Chrg <= 0.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.05; fbPIDBatteryPLCLM_Chrg.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 0.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 1 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.07; fbPIDBatteryPLCLM_Chrg.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 1 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 1.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.09; fbPIDBatteryPLCLM_Chrg.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 1.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 2 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.11; fbPIDBatteryPLCLM_Chrg.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 2 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 2.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.13; fbPIDBatteryPLCLM_Chrg.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 2.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 3 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.15; fbPIDBatteryPLCLM_Chrg.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 3 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 3.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.17; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 3.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 4 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.19; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 4 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 4.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.21; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 4.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.23; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.25; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	END_IF
ELSIF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eBalanced THEN
	IF lrErrorPIDCorrectionBattPLCLM_Chrg <= 0.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.10; fbPIDBatteryPLCLM_Chrg.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 0.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 1 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.14; fbPIDBatteryPLCLM_Chrg.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 1 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 1.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.18; fbPIDBatteryPLCLM_Chrg.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 1.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 2 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.22; fbPIDBatteryPLCLM_Chrg.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 2 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 2.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.26; fbPIDBatteryPLCLM_Chrg.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 2.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 3 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.30; fbPIDBatteryPLCLM_Chrg.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 3 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 3.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.34; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 3.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 4 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.38; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 4 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 4.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.42; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 4.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.46; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.50; fbPIDBatteryPLCLM_Chrg.udiIValue := 900;
	END_IF
ELSIF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eFast THEN
	IF lrErrorPIDCorrectionBattPLCLM_Chrg <= 0.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.30; fbPIDBatteryPLCLM_Chrg.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 0.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 1 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.33; fbPIDBatteryPLCLM_Chrg.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 1 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 1.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.36; fbPIDBatteryPLCLM_Chrg.udiIValue := 275; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 1.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 2 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.39; fbPIDBatteryPLCLM_Chrg.udiIValue := 275; 	
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 2 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 2.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.42; fbPIDBatteryPLCLM_Chrg.udiIValue := 500; 
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 2.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 3 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.45; fbPIDBatteryPLCLM_Chrg.udiIValue := 500;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 3 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 3.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.48; fbPIDBatteryPLCLM_Chrg.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 3.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 4 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.51; fbPIDBatteryPLCLM_Chrg.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 4 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 4.5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.54; fbPIDBatteryPLCLM_Chrg.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 4.5 AND lrErrorPIDCorrectionBattPLCLM_Chrg <= 5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.57; fbPIDBatteryPLCLM_Chrg.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattPLCLM_Chrg > 5 THEN fbPIDBatteryPLCLM_Chrg.rPValue := 0.60; fbPIDBatteryPLCLM_Chrg.udiIValue := 750;
	END_IF	
END_IF

//Start and stop charge when charging from thr grid is allowed
IF (bEnable AND eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping AND stSetupEMS.bAllowChrgFromGrid AND NOT bEPMActive AND NOT bStopAll AND NOT 
		fbPIDBatteryPLCLM_Dischrg.bEnable AND NOT fbPIDDischrgCmdFromBackend.bEnable AND lrGridPower < (lrSizeGridConnection * 0.95)) AND (b_TimeBasedReleaseChargingBattery OR NOT b_EnableBatteryChargingControl) OR 
	(bEnable AND eOperationMode = E_OperatingMode_EMS.eLoadManagement AND stSetupEMS.bAllowChrgFromGrid AND NOT bEPMActive AND NOT bStopAll AND NOT 
		fbPIDBatteryPLCLM_Dischrg.bEnable AND NOT fbPIDDischrgCmdFromBackend.bEnable AND lrGridPower < (lrSizeGridConnection * 0.95)) 
THEN
			fbPIDBatteryPLCLM_Chrg.bEnable := TRUE;
END_IF
	IF (stSetupEMS.bAllowChrgFromGrid AND (NOT bEnable OR diNumberOfActiveBatterys = 0 OR bEPMActive OR bStopAll OR fbPIDBatteryPLCLM_Dischrg.bEnable OR eOperationMode = E_OperatingMode_EMS.eAllOff OR 
		eOperationMode = E_OperatingMode_EMS.eSelfConsumption OR fbPIDDischrgCmdFromBackend.bEnable OR (fbPIDBatteryPLCLM_Chrg.rQController >= 0 AND lrGridPower >= (lrSizeGridConnection * 0.95)))) or not b_TimeBasedReleaseChargingBattery THEN
			fbPIDBatteryPLCLM_Chrg.bEnable := FALSE;
	END_IF

//Start and stop charge when charging from thr grid is not allowed
IF (bEnable AND eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping AND NOT stSetupEMS.bAllowChrgFromGrid AND NOT bEPMActive AND NOT bStopAll AND NOT 
		fbPIDBatteryPLCLM_Dischrg.bEnable AND NOT fbPIDDischrgCmdFromBackend.bEnable AND lrGridPower < 0) OR 
	(bEnable AND eOperationMode = E_OperatingMode_EMS.eLoadManagement AND NOT stSetupEMS.bAllowChrgFromGrid AND NOT bEPMActive AND NOT bStopAll AND NOT 
		fbPIDBatteryPLCLM_Dischrg.bEnable AND NOT fbPIDDischrgCmdFromBackend.bEnable AND lrGridPower < 0) THEN
			fbPIDBatteryPLCLM_Chrg.bEnable := TRUE;
END_IF
	IF (NOT stSetupEMS.bAllowChrgFromGrid AND (NOT bEnable OR diNumberOfActiveBatterys = 0 OR bEPMActive OR bStopAll OR fbPIDBatteryPLCLM_Dischrg.bEnable OR eOperationMode = E_OperatingMode_EMS.eAllOff OR 
		eOperationMode = E_OperatingMode_EMS.eSelfConsumption OR fbPIDDischrgCmdFromBackend.bEnable OR (fbPIDBatteryPLCLM_Chrg.rQController >= 0 AND lrGridPower >= 0))) THEN
			fbPIDBatteryPLCLM_Chrg.bEnable := FALSE;
	END_IF

//Set the Setpoint from the controller	
IF stSetupEMS.bAllowChrgFromGrid AND dwAvarageBatterySOC < stSetupEMS.byResChrgfromGridToBatt THEN 
	fbPIDBatteryPLCLM_Chrg.rSetpoint := LREAL_TO_REAL(lrSizeGridConnection * 0.95);
ELSE
	fbPIDBatteryPLCLM_Chrg.rSetpoint := 0;
END_IF 	
	
fbPIDBatteryPLCLM_Chrg( 
	bEnable:= , 
	rSetpoint:= , 
	udiIValue:= , 
	udiDValue:= 0, 
	udiDamping:= 0, 
	rPValue:= , 
	rMaxValue:= 0, 
	rMinValue:= rMaxBattChargingPower *(-1), 
	rNeutralZone:= 0.1, 
	bDirection:= TRUE, 
	rActualValue:= LREAL_TO_REAL(lrGridPower), 
	rQController=> );

FOR liLPDataBatteryInverter := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
	IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].byPriority <= bySmGrActiveCommonPrio AND Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].byPriority <> 0 AND NOT 
		bEPMActive AND fbPIDBatteryPLCLM_Chrg.bEnable THEN
			Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].rTargetPowerEMS := fbPIDBatteryPLCLM_Chrg.rQController;
	END_IF 
END_FOR	
// test
mtest1 :=Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[1,1].byPriority <= bySmGrActiveCommonPrio; 
mtest2:=Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[1,1].byPriority <> 0;  


(*----------------------------------------------------------------------------------------------------Controller to discharge the battery in the emergency power mode----------------------------------------------------------------------------------------------------------*)

//All batterys what made active a island grid (Emergency power mode), the receive a target power form -100% to charge. The rest of the logic must implementet in each battery or batteryinverter function.
//Calculates the power from all batterys wich made a island grid
lrSizeBatteryPowerInEPO := 0;
FOR liLPDataBatteryInverter := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
	IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].bWorkOnIslandMode AND bEPMActive AND NOT bStopAll THEN 
		Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].rTargetPowerEMS := -100; 
			lrSizeBatteryPowerInEPO := lrSizeBatteryPowerInEPO + Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].lrPowerOnIslandMode;  
	END_IF
END_FOR	

lrErrorPIDCorrectionBattEPO := ABS(0 - lrSizeBatteryPowerInEPO);

//Controller weighting
IF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eSlow THEN
	IF lrErrorPIDCorrectionBattEPO <= 0.5 THEN fbPIDBatteryEPO.rPValue := 0.05; fbPIDBatteryEPO.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattEPO > 0.5 AND lrErrorPIDCorrectionBattEPO <= 1 THEN fbPIDBatteryEPO.rPValue := 0.07; fbPIDBatteryEPO.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattEPO > 1 AND lrErrorPIDCorrectionBattEPO <= 1.5 THEN fbPIDBatteryEPO.rPValue := 0.09; fbPIDBatteryEPO.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionBattEPO > 1.5 AND lrErrorPIDCorrectionBattEPO <= 2 THEN fbPIDBatteryEPO.rPValue := 0.11; fbPIDBatteryEPO.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionBattEPO > 2 AND lrErrorPIDCorrectionBattEPO <= 2.5 THEN fbPIDBatteryEPO.rPValue := 0.13; fbPIDBatteryEPO.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionBattEPO > 2.5 AND lrErrorPIDCorrectionBattEPO <= 3 THEN fbPIDBatteryEPO.rPValue := 0.15; fbPIDBatteryEPO.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionBattEPO > 3 AND lrErrorPIDCorrectionBattEPO <= 3.5 THEN fbPIDBatteryEPO.rPValue := 0.17; fbPIDBatteryEPO.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattEPO > 3.5 AND lrErrorPIDCorrectionBattEPO <= 4 THEN fbPIDBatteryEPO.rPValue := 0.19; fbPIDBatteryEPO.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattEPO > 4 AND lrErrorPIDCorrectionBattEPO <= 4.5 THEN fbPIDBatteryEPO.rPValue := 0.21; fbPIDBatteryEPO.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattEPO > 4.5 AND lrErrorPIDCorrectionBattEPO <= 5 THEN fbPIDBatteryEPO.rPValue := 0.23; fbPIDBatteryEPO.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattEPO > 5 THEN fbPIDBatteryEPO.rPValue := 0.25; fbPIDBatteryEPO.udiIValue := 900;
	END_IF
ELSIF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eBalanced THEN
	IF lrErrorPIDCorrectionBattEPO <= 0.5 THEN fbPIDBatteryEPO.rPValue := 0.10; fbPIDBatteryEPO.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattEPO > 0.5 AND lrErrorPIDCorrectionBattEPO <= 1 THEN fbPIDBatteryEPO.rPValue := 0.14; fbPIDBatteryEPO.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionBattEPO > 1 AND lrErrorPIDCorrectionBattEPO <= 1.5 THEN fbPIDBatteryEPO.rPValue := 0.18; fbPIDBatteryEPO.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionBattEPO > 1.5 AND lrErrorPIDCorrectionBattEPO <= 2 THEN fbPIDBatteryEPO.rPValue := 0.22; fbPIDBatteryEPO.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionBattEPO > 2 AND lrErrorPIDCorrectionBattEPO <= 2.5 THEN fbPIDBatteryEPO.rPValue := 0.26; fbPIDBatteryEPO.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionBattEPO > 2.5 AND lrErrorPIDCorrectionBattEPO <= 3 THEN fbPIDBatteryEPO.rPValue := 0.30; fbPIDBatteryEPO.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionBattEPO > 3 AND lrErrorPIDCorrectionBattEPO <= 3.5 THEN fbPIDBatteryEPO.rPValue := 0.34; fbPIDBatteryEPO.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattEPO > 3.5 AND lrErrorPIDCorrectionBattEPO <= 4 THEN fbPIDBatteryEPO.rPValue := 0.38; fbPIDBatteryEPO.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattEPO > 4 AND lrErrorPIDCorrectionBattEPO <= 4.5 THEN fbPIDBatteryEPO.rPValue := 0.42; fbPIDBatteryEPO.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattEPO > 4.5 AND lrErrorPIDCorrectionBattEPO <= 5 THEN fbPIDBatteryEPO.rPValue := 0.46; fbPIDBatteryEPO.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionBattEPO > 5 THEN fbPIDBatteryEPO.rPValue := 0.50; fbPIDBatteryEPO.udiIValue := 900;
	END_IF
ELSIF eSpeedModeLocalController = E_SpeedModeLocalController_EMS.eFast THEN
	IF lrErrorPIDCorrectionBattEPO <= 0.5 THEN fbPIDBatteryEPO.rPValue := 0.30; fbPIDBatteryEPO.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionBattEPO > 0.5 AND lrErrorPIDCorrectionBattEPO <= 1 THEN fbPIDBatteryEPO.rPValue := 0.33; fbPIDBatteryEPO.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionBattEPO > 1 AND lrErrorPIDCorrectionBattEPO <= 1.5 THEN fbPIDBatteryEPO.rPValue := 0.36; fbPIDBatteryEPO.udiIValue := 275; 
	ELSIF lrErrorPIDCorrectionBattEPO > 1.5 AND lrErrorPIDCorrectionBattEPO <= 2 THEN fbPIDBatteryEPO.rPValue := 0.39; fbPIDBatteryEPO.udiIValue := 275; 	
	ELSIF lrErrorPIDCorrectionBattEPO > 2 AND lrErrorPIDCorrectionBattEPO <= 2.5 THEN fbPIDBatteryEPO.rPValue := 0.42; fbPIDBatteryEPO.udiIValue := 500; 
	ELSIF lrErrorPIDCorrectionBattEPO > 2.5 AND lrErrorPIDCorrectionBattEPO <= 3 THEN fbPIDBatteryEPO.rPValue := 0.45; fbPIDBatteryEPO.udiIValue := 500;
	ELSIF lrErrorPIDCorrectionBattEPO > 3 AND lrErrorPIDCorrectionBattEPO <= 3.5 THEN fbPIDBatteryEPO.rPValue := 0.48; fbPIDBatteryEPO.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattEPO > 3.5 AND lrErrorPIDCorrectionBattEPO <= 4 THEN fbPIDBatteryEPO.rPValue := 0.51; fbPIDBatteryEPO.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattEPO > 4 AND lrErrorPIDCorrectionBattEPO <= 4.5 THEN fbPIDBatteryEPO.rPValue := 0.54; fbPIDBatteryEPO.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattEPO > 4.5 AND lrErrorPIDCorrectionBattEPO <= 5 THEN fbPIDBatteryEPO.rPValue := 0.57; fbPIDBatteryEPO.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionBattEPO > 5 THEN fbPIDBatteryEPO.rPValue := 0.60; fbPIDBatteryEPO.udiIValue := 750;
	END_IF
END_IF

IF bEnable AND bEPMActive AND arrMinPrioReached[1] AND arrMinPrioReached[2] AND arrMinPrioReached[3] AND arrMinPrioReached[4] AND arrMinPrioReached[5] AND NOT bChargePrioBatterysOnEPO AND NOT bStopAll THEN
	fbPIDBatteryEPO.bEnable := TRUE;
ELSE
	fbPIDBatteryEPO.bEnable := FALSE;
END_IF

fbPIDBatteryEPO(
	bEnable:= , 
	rSetpoint:= 0, 
	udiIValue:= , 
	udiDValue:= 0, 
	udiDamping:= 0, 
	rPValue:= , 
	rMaxValue:= 100, 
	rMinValue:= 0, 
	rNeutralZone:= 0.1, 
	bDirection:= TRUE, 
	rActualValue:= LREAL_TO_REAL(lrSizeBatteryPowerInEPO), 
	rQController=> rControllerQPIDEPO);

//Set the Controller output	to 0 when we have surplus. (Because its possible that the controller output is not set 100% to 0 regarding internal discrepancies)
IF rControllerQPIDEPO <= 0.4 AND fbPIDBatteryEPO.bEnable AND lrSizeBatteryPowerInEPO <= - Constants_Energy.rToleranceSurplusConsumption THEN
	timPIDEPO.IN := TRUE;
ELSE
	timPIDEPO.IN := FALSE;
END_IF
	
timPIDEPO(IN:= , PT:= T#15S, Q=> , ET=> );
	IF timPIDEPO.Q THEN rControllerQPIDEPO := 0; END_IF

FOR liLPDataBatteryInverter := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
	IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].byPriority <> 0 AND bEPMActive AND NOT Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].bWorkOnIslandMode AND 
		 arrMinPrioReached[1] AND arrMinPrioReached[2] AND arrMinPrioReached[3] AND arrMinPrioReached[4] AND arrMinPrioReached[5] AND NOT bChargePrioBatterysOnEPO THEN
			Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDataBatteryInverter].rTargetPowerEMS := rControllerQPIDEPO;
	END_IF
END_FOR 

(*-----------------------------------------------------------Controll the Batterys and Heating pumps with the Backend Commands-----------------------------------------------------------------*)

//Controll the Heating Pumps
FOR liLPDischrgCmdFromBackend := 1 TO Constants_Energy.diMaxNumberOfHeatingPumps BY 1 DO  
	IF timErrorWarning.Q AND timEnergyOptReady.Q AND NOT timHB.Q THEN 
		Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPDischrgCmdFromBackend].bExternalOnCommand := bActivateHP; 
	ELSE
		Lynus_Standards.GVL_Energy.stDataHeatingPumps[diNrOfEMS_OUT,liLPDischrgCmdFromBackend].bExternalOnCommand := FALSE;
	END_IF
END_FOR
	//Reset the Activation from the HP (Maybe when we have communicaiton Error with the backend in this time when he well reset the command or somthing else...)
	timResetActivateHP(IN:= bActivateHP, PT:= T#2M, Q=> , ET=> );
		IF timResetActivateHP.Q THEN bActivateHP := FALSE; END_IF

//Controll the discharge power from the Batterys with the power command from the Backend
//Calculate the actual Battery Power
lrActualPowerBatterys := 0;
	FOR liLPDischrgCmdFromBackend := 1 TO Constants_Energy.diMaxNumberOfBatterys BY 1 DO
		lrActualPowerBatterys := lrActualPowerBatterys + Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_OUT,liLPDischrgCmdFromBackend].lrPower;	
	END_FOR

//Reset the Controller when we have surplus in the slef consumption mode
IF bSurplusAvailable AND eOperationMode = E_OperatingMode_EMS.eSelfConsumption THEN 
	timPIDDischrgCmdFromBackend.IN := TRUE;
ELSE
	timPIDDischrgCmdFromBackend.IN := FALSE;
END_IF

//Reset the Controller when we have surplus in the Load capping or load management mode
IF ((eOperationMode = E_OperatingMode_EMS.eLoadManagement OR eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping) AND (lrGridPower < (lrSizeGridConnection * 0.95))) THEN
	timPIDDischrgCmdFromBackend.IN := TRUE;
END_IF
	IF ((eOperationMode = E_OperatingMode_EMS.eLoadManagement OR eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping) AND (lrGridPower >= (lrSizeGridConnection * 0.95))) THEN
		timPIDDischrgCmdFromBackend.IN := FALSE;
	END_IF	  

//Give the Controller 35 Seconds Time. So he can make 3 times a correction for the power when the Backend commands to much Battery power.
timPIDDischrgCmdFromBackend(IN:= , PT:= T#35S, Q=> , ET=> );

//Enable or dissable the controller when Self Consumption mode is active
IF bEnable AND NOT bEPMActive AND NOT bStopAll AND bDischrgCmdFromBackendOK AND eOperationMode <> E_OperatingMode_EMS.eAllOff AND diMemCmpOperationState = 0 AND 
	arrMinPrioReached[1] AND arrMinPrioReached[2] AND arrMinPrioReached[3] AND arrMinPrioReached[4] AND arrMinPrioReached[5] AND NOT timPIDDischrgCmdFromBackend.Q AND eOperationMode = E_OperatingMode_EMS.eSelfConsumption THEN
		fbPIDDischrgCmdFromBackend.bEnable := TRUE;
ELSE
		fbPIDDischrgCmdFromBackend.bEnable := FALSE;
END_IF	

//Enable or dissable the controller when Paeak Load capping or load management mode is active
IF bEnable AND NOT bEPMActive AND NOT bStopAll AND bDischrgCmdFromBackendOK AND eOperationMode <> E_OperatingMode_EMS.eAllOff AND diMemCmpOperationState = 0 AND 
	eOperationMode = E_OperatingMode_EMS.eLoadManagement AND NOT fbPIDBatteryPLCLM_Chrg.bEnable AND NOT timPIDDischrgCmdFromBackend.Q THEN
		fbPIDDischrgCmdFromBackend.bEnable := TRUE;
END_IF	
	IF eOperationMode = E_OperatingMode_EMS.eLoadManagement AND (NOT bEnable OR diNumberOfActiveBatterys = 0 OR bEPMActive OR bStopAll OR fbPIDBatteryPLCLM_Chrg.bEnable OR timPIDDischrgCmdFromBackend.Q) THEN fbPIDDischrgCmdFromBackend.bEnable := FALSE; END_IF

IF bEnable AND NOT bEPMActive AND NOT bStopAll AND bDischrgCmdFromBackendOK AND eOperationMode <> E_OperatingMode_EMS.eAllOff AND diMemCmpOperationState = 0 AND 
	eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping AND NOT fbPIDBatteryPLCLM_Chrg.bEnable AND NOT timPIDDischrgCmdFromBackend.Q THEN
		fbPIDDischrgCmdFromBackend.bEnable := TRUE;
END_IF	
	IF eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping AND (NOT bEnable OR diNumberOfActiveBatterys = 0 OR bEPMActive OR bStopAll OR fbPIDBatteryPLCLM_Chrg.bEnable OR timPIDDischrgCmdFromBackend.Q) THEN fbPIDDischrgCmdFromBackend.bEnable := FALSE; END_IF 

//Correction and safety for the Setpoint, that we dont give power back to the grid
//Set one time the new received Battery power and make then the correction (New reveived value from Backend or the PID Controller start from new)
FPEnablePID(CLK:= fbPIDDischrgCmdFromBackend.bEnable, Q=> );
	IF rNewBattPower <> rNewBattPower_CP OR FPEnablePID.Q THEN
		lrNewBatteryPowerWithCorrection := rNewBattPower;
			rNewBattPower_CP := rNewBattPower;
	END_IF

//Give the Controller and the Inverter time to set the new Setpoint
IF lrGridPower <> lrGridPower_CP AND NOT timCorrectionSetpoint.Q  AND bDischrgCmdFromBackendOK THEN
	timCorrectionSetpoint.IN := TRUE;
		lrGridPower_CP := lrGridPower;
ELSE
	timCorrectionSetpoint.IN := FALSE;
END_IF	 

//Make the correction a litte bit faster when the power on the grid is not so big
timCorrectionSetpoint.PT := T#10S;
IF lrGridPower >= - 0.30 AND lrGridPower <= 0.30 THEN timCorrectionSetpoint.PT := T#7.5S; END_IF
IF lrGridPower >= - 0.20 AND lrGridPower <= 0.20 THEN timCorrectionSetpoint.PT := T#5S; END_IF

timCorrectionSetpoint(IN:= , PT:= , Q=> , ET=> );
	FPMakeCorrection(CLK:= timCorrectionSetpoint.Q, Q=> );

//Batterycorrection when Self Consumption Mode is active
IF FPMakeCorrection.Q AND eOperationMode = E_OperatingMode_EMS.eSelfConsumption THEN
	lrNewBatteryPowerWithCorrection := lrNewBatteryPowerWithCorrection + lrGridPower;
END_IF
	//Batterycorrection when Peak load capping or load management Mode is active
	IF FPMakeCorrection.Q AND eOperationMode = E_OperatingMode_EMS.eLoadManagement OR eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping THEN
		lrNewBatteryPowerWithCorrection := (lrNewBatteryPowerWithCorrection + (lrGridPower - (lrSizeGridConnection * 0.96)));
	END_IF

IF lrNewBatteryPowerWithCorrection < 0 THEN lrNewBatteryPowerWithCorrection := 0; END_IF
	IF lrNewBatteryPowerWithCorrection > rNewBattPower THEN lrNewBatteryPowerWithCorrection := rNewBattPower; END_IF 

lrErrorPIDCorrectionDischrgCmdFromBackend := ABS(lrNewBatteryPowerWithCorrection - lrActualPowerBatterys);

//Controller weighting
IF eSpeedModeBackendController = E_SpeedModeBackendController_EMS.eSlow THEN
	IF lrErrorPIDCorrectionDischrgCmdFromBackend <= 0.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.05; fbPIDDischrgCmdFromBackend.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 0.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 1 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.07; fbPIDDischrgCmdFromBackend.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 1 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 1.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.09; fbPIDDischrgCmdFromBackend.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 1.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 2 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.11; fbPIDDischrgCmdFromBackend.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 2 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 2.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.13; fbPIDDischrgCmdFromBackend.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 2.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 3 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.15; fbPIDDischrgCmdFromBackend.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 3 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 3.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.17; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 3.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 4 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.19; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 4 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 4.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.21; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 4.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.23; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.25; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	END_IF
ELSIF eSpeedModeBackendController = E_SpeedModeBackendController_EMS.eBalanced THEN
	IF lrErrorPIDCorrectionDischrgCmdFromBackend <= 0.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.10; fbPIDDischrgCmdFromBackend.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 0.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 1 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.14; fbPIDDischrgCmdFromBackend.udiIValue := 450;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 1 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 1.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.18; fbPIDDischrgCmdFromBackend.udiIValue := 450; 
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 1.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 2 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.22; fbPIDDischrgCmdFromBackend.udiIValue := 450; 	
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 2 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 2.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.26; fbPIDDischrgCmdFromBackend.udiIValue := 675; 
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 2.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 3 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.30; fbPIDDischrgCmdFromBackend.udiIValue := 675;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 3 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 3.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.34; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 3.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 4 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.38; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 4 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 4.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.42; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 4.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.46; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.50; fbPIDDischrgCmdFromBackend.udiIValue := 900;
	END_IF
ELSIF eSpeedModeBackendController = E_SpeedModeBackendController_EMS.eFast THEN
	IF lrErrorPIDCorrectionDischrgCmdFromBackend <= 0.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.40; fbPIDDischrgCmdFromBackend.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 0.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 1 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.42; fbPIDDischrgCmdFromBackend.udiIValue := 275;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 1 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 1.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.44; fbPIDDischrgCmdFromBackend.udiIValue := 275; 
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 1.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 2 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.46; fbPIDDischrgCmdFromBackend.udiIValue := 275; 	
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 2 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 2.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.48; fbPIDDischrgCmdFromBackend.udiIValue := 500; 
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 2.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 3 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.50; fbPIDDischrgCmdFromBackend.udiIValue := 500;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 3 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 3.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.52; fbPIDDischrgCmdFromBackend.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 3.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 4 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.54; fbPIDDischrgCmdFromBackend.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 4 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 4.5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.56; fbPIDDischrgCmdFromBackend.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 4.5 AND lrErrorPIDCorrectionDischrgCmdFromBackend <= 5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.58; fbPIDDischrgCmdFromBackend.udiIValue := 750;
	ELSIF lrErrorPIDCorrectionDischrgCmdFromBackend > 5 THEN fbPIDDischrgCmdFromBackend.rPValue := 0.60; fbPIDDischrgCmdFromBackend.udiIValue := 750;
	END_IF
END_IF

fbPIDDischrgCmdFromBackend(
	bEnable:= , 
	rSetpoint:= LREAL_TO_REAL(lrNewBatteryPowerWithCorrection), 
	udiIValue:= , 
	udiDValue:= 0, 
	udiDamping:= 0, 
	rPValue:= , 
	rMaxValue:= 100, 
	rMinValue:= 0,
	rNeutralZone:= 0.1, 
	bDirection:= FALSE, 
	rActualValue:= LREAL_TO_REAL(lrActualPowerBatterys), 
	rQController=> rControllerQPIDDischrgCmdFromBackend);

IF eOperationMode = E_OperatingMode_EMS.eSelfConsumption THEN 
	FOR liLPDischrgCmdFromBackend := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
		IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDischrgCmdFromBackend].byPriority <> 0 AND NOT bEPMActive AND bDischrgCmdFromBackendOK AND	
			arrMinPrioReached[1] AND arrMinPrioReached[2] AND arrMinPrioReached[3] AND arrMinPrioReached[4] AND arrMinPrioReached[5] THEN
				Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDischrgCmdFromBackend].rTargetPowerEMS := rControllerQPIDDischrgCmdFromBackend;
		END_IF 
	END_FOR	
ELSE
	FOR liLPDischrgCmdFromBackend := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
		IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDischrgCmdFromBackend].byPriority <> 0 AND NOT bEPMActive AND fbPIDDischrgCmdFromBackend.bEnable THEN
			Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDischrgCmdFromBackend].rTargetPowerEMS := rControllerQPIDDischrgCmdFromBackend;
		END_IF 
	END_FOR	
END_IF

//On this Modes set the Battery Power to 0 when no charge and no discharge controller is active
IF eOperationMode = E_OperatingMode_EMS.eLoadManagement OR eOperationMode = E_OperatingMode_EMS.ePeakLoadCapping THEN
	IF NOT fbPIDBatteryPLCLM_Chrg.bEnable AND NOT fbPIDBatteryPLCLM_Dischrg.bEnable AND NOT fbPIDDischrgCmdFromBackend.bEnable THEN
		FOR liLPDischrgCmdFromBackend := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
			Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPDischrgCmdFromBackend].rTargetPowerEMS := 0;
		END_FOR	
	END_IF
END_IF	    

(*------------------------------------------------------------------------------Progress and State----------------------------------------------------------------------------------------*)
	
IF NOT arrMinPrioReached[1] AND NOT arrMinPrioReached[2] AND NOT arrMinPrioReached[3] AND NOT arrMinPrioReached[4] AND NOT arrMinPrioReached[5] THEN
	byProgress := REAL_TO_BYTE(F_Scalvalue(x:= UINT_TO_REAL(uiState), x1:= 0, y1:= 0, x2:= 110, y2:= 100));
ELSE
	byProgress := 100;
END_IF 
	byProgress := LIMIT(0,byProgress,100);

uiState_OUT := uiState;
	
(*-----------------------------------------------------------Write data to Global structure for batterys and battery inverters-----------------------------------------------------------------*)

FOR liLPBatterysSetupData := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
	Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPBatterysSetupData].byReserveSOCEPO := stSetupEMS.byReserveSOCEPO;
		Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_OUT,liLPBatterysSetupData].byMaxDepthOfDischargeEPO := stSetupEMS.byMaxDepthOfDischrgEPO;	
END_FOR

(*----------------------------------------------------------Handle messages from this device-----------------------------------------------------------------*)

fbMessagesEMS.wMessageCode := 0;

IF arrMinPrioReached[1] AND arrMinPrioReached[2] AND arrMinPrioReached[3] AND arrMinPrioReached[4] AND arrMinPrioReached[5] THEN fbMessagesEMS.wMessageCode := 1; END_IF
IF arrMaxPrioReached[1] AND arrMaxPrioReached[2] AND arrMaxPrioReached[3] AND arrMaxPrioReached[4] AND arrMaxPrioReached[5] THEN fbMessagesEMS.wMessageCode := 2; END_IF
IF bMissingPowerData THEN fbMessagesEMS.wMessageCode := 3; END_IF
IF bStopAll THEN fbMessagesEMS.wMessageCode := 4; END_IF
IF bStopAll AND timDissableFunctions.Q THEN fbMessagesEMS.wMessageCode := 5; END_IF

fbMessagesEMS(bEnable:= bEnable, wMessageCode:= , eMessageEMS=> eMessageEMS);

(*----------------------------------------------------------Save persistent data----------------------------------------------------------------*)

arrPD[1](lrValue:= BOOL_TO_LREAL(bEnable), bEventBasedActive=> );
arrPD[2](lrValue:= DINT_TO_LREAL(diNrOfEM_IN_ECS), bEventBasedActive=> );
arrPD[3](lrValue:= BYTE_TO_LREAL(stSetupEMS.byReserveSOCEPO), bEventBasedActive=> );
arrPD[4](lrValue:= BYTE_TO_LREAL(stSetupEMS.byMaxDepthOfDischrgEPO), bEventBasedActive=> );
arrPD[5](lrValue:= BYTE_TO_LREAL(stSetupEMS.byResChrgfromGridToBatt), bEventBasedActive=> );
arrPD[6](lrValue:= INT_TO_LREAL(eOperationMode), bEventBasedActive=> );
arrPD[7](lrValue:= REAL_TO_LREAL(stSetupEMS.rSizeMainFuseCS), bEventBasedActive=> );
arrPD[8](lrValue:= UINT_TO_LREAL(stSetupEMS.uiUpdateTime), bEventBasedActive=> );
arrPD[9](lrValue:= INT_TO_LREAL(eSpeedModeBackendController), bEventBasedActive=> );
arrPD[10](lrValue:= BOOL_TO_LREAL(stSetupEMS.bAllowChrgFromGrid), bEventBasedActive=> );
arrPD[11](lrValue:= BOOL_TO_LREAL(stSetupEMS.bEnableMainFuseFunction), bEventBasedActive=> );
arrPD[12](lrValue:= BYTE_TO_LREAL(stSetupEMS.byPrioMinChrgBattSOCInEPO), bEventBasedActive=> );


(*----------------------------------------------------------impuls for start/stop charging battery----------------------------------------------------------------*)
IF b_EnableBatteryChargingControl THEN
	IF b_StartReleaseBatteryCharging THEN // AND NOT b_StopReleaseBatteryCharging THEN
		RS_BatteryChargingControl.SET:=TRUE;
		RS_BatteryChargingControl.RESET1:=FALSE;
	ELSIF NOT b_StartReleaseBatteryCharging AND b_StopReleaseBatteryCharging THEN
			RS_BatteryChargingControl.SET:=FALSE;
		RS_BatteryChargingControl.RESET1:=TRUE;
	END_IF
ELSE
	RS_BatteryChargingControl.RESET1:=TRUE;
	RS_BatteryChargingControl.SET:=false;
END_IF

RS_BatteryChargingControl(Q1=>b_TimeBasedReleaseChargingBattery);



]]></ST>
    </Implementation>
    <LineIds Name="FB_EMS_T">
      <LineId Id="17071" Count="2" />
      <LineId Id="13830" Count="24" />
      <LineId Id="17498" Count="0" />
      <LineId Id="13855" Count="0" />
      <LineId Id="17501" Count="0" />
      <LineId Id="17537" Count="0" />
      <LineId Id="13856" Count="9" />
      <LineId Id="17841" Count="1" />
      <LineId Id="13866" Count="72" />
      <LineId Id="17215" Count="0" />
      <LineId Id="13940" Count="54" />
      <LineId Id="17533" Count="0" />
      <LineId Id="13996" Count="117" />
      <LineId Id="16098" Count="1" />
      <LineId Id="14116" Count="10" />
      <LineId Id="17359" Count="0" />
      <LineId Id="14129" Count="8" />
      <LineId Id="14139" Count="2" />
      <LineId Id="16100" Count="1" />
      <LineId Id="14144" Count="39" />
      <LineId Id="14185" Count="680" />
      <LineId Id="16270" Count="8" />
      <LineId Id="16280" Count="19" />
      <LineId Id="16268" Count="1" />
      <LineId Id="14866" Count="60" />
      <LineId Id="17691" Count="0" />
      <LineId Id="14928" Count="128" />
      <LineId Id="17044" Count="0" />
      <LineId Id="15058" Count="3" />
      <LineId Id="17056" Count="1" />
      <LineId Id="15062" Count="0" />
      <LineId Id="17058" Count="1" />
      <LineId Id="15063" Count="0" />
      <LineId Id="17060" Count="0" />
      <LineId Id="17067" Count="0" />
      <LineId Id="17066" Count="0" />
      <LineId Id="17065" Count="0" />
      <LineId Id="17061" Count="0" />
      <LineId Id="17063" Count="0" />
      <LineId Id="17062" Count="0" />
      <LineId Id="15065" Count="113" />
      <LineId Id="16266" Count="0" />
      <LineId Id="16262" Count="0" />
      <LineId Id="16260" Count="0" />
      <LineId Id="16263" Count="0" />
      <LineId Id="15179" Count="3" />
      <LineId Id="16267" Count="0" />
      <LineId Id="16264" Count="0" />
      <LineId Id="16261" Count="0" />
      <LineId Id="15183" Count="0" />
      <LineId Id="16265" Count="0" />
      <LineId Id="15184" Count="29" />
      <LineId Id="16253" Count="4" />
      <LineId Id="16251" Count="1" />
      <LineId Id="15214" Count="0" />
      <LineId Id="16238" Count="12" />
      <LineId Id="15220" Count="70" />
      <LineId Id="16259" Count="0" />
      <LineId Id="15291" Count="66" />
      <LineId Id="16796" Count="0" />
      <LineId Id="16798" Count="10" />
      <LineId Id="16795" Count="0" />
      <LineId Id="16810" Count="11" />
      <LineId Id="16809" Count="0" />
      <LineId Id="16793" Count="0" />
      <LineId Id="15358" Count="11" />
      <LineId Id="16794" Count="0" />
      <LineId Id="15370" Count="51" />
      <LineId Id="16822" Count="0" />
      <LineId Id="16781" Count="10" />
      <LineId Id="15433" Count="0" />
      <LineId Id="16823" Count="0" />
      <LineId Id="16826" Count="10" />
      <LineId Id="16825" Count="0" />
      <LineId Id="16838" Count="11" />
      <LineId Id="16837" Count="0" />
      <LineId Id="16824" Count="0" />
      <LineId Id="15434" Count="38" />
      <LineId Id="16850" Count="0" />
      <LineId Id="16770" Count="10" />
      <LineId Id="16587" Count="0" />
      <LineId Id="16852" Count="0" />
      <LineId Id="16854" Count="10" />
      <LineId Id="16853" Count="0" />
      <LineId Id="16867" Count="11" />
      <LineId Id="16866" Count="0" />
      <LineId Id="16851" Count="0" />
      <LineId Id="15485" Count="5" />
      <LineId Id="17536" Count="0" />
      <LineId Id="15491" Count="45" />
      <LineId Id="17683" Count="0" />
      <LineId Id="17686" Count="0" />
      <LineId Id="17689" Count="0" />
      <LineId Id="17684" Count="0" />
      <LineId Id="15537" Count="15" />
      <LineId Id="16881" Count="0" />
      <LineId Id="16883" Count="10" />
      <LineId Id="16882" Count="0" />
      <LineId Id="16895" Count="11" />
      <LineId Id="16894" Count="0" />
      <LineId Id="16879" Count="0" />
      <LineId Id="15553" Count="11" />
      <LineId Id="16880" Count="0" />
      <LineId Id="15565" Count="255" />
      <LineId Id="15958" Count="3" />
      <LineId Id="17507" Count="1" />
      <LineId Id="17506" Count="0" />
      <LineId Id="17515" Count="0" />
      <LineId Id="17519" Count="0" />
      <LineId Id="17521" Count="0" />
      <LineId Id="17528" Count="0" />
      <LineId Id="17523" Count="0" />
      <LineId Id="17529" Count="0" />
      <LineId Id="17524" Count="0" />
      <LineId Id="17522" Count="0" />
      <LineId Id="17525" Count="1" />
      <LineId Id="17530" Count="0" />
      <LineId Id="17520" Count="0" />
      <LineId Id="17516" Count="0" />
      <LineId Id="17512" Count="0" />
      <LineId Id="17517" Count="0" />
      <LineId Id="17513" Count="1" />
      <LineId Id="17511" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>