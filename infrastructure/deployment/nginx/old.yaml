apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx
  namespace: lynus
data:
  nginx.conf: |
    worker_processes auto;
    pid /run/nginx.pid;

    events {
        worker_connections 768;
        # multi_accept on;
    }

    http {
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        types_hash_max_size 2048;
        proxy_max_temp_file_size 0;

        server_tokens off;

        # server_names_hash_bucket_size 64;
        # server_name_in_redirect off;

        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers on;

        error_log  stderr warn;
        access_log  /dev/stdout;

        # https://gist.github.com/kilhage/7f0e7546457716dc9174
        gzip on;
        gzip_proxied any;
        gzip_types
        	text/css
        	text/plain
        	text/javascript
        	application/javascript
        	application/json
        	application/x-javascript
        	application/xml
        	application/xml+rss
        	application/xhtml+xml
        	application/x-font-ttf
        	application/x-font-opentype
        	application/vnd.ms-fontobject
        	image/svg+xml
        	image/x-icon;
          
        gzip_comp_level 9;
        gzip_http_version 1.0;
        gzip_vary on;
        gzip_buffers 16 8k;
        gzip_min_length 50;

        map $http_upgrade $connection_upgrade {
            default upgrade;
            '' close;
        }

        server {
            listen 80 default_server;
            server_name _;
            return 301 https://$host$request_uri;
        }

        server {
            listen 443 ssl;
            server_name admin.${DOMAIN};

            ssl_certificate /etc/nginx/ssl/tls.crt;
            ssl_certificate_key /etc/nginx/ssl/tls.key;

            location / {
                proxy_pass http://admin-console;
            }
        }

        server {
            listen 443 ssl;
            server_name dashboard.${DOMAIN};

            ssl_certificate /etc/nginx/ssl/tls.crt;
            ssl_certificate_key /etc/nginx/ssl/tls.key;

            location / {
                proxy_pass http://dashboard;
            }
        }

        server {
            listen 443 ssl;
            server_name monitoring.${DOMAIN};

            ssl_certificate /etc/nginx/ssl/tls.crt;
            ssl_certificate_key /etc/nginx/ssl/tls.key;

            location / {
                proxy_set_header Host $http_host;
                proxy_pass http://grafana:3000;
            }

            location /api/live/ {
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
                proxy_set_header Host $http_host;
                proxy_pass http://grafana:3000;
            }
        }

        server {
            listen 443 ssl;
            server_name s3.${DOMAIN};

            ssl_certificate /etc/nginx/ssl/tls.crt;
            ssl_certificate_key /etc/nginx/ssl/tls.key;

            ignore_invalid_headers off;
            client_max_body_size 100m;
            proxy_buffering off;

            location /minio/v2/metrics/cluster {
                return 401;
            }

            location / {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $remote_addr;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Host $http_host;

                proxy_connect_timeout 300;
                proxy_http_version 1.1;
                proxy_set_header Connection "";
                chunked_transfer_encoding off;

                
                proxy_pass http://minio:9000;
            }
        }

        proxy_cache_path /tmp keys_zone=icons:10m max_size=1000m use_temp_path=off;
        server {
            listen 443 ssl;
            server_name static.${DOMAIN};

            ssl_certificate /etc/nginx/ssl/tls.crt;
            ssl_certificate_key /etc/nginx/ssl/tls.key;

            location ~ "^/icons/([0-9]{1,8}).(png|svg)" {
                proxy_cache icons;

                resolver 8.8.8.8;
                proxy_ssl_server_name on;
                proxy_set_header Host static.thenounproject.com;
                proxy_pass https://static.thenounproject.com/png/$1-200.png;
            }

            location /assets/ {
                proxy_pass http://api/assets/;
            }
        }

        server {
            listen 443 ssl;
            server_name accounts.${DOMAIN};

            ssl_certificate /etc/nginx/ssl/tls.crt;
            ssl_certificate_key /etc/nginx/ssl/tls.key;

            location / {
                # redirect traffic from the root url to /auth/ as nothing is served on the root url
                return 301 /auth/;
            }

            location /auth/ {
                # https://keycloak.discourse.group/t/keycloak-in-docker-behind-reverse-proxy/1195/13
                # https://itnext.io/nginx-as-reverse-proxy-in-front-of-keycloak-21e4b3f8ec53
                proxy_set_header X-Forwarded-For $remote_addr;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection ‘upgrade’;
                proxy_set_header Host $host;

                # https://stackoverflow.com/a/57496495
                proxy_buffer_size 128k;
                proxy_buffers 4 256k;
                proxy_busy_buffers_size 256k;
                proxy_pass http://keycloak;
            }
        }

        # api
        limit_req_zone $binary_remote_addr zone=api_limit:100m rate=64r/s;
        server {
            listen 443 ssl;
            server_name api.${DOMAIN};

            proxy_connect_timeout 600s;
            proxy_send_timeout 600s;
            proxy_read_timeout 600s;
            send_timeout 600s;

            ssl_certificate /etc/nginx/ssl/tls.crt;
            ssl_certificate_key /etc/nginx/ssl/tls.key;

            location /v1/notifications {
                return 401;
            }

            location /v1/metrics {
                return 401;
            }

            location = /v1/swagger {
                return 308 /v1/swagger/;
            }


            location /v1/ {
                limit_req zone=api_limit burst=64 nodelay;
                limit_req_status 429;

                #hopefully this enables sse to work (https://stackoverflow.com/a/13673298)
                proxy_set_header Connection '';
                proxy_http_version 1.1;
                chunked_transfer_encoding off;
                proxy_buffering off;
                proxy_cache off;

                proxy_set_header X-Forwarded-For $remote_addr;
                proxy_pass http://api/;
            }
        }

        # mqtt websockets
        server {
            listen 443 ssl;
            server_name mqtt.${DOMAIN};

            ssl_certificate /etc/nginx/ssl/tls.crt;
            ssl_certificate_key /etc/nginx/ssl/tls.key;
            ssl_ciphers ALL;

            location / {
                proxy_pass http://proxy:9001;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "Upgrade";
                proxy_set_header Host $host;
            }
        }
    }

    stream {
        server {
            listen 8883 ssl;

            ssl_certificate /etc/nginx/ssl/mqtt.crt;
            ssl_certificate_key /etc/nginx/ssl/mqtt.key;
            ssl_ciphers ALL;

            proxy_pass proxy:1883;
        }

        server {
            listen 1883;

            proxy_pass proxy:1883;
        }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  namespace: lynus
  labels:
    app: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.25.2-alpine
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "1024Mi"
              cpu: "1000m"
          imagePullPolicy: Always
          env:
            - name: DOMAIN
              valueFrom:
                secretKeyRef:
                  key: DOMAIN
                  name: lynus-credentials
            - name: NGINX_ENVSUBST_OUTPUT_DIR
              value: /etc/nginx
          ports:
            - containerPort: 443
              name: https
            - containerPort: 80
              name: http
            - containerPort: 1883
              name: mqtt
            - containerPort: 8883
              name: mqtts
          volumeMounts:
            - mountPath: /etc/nginx/templates/nginx.conf.template
              readOnly: true
              name: config
              subPath: nginx.conf
            - mountPath: /etc/nginx/ssl/
              readOnly: true
              name: tls
      nodeSelector:
        nodetype: large
      volumes:
        - name: config
          configMap:
            name: nginx
        - name: tls
          secret:
            secretName: tls-certificates
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-lb
  namespace: lynus
  annotations:
    service.beta.kubernetes.io/exoscale-loadbalancer-service-instancepool-id: "INSTANCEPOOL_ID"
spec:
  selector:
    app: nginx
  ports:
    - name: https
      port: 443
    - name: http
      port: 80
    - name: mqtts
      port: 8883
    - name: mqtt
      port: 1883
  type: LoadBalancer
