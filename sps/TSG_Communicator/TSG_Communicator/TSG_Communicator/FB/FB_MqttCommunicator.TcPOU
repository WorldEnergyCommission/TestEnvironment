<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MqttCommunicator" Id="{4819176e-d293-45c7-a44a-e7fef91e0c6e}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'hide_all_locals'}
FUNCTION_BLOCK FB_MqttCommunicator
VAR_INPUT
	bConnect      				: BOOL;															//If True then a connection to the cloud service is established
	sUserName     				: STRING(36);     												//Username that was given in the cloud when the project was created
    sUserPassword 				: STRING(36);   					 							//Password that was given in the cloud when the project was created
	eSavePositionCertificate	: eSavePositionOnPLC;											//Save Position from the certificate (HardDisk\ or C:\) 
END_VAR
VAR_OUTPUT
	bConnected					: BOOL;															//True = PLC is Connected to the cloud service FALSE = Not connected
	bError          			: BOOL;															//Error flag
    hrErrorCode      			: HRESULT;														//Error code if bError is true
    eConnectionState 			: ETcIotMqttClientState;										//State of the cloud connection
	eErrorMessage_Out			: eErrorMessage;												//Error State from received Messege
END_VAR
VAR
	(*-----------------------------------------------------Other-----------------------------------------------------------------------------------------*)
	fbMqttClient    			: FB_IotMqttClient;												//Function mqtt client
	fbJsonWrite					: FB_MessageWrite;												//Json Write function
	fbJsonRead					: FB_MessageRead;												//Json Read function
	fbGetTime					: NT_GetTime;													//System time
	FNGetTimeDate				: F_TRIG;														//Intern falling edge
	timError					: TON;															//Timer error to clear Message Queue
    bSetParameter   			: BOOL := TRUE;													//Set new parameter
	bClientIDCreated			: BOOL;															//True if the client id is generated
	byLPCopyValuesGV_1			: BYTE;															//Loop to copy the data from global interface in the read Json function
	udiLPCopyValuesGV_2			: UDINT;														//Loop to copy the data from global interface in the read Json function
	sUserNameOld     			: STRING(36);    												//Old User name from the project
    sUserPasswordOld 			: STRING(36);    												//Old Password for the project
	sClientID					: STRING(255);													//Client ID
	eSavePositionCertificateOld	: eSavePositionOnPLC;											//Old Position from the certificate (HardDisk\ or C:\) 
	(*---------------------------------------------------published message---------------------------------------------------------------------------*)
	arrBusySendigInterface		: ARRAY[1..10] OF BOOL;											//Array to save with what Send Interface it was sending the last message to enbale that after sending for new Message
	arrTimoutSendinigInterface	: ARRAY[1..10] OF TON;											//Timer to Reset a Sending Interface after a Delay. That its not possible to block everytime the sending interface 
   	bHBSending					: BOOL;															//Heart Beat Sending is in progress
	byLPJsonSend				: BYTE;															//Loop to prepear data befor sending
	byLPSendInterface			: BYTE;															//Loop for the send interface
	uiStatePublish				: UINT;															//State maschine sending
	sTopicPub   				: STRING(255);													//Topic publish
    sPayloadPub 				: STRING(7000);													//Payload publish
    fbTimerPub 					: TON;															//Timer to send the message to the broker after expiration of time 
	fbTimerHB					: TON;															//Timer for sending the Heart Beat
	(*---------------------------------------------------received message----------------------------------------------------------------------------*)
    bSubscribed    				: BOOL;															//True if the connection to the broker is on
	bUnsubscribe				: BOOL;															//True if the connection to the broker is off
	bReadOut					: BOOL;															//Read out value from received buffer
	bBusyWrite					: BOOL;															//Interface write is busy	
	bErrorWrite					: BOOL;															//Interface write has a error
	byCounterBusyErrorWrite		: BYTE;															//Counter to clear error or busy state
    byLPWriteInterface			: BYTE;															//Loop for the write interface
	sTopicSub      				: STRING(255);													//Topic subscrib
	{attribute 'TcEncoding':='UTF-8'}
  	sPayloadRcv    				: STRING(7000);													//Payload received
  	fbMessageQueue 				: FB_IotMqttMessageQueue;										//Function message queuee
    fbMessage      				: FB_IotMqttMessage;											//Function message
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Kai Ebensperger
//Company : Lynus AG
//Updated : M.Schwarzmann, EfficientIO
//Date : 08.06.2022
//Version : 1.0.0.1

//With this function we can commiunicate over mqtt with the TSG-Protect cloud instance (by EfficientIO) to write data from plc to the cloud or receive data from cloud and write to plc
//Max data from cloud to the plc is every 250MS 1 messege.
//Data from plc to cloud is every 50MS if messages are in the buffer from the interface
//So that the mqtt function starts, the scann function must be completed  

//Create Client ID
fbGetTime(START:= NOT bClientIDCreated,);
	FNGetTimeDate(CLK:= fbGetTime.BUSY, Q=> );

IF FNGetTimeDate.Q AND NOT fbGetTime.ERR THEN
	sClientID := CONCAT(CONCAT(WORD_TO_STRING(fbGetTime.TIMESTR.wYear),WORD_TO_STRING(fbGetTime.TIMESTR.wMonth)),CONCAT(CONCAT(WORD_TO_STRING(fbGetTime.TIMESTR.wDay),WORD_TO_STRING(fbGetTime.TIMESTR.wDayOfWeek)),CONCAT(CONCAT(WORD_TO_STRING(fbGetTime.TIMESTR.wHour),WORD_TO_STRING(fbGetTime.TIMESTR.wMinute)),
					CONCAT(CONCAT(WORD_TO_STRING(fbGetTime.TIMESTR.wSecond),WORD_TO_STRING(fbGetTime.TIMESTR.wMilliseconds)),TwinCAT_SystemInfoVarList._AppInfo.ProjectName))));
		bClientIDCreated := TRUE;
END_IF		

IF bSetParameter AND bClientIDCreated THEN
    bSetParameter               := FALSE;
	fbMqttClient.sClientId		:= sClientID;
    fbMqttClient.sHostName      := 'mqtt.tsg-portal.de';
    fbMqttClient.nHostPort      := 8883;
  	fbMqttClient.sTopicPrefix   := ''; 
	fbMqttClient.nKeepAlive     := 30; 
	fbMqttClient.sUserName      := sUserName;
	fbMqttClient.sUserPassword  := sUserPassword; 
	//TLS
	IF eSavePositionCertificate = eSavePositionOnPLC.ePostionHardDisk THEN 
		fbMqttClient.stTLS.sCA      := 'Hard Disk\TwinCAT\3.1\Config\Certificates\mqtt_tsg.pem';
	ELSIF eSavePositionCertificate = eSavePositionOnPLC.ePostionC THEN
		fbMqttClient.stTLS.sCA      := 'C:\TwinCAT\3.1\Config\Certificates\mqtt_tsg.pem';		
	END_IF
	fbMqttClient.stTLS.sVersion	:= 'tlsv1.2';
    fbMqttClient.ipMessageQueue := fbMessageQueue;
END_IF

//Config timer pub
fbTimerPub.PT := T#25MS;

//Change Inputs and disconnect connection
IF sUserName <> sUserNameOld OR sUserPassword <> sUserPasswordOld OR eSavePositionCertificate <> eSavePositionCertificateOld THEN 
	bConnect := FALSE; bSetParameter := TRUE; sUserNameOld := sUserName; sUserPasswordOld := sUserPassword; 
		eSavePositionCertificateOld := eSavePositionCertificate;	
END_IF 

//Subscribe and Unsubscribe befor remove client connection
IF NOT bConnect OR Lynus_Standards.GVL_Communicator.bBusyInfoAlVariables OR Lynus_Standards.GVL_Communicator.bErrorInfoAlVariables OR NOT Lynus_Standards.GVL_Communicator.bInfoAlVariablesOK THEN
	IF NOT bUnsubscribe THEN
		bUnsubscribe := fbMqttClient.Unsubscribe(sTopic:= sTopicSub);
	END_IF
		fbMqttClient.Execute(FALSE);
			bSubscribed := FALSE;
				//Stop ADS read/write when the connection to the broker is off and clear the received buffer
				FOR byLPSendInterface := 1 TO 10 BY 1 DO 
					Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPSendInterface].bBusy := FALSE;
						Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPSendInterface].bErrorSending := TRUE;
							arrBusySendigInterface[byLPSendInterface] := FALSE;
				END_FOR
					fbTimerPub(IN:= FALSE); bReadOut := FALSE; 	bBusyWrite := FALSE; bErrorWrite := FALSE;
						sPayloadRcv := ''; uiStatePublish := 0;
							fbMessageQueue.ResetQueue();										
ELSE
	IF NOT bSetParameter AND NOT Lynus_Standards.GVL_Communicator.bBusyInfoAlVariables AND NOT Lynus_Standards.GVL_Communicator.bErrorInfoAlVariables AND Lynus_Standards.GVL_Communicator.bInfoAlVariablesOK THEN
		bUnsubscribe := FALSE;
			fbMqttClient.Execute(TRUE);
				//Start ADS read/write when the connection to the broker is on and no error
				IF NOT fbMqttClient.bError AND fbMqttClient.bConnected THEN 
					FOR byLPSendInterface := 1 TO 10 BY 1 DO 
						Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPSendInterface].bErrorSending := FALSE;
					END_FOR
				ELSE 
					//Stop read/write and clear the received buffer from old messages
					FOR byLPSendInterface := 1 TO 10 BY 1 DO 
						Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPSendInterface].bErrorSending := TRUE;
							arrBusySendigInterface[byLPSendInterface] := FALSE;
					END_FOR
						bReadOut := FALSE; bBusyWrite := FALSE; bErrorWrite := FALSE;
							sPayloadRcv := ''; uiStatePublish := 0;
								fbMessageQueue.ResetQueue();
				END_IF		
	END_IF	
END_IF

(*----------------------------------------------------------------------------------Send Messeges---------------------------------------------------------------*)

//Prepare Json Doc for sending
IF bConnected AND NOT bError AND NOT bHBSending THEN fbTimerHB.IN := TRUE; ELSE fbTimerHB.IN := FALSE; END_IF
	fbTimerHB(IN:= , PT:= T#15S, Q=> , ET=> );

IF Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction >= 1 AND Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction <= 10 THEN	
	FOR byLPJsonSend := 1 TO Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction BY 1 DO 	
		fbJsonWrite.stInfoToConvertInMessage[byLPJsonSend].sFullSymbolName := Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].sFullSymbolName;
			fbJsonWrite.stInfoToConvertInMessage[byLPJsonSend].sSymbolUnit := Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].sSymbolUnit; 
				fbJsonWrite.stInfoToConvertInMessage[byLPJsonSend].sSymbolType := Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].sSymbolType;
					fbJsonWrite.stInfoToConvertInMessage[byLPJsonSend].arrValue := Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].arrValue; 	
	END_FOR 	
END_IF

//Heart Beat			
IF (fbTimerHB.Q AND uiStatePublish = 0) OR bHBSending THEN
	fbJsonWrite.stInfoToConvertInMessage[1].sFullSymbolName := '';
		fbJsonWrite.stInfoToConvertInMessage[1].sSymbolUnit := ''; 
			fbJsonWrite.stInfoToConvertInMessage[1].sSymbolType := 'STRING(30)';
				fbJsonWrite.stInfoToConvertInMessage[1].arrValue[1] := 'hb';
					bHBSending := TRUE;
	FOR byLPJsonSend := 2 TO 10 BY 1 DO
		fbJsonWrite.stInfoToConvertInMessage[byLPJsonSend].sFullSymbolName := '';
			fbJsonWrite.stInfoToConvertInMessage[byLPJsonSend].sSymbolUnit := ''; 
				fbJsonWrite.stInfoToConvertInMessage[byLPJsonSend].sSymbolType := '';
					fbJsonWrite.stInfoToConvertInMessage[byLPJsonSend].arrValue[1] := '';
	END_FOR
END_IF  			

IF uiStatePublish = 0 THEN fbJsonWrite.bEnable := TRUE; END_IF
			
fbJsonWrite(stInfoToConvertInMessage:= , sMessageDocToWrite=> sPayloadPub, eErrorMessage_Out => ,);

//Publish
IF fbMqttClient.bConnected AND NOT bSetParameter THEN
    IF NOT bSubscribed THEN
        bSubscribed := fbMqttClient.Subscribe(sTopic:= sTopicSub, eQoS:=TcIotMqttQos.AtMostOnceDelivery);
    END_IF
 END_IF

//Topics
sTopicPub := CONCAT(CONCAT('projects/',sUserName),'/messages');
	sTopicSub := CONCAT(CONCAT('projects/',sUserName),'/messages2'); 
 
CASE uiStatePublish OF
	
	0://Wait to publish
		IF NOT bHBSending THEN
			IF Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction >= 1 AND Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction <= 10 THEN
				FOR byLPJsonSend := 1 TO Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction BY 1 DO
					IF Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].bBusy AND fbJsonWrite.bDone THEN 
						uiStatePublish := 1; 
							arrBusySendigInterface[byLPJsonSend] := TRUE;
								fbJsonWrite.bEnable := FALSE;
					END_IF
				END_FOR
			END_IF
		END_IF
			IF bHBSending AND fbJsonWrite.bDone THEN uiStatePublish := 2; fbJsonWrite.bEnable := FALSE; END_IF
			
	1://Publish the message
		fbTimerPub(IN := TRUE);
			IF fbTimerPub.Q THEN // publish new payload every 25MS if messages are in the buffer after ads read
				fbTimerPub(IN := FALSE);
					IF Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction >= 1 AND Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction <= 10 THEN
						FOR byLPJsonSend := 1 TO Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction BY 1 DO
							//Mark the sendet variables on interfaces as done
							IF arrBusySendigInterface[byLPJsonSend] THEN 
								Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].bBusy := FALSE; 
									arrBusySendigInterface[byLPJsonSend] := FALSE; 
										Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].sSymbolType := '';	
							END_IF
						END_FOR
					END_IF
						IF NOT fbJsonWrite.bError THEN 
							fbMqttClient.Publish(sTopic:= sTopicPub, 
													pPayload:= ADR(sPayloadPub), nPayloadSize:= LEN2(ADR(sPayloadPub)), 
													eQoS:= TcIotMqttQos.AtMostOnceDelivery, bRetain:= FALSE, bQueue:= FALSE);	
						END_IF
													uiStatePublish := 0;
			END_IF	
		
	2://Publish the HB Message
		IF NOT fbJsonWrite.bError THEN
			fbMqttClient.Publish(sTopic:= sTopicPub, 
									pPayload:= ADR(sPayloadPub), nPayloadSize:= LEN2(ADR(sPayloadPub)), 
									eQoS:= TcIotMqttQos.AtMostOnceDelivery, bRetain:= FALSE, bQueue:= FALSE);
		END_IF
								
			bHBSending := FALSE;					
				uiStatePublish := 0;

END_CASE

//Reset the Sending Interface after it is to long time busy to enable it for a new Messages from the Buffer
FOR byLPJsonSend := 1 TO 10 BY 1 DO
	IF Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].bBusy THEN arrTimoutSendinigInterface[byLPJsonSend].IN := TRUE; ELSE arrTimoutSendinigInterface[byLPJsonSend].IN := FALSE; END_IF
		IF arrTimoutSendinigInterface[byLPJsonSend].Q THEN 
			Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].bBusy := FALSE;
				arrBusySendigInterface[byLPJsonSend] := FALSE;
					Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueSendTo[byLPJsonSend].sSymbolType := '';	
		END_IF    
END_FOR

arrTimoutSendinigInterface[1](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[2](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[3](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[4](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[5](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[6](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[7](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[8](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[9](IN:= , PT:= T#15S, Q=> , ET=> );
arrTimoutSendinigInterface[10](IN:= , PT:= T#15S, Q=> , ET=> );

(*----------------------------------------------------------------------------------Received Messeges---------------------------------------------------------------*)

byCounterBusyErrorWrite := 0;

//Busy write interface
IF Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction >= 1 AND Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction <= 10 THEN 
	FOR byLPWriteInterface := 1 TO Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction BY 1 DO 
		IF Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[byLPWriteInterface].bBusy THEN bBusyWrite := TRUE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[byLPWriteInterface].bBusy THEN byCounterBusyErrorWrite := byCounterBusyErrorWrite + 1; END_IF  
	END_FOR 
END_IF
	IF byCounterBusyErrorWrite >= Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction THEN bBusyWrite := FALSE; END_IF

byCounterBusyErrorWrite := 0;

//Error on a write interface
IF Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction >= 1 AND Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction <= 10 THEN 
	FOR byLPWriteInterface := 1 TO Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction BY 1 DO 
		IF Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[byLPWriteInterface].bErrorWrite THEN bErrorWrite := TRUE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[byLPWriteInterface].bErrorWrite THEN byCounterBusyErrorWrite := byCounterBusyErrorWrite + 1; END_IF  
	END_FOR 
END_IF
	IF byCounterBusyErrorWrite >= Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction THEN bErrorWrite := FALSE; END_IF 
	 
IF fbMqttClient.bConnected AND NOT fbMqttClient.bError AND NOT bBusyWrite AND NOT bErrorWrite THEN bReadOut := TRUE; ELSE bReadOut := FALSE; END_IF  

IF (fbMessageQueue.nQueuedMessages > 0 AND bReadOut) OR
	(fbMessageQueue.nQueuedMessages > 0 AND bReadOut AND (fbJsonRead.bError)) THEN
		IF fbMessageQueue.Dequeue(fbMessage:=fbMessage) THEN
			IF fbMessage.CompareTopic(sTopicSub) THEN
				fbMessage.GetPayload(pPayload:=ADR(sPayloadRcv), nPayloadSize:=SIZEOF(sPayloadRcv), bSetNullTermination:= TRUE);
			END_IF
		END_IF
END_IF

//Copy only as much data as you have to save resources
IF Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction >= 1 AND Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction <= 10 THEN
	FOR byLPCopyValuesGV_1 := 1 TO Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction BY 1 DO
		IF Lynus_Standards.GVL_Communicator.arrCounterVariableInArray[byLPCopyValuesGV_1] >= 1 AND Lynus_Standards.GVL_Communicator.arrCounterVariableInArray[byLPCopyValuesGV_1] <= Lynus_Standards.Constants_Communicator.udiArraySizeMarkedSymobls THEN
			FOR udiLPCopyValuesGV_2 := 1 TO Lynus_Standards.GVL_Communicator.arrCounterVariableInArray[byLPCopyValuesGV_1] BY 1 DO  			
				fbJsonRead.arrVarInfos[byLPCopyValuesGV_1,udiLPCopyValuesGV_2] := Lynus_Standards.GVL_Communicator.arrInterfaceInfoAlVariables[byLPCopyValuesGV_1,udiLPCopyValuesGV_2];	
			END_FOR
		END_IF 
	END_FOR
END_IF    

fbJsonRead(
	sReceivedMessageDoc:= sPayloadRcv, 
	arrVarInfos:= , 
	stInfoFromReceivedMessage=> , 
	bError=> , 
	bMuchMoreInformationReceived=> , 
	eErrorMessage_Out=> );

IF NOT fbJsonRead.bError AND bReadOut AND fbJsonRead.stInfoFromReceivedMessage.sSymbolType <> '' THEN
	sPayloadRcv := '';
		Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[fbJsonRead.stInfoFromReceivedMessage.byReadWriteArrayNumber].bWriteNewValue := TRUE;
			Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[fbJsonRead.stInfoFromReceivedMessage.byReadWriteArrayNumber].sFullSymbolName := fbJsonRead.stInfoFromReceivedMessage.sFullSymbolName;
				Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[fbJsonRead.stInfoFromReceivedMessage.byReadWriteArrayNumber].sSymbolType := fbJsonRead.stInfoFromReceivedMessage.sSymbolType;
					Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[fbJsonRead.stInfoFromReceivedMessage.byReadWriteArrayNumber].arrValue := fbJsonRead.stInfoFromReceivedMessage.arrValue;	
						Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[fbJsonRead.stInfoFromReceivedMessage.byReadWriteArrayNumber].uiSizeArray := fbJsonRead.stInfoFromReceivedMessage.uiSizeArray;
END_IF
	IF fbJsonRead.bError THEN sPayloadRcv := ''; END_IF
	
//Data to ADS Write
IF Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction >= 1 AND Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction <= 10 THEN
	FOR byLPWriteInterface := 1 TO Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction BY 1 DO 
		Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[byLPWriteInterface].udiCountBuffer := fbMessageQueue.nQueuedMessages; 
	END_FOR
ELSE
	FOR byLPWriteInterface := 1 TO 10 BY 1 DO 
		Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[byLPWriteInterface].udiCountBuffer := 0; 
	END_FOR
END_IF

//Outputs
bConnected := fbMqttClient.bConnected;
	hrErrorCode := fbMqttClient.hrErrorCode;
		eConnectionState := fbMqttClient.eConnectionState;

//Data to send the connected Flag to the GVL to enable all other Lynus Devices on PLC
Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := bConnected;	

IF Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction >= 1 AND Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction <= 10 THEN
	FOR byLPWriteInterface := 1 TO Lynus_Standards.GVL_Communicator.byNumberOfReadWriteFunction BY 1 DO 
		Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[byLPWriteInterface].bSendFunctionOK := bConnected; 
	END_FOR
ELSE
	FOR byLPWriteInterface := 1 TO 10 BY 1 DO 
		Lynus_Standards.GVL_Communicator.arrInterfaceInfoValueWriteTo[byLPWriteInterface].bSendFunctionOK := FALSE;
	END_FOR
END_IF		
		
IF fbMqttClient.bError OR fbJsonRead.bError OR fbGetTime.ERR THEN bError := TRUE; ELSE bError := FALSE; END_IF	

IF fbJsonRead.bError THEN eErrorMessage_Out := fbJsonRead.eErrorMessage_Out; END_IF
IF fbJsonWrite.bError THEN eErrorMessage_Out := fbJsonWrite.eErrorMessage_Out; END_IF

IF NOT fbJsonRead.bError AND NOT fbJsonWrite.bError THEN eErrorMessage_Out := eErrorMessage.eNoError; END_IF  

//Clear receive buffer, if the json string has the error too long
timError(IN:= fbJsonRead.bError AND NOT timError.Q, PT:= T#30S, Q=> , ET=> );
	
IF timError.Q THEN 
	sPayloadRcv := '';
		bReadOut := FALSE;
			fbMessageQueue.ResetQueue();
END_IF	]]></ST>
    </Implementation>
    <LineIds Name="FB_MqttCommunicator">
      <LineId Id="3" Count="1" />
      <LineId Id="368" Count="0" />
      <LineId Id="5" Count="306" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>