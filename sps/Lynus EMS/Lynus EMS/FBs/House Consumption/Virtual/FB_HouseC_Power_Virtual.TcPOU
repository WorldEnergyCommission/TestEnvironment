<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_HouseC_Power_Virtual" Id="{c61eb3c6-6e11-427f-9f1c-ba33406bb2bf}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_HouseC_Power_Virtual
VAR_INPUT PERSISTENT
	bEnable									: BOOL;													//{#lynus.ag#()} //Enable the Fuctionblock and his logic
	diNrOfEMS_IN							: DINT;													//Number of EMS from what this Device received Data
END_VAR
VAR_INPUT
	bSetDefault								: BOOL;													//With this Input can set the default Value from the Counter from the Input to the Counter at the Output									
	lrCounterConsumptionSetDefault			: LREAL;												//Set Default value for Consumption Counter
	lrCounterProductionSetDefault			: LREAL;												//Set Default value for Production Counter
END_VAR
VAR_OUTPUT
	stDataHouseC							: ST_HouseConsumption_Output;							//{#lynus.ag#()} //House consumption output data
	diNrOfHouseC_OUT						: DINT;													//Active Number from the House connection for using on other functions
END_VAR
VAR
	{attribute 'hide'}
	fbHouseC								: FB_HouseConsumption;									//Function for House consumption
	{attribute 'hide'}
	fbNumberDevice							: FB_NumberOfDevice;									//Function block to calcualte the number of the Device
	{attribute 'hide'}
	TaskIndex								: GETCURTASKINDEX;										//Function to read out the task index	
	{attribute 'hide'}
	timSaveCSProd							: TON;													//Timer to save the Counter Status from production on persistent data
	{attribute 'hide'}
	timSaveCSCons							: TON;													//Timer to save the Counter Status from Consumption on persistent data
	{attribute 'hide'}
	timDissableFunctions					: TON;													//Timer to dissable the Function after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days without connection to the Lynus Cloud
	{attribute 'hide'}
	timResetConnectionOnGVL					: TON;													//Timer to try reset the connection Flag on the GVL. (When somebody delete the Connection Function and make only a onlinechange)
	{attribute 'hide'}
	FPSetDefault							: R_TRIG;												//Internal positive Edge
	{attribute 'hide'}
	arrPD									: ARRAY[1..4] OF FB_PersistentData_Number;				//Function to save persistent data 
	{attribute 'hide'}
	bError									: BOOL;													//Error from external Devices
	{attribute 'hide'}
	byWaitInStep							: BYTE;													//Wait in Step before start to clean data on PLC
	{attribute 'hide'}
	iStateGVLData							: INT;													//State machine to handle the data on the GVL
	{attribute 'hide'}
	diCounterForGVL							: DINT;													//Counter to clean old data on GVL
	{attribute 'hide'}
	udicycleTime							: UDINT;												//Cycletime of plc
	{attribute 'hide'}
	lrPowerProduction						: LREAL;												//Complete Power Production from al Devices of this EMS in kW 
	{attribute 'hide'}
	lrPowerBattery							: LREAL;												//Complete Battery Power from al Batterys of this EMS in kW 
	{attribute 'hide'}
	lrPowerGrid								: LREAL;												//Complete Grid Power from al Grids of this EMS in kW 
	{attribute 'hide'}
	lrCounterConsumption_CP					: LREAL;												//Counter Status Consumption with Unit kW/h to compare for save persistent
	{attribute 'hide'}
	lrCounterProduction_CP					: LREAL;												//Counter Status Production with Unit kW/h to compare for save persistent
	{attribute 'hide'}
	lrTotalPower							: LREAL;												//Total power with unit kW
	{attribute 'hide'}
	lrTotalPower_CP							: LREAL;												//Total power with unit kW to trigger the calculation for energy
	{attribute 'hide'}
	lrCyclesForMinute						: LREAL;												//Cycles what the plc need for 1 minute 
	{attribute 'hide'}
	lrPastTime								: LREAL;												//Past time in hours 
	{attribute 'hide'}
	lrSumToCalculate						: LREAL;												//Actual sum of the energy counters before start the calculation with unit kW/h
	{attribute 'hide'}
	liLPPower								: LINT;													//Loop to calculate the total power
END_VAR
VAR PERSISTENT
	{attribute 'conditionalshow'}
	lrCounterConsumption					: LREAL;												//Counter Status Consumption with Unit kW/h
	{attribute 'conditionalshow'}
	lrCounterProduction						: LREAL;												//Counter Status Production with Unit kW/h
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Kai Ebensperger
//Company : Lynus AG
//Date : 15.06.2021
//Version : 1.0.0.0

//With this function block its possible to show the power data from a house.
//The power data in this function block is calculated by all the other consumers and producers. So the output data is not messured.
//Use only one of this Function block per each EMS
//NOTE : The output from this Function Block is not 100% perfect why the value is only calculatet and not messured.

//NOTE for diNr.....Designation => 
//_IN = Here Data come in from other Functions or go out to other functions about the GVL
//_OUT = Here Data go out to other functions about the GVL

(*------------------------------------------------------------Limits----------------------------------------------------------------------------------*)

diNrOfEMS_IN := LIMIT(0,diNrOfEMS_IN,Constants_Energy.diMaxNumberOfEMS);

(*-------------------------------------------------------------Calcualte the number of House Consumption---------------------------------------------------------------*)

fbNumberDevice(
	diActualNumberOfDevices:= Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfHouseConsumption, 
	diMaxNumberOfDevices:= Constants_Energy.diMaxNumberOfHouseConsumptions, 
	udiCounterOnlineChange:= TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, 
	bNumberIsCalculatet=> , 
	bFPNumberIsCalculatet=> , 
	bOnlineChange=> , 
	diNumberForThisDevice=> diNrOfHouseC_OUT, 
	diNumberOfTotalDevices=> );

//Write new Numer on GVL
IF fbNumberDevice.bFPNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfHouseConsumption := fbNumberDevice.diNumberOfTotalDevices;	
END_IF 

//Delete old Number on GVL
IF fbNumberDevice.bOnlineChange THEN 
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfHouseConsumption := diNrOfHouseC_OUT;	
		iStateGVLData := 1; 
END_IF

(*-------------------------------------------------------------Calcualte the power of the house---------------------------------------------------------------*)	

lrPowerProduction := 0;
	lrPowerBattery := 0;
		lrPowerGrid := 0;
			bError := FALSE;

//Batterypower
FOR liLPPower := 1 TO Constants_Energy.diMaxNumberOfBatterys BY 1 DO
	lrPowerBattery := lrPowerBattery + Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_IN,liLPPower].lrPower;	
		IF Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_IN,liLPPower].byErrorWarning = 2 THEN bError := TRUE; END_IF 
END_FOR 
 	//Generator power
	FOR liLPPower := 1 TO Constants_Energy.diMaxNumberOfGenerators BY 1 DO
		lrPowerProduction := lrPowerProduction + Lynus_Standards.GVL_Energy.stDataOfGenerators[liLPPower].lrPowerProduction;	
			IF Lynus_Standards.GVL_Energy.stDataOfGenerators[liLPPower].byErrorWarning = 2 THEN bError := TRUE; END_IF		
	END_FOR 
		//PV power
		FOR liLPPower := 1 TO Constants_Energy.diMaxNumberOfPvSystems BY 1 DO
			lrPowerProduction := lrPowerProduction + Lynus_Standards.GVL_Energy.stDataOfPvSystems[liLPPower].lrPowerProduction;	
				IF Lynus_Standards.GVL_Energy.stDataOfPvSystems[liLPPower].byErrorWarning = 2 THEN bError := TRUE; END_IF		
		END_FOR	
			//Grid power	
			FOR liLPPower := 1 TO Constants_Energy.diMaxNumberOfGridConnections BY 1 DO
				lrPowerGrid := lrPowerGrid + Lynus_Standards.GVL_Energy.stDataGridConnections[diNrOfEMS_IN,liLPPower].lrPower;	
					IF Lynus_Standards.GVL_Energy.stDataGridConnections[diNrOfEMS_IN,liLPPower].byErrorWarning = 2 THEN bError := TRUE; END_IF 
			END_FOR 

//Complete power
lrTotalPower := lrPowerProduction + lrPowerGrid + lrPowerBattery;
	lrTotalPower := LIMIT(0,lrTotalPower,100000);							

(*-------------------------------------------------------------Calcualte the energy of the house---------------------------------------------------------------*)
							
//Read out the Taskindex
TaskIndex(index=> );							

//Set default Value
FPSetDefault(CLK:= bSetDefault, Q=> );
	IF FPSetDefault.Q THEN 
		lrCounterConsumption_CP := lrCounterConsumptionSetDefault;
			lrCounterProduction_CP := lrCounterProductionSetDefault;
	END_IF
						
//Save the persistent counter status to the counter status for compare on the first plc cycle	
IF TwinCAT_SystemInfoVarList._TaskInfo[TaskIndex.index].FirstCycle THEN 
	lrCounterConsumption_CP := lrCounterConsumption;
		lrCounterProduction_CP := lrCounterProduction;
END_IF											

//Timer to save the Energy Counters persistent every 12 hours											
timSaveCSProd(IN:= lrCounterProduction <> lrCounterProduction_CP, PT:= T#12H, Q=> , ET=> );
	timSaveCSCons(IN:= lrCounterConsumption <> lrCounterConsumption_CP, PT:= T#12H, Q=> , ET=> );

IF timSaveCSProd.Q THEN lrCounterProduction := lrCounterProduction_CP; END_IF 
	IF timSaveCSCons.Q THEN lrCounterConsumption := lrCounterConsumption_CP; END_IF  
	
//Write Data when the Event Based saving on persitent Data is not active
IF NOT arrPD[3].bEventBasedActive AND NOT arrPD[4].bEventBasedActive THEN
	lrCounterProduction := lrCounterProduction_CP;
		lrCounterConsumption := lrCounterConsumption_CP;
END_IF   
			
//Read out the cycle time to calculate the energy counters
//Cycle Time in MS
udicycleTime := TwinCAT_SystemInfoVarList._TaskInfo[TaskIndex.index].CycleTime / 10000;

//Calculate the cycles what is needed for 1 Minute
lrCyclesForMinute := UDINT_TO_LREAL((1 * udicycleTime)) / 60000;	

//Calculate past time in hours
lrPastTime := lrPastTime + (lrCyclesForMinute / 60);

//Calculate the Energy when the power data change and start then from new
IF MEMCMP(ADR(lrTotalPower),ADR(lrTotalPower_CP),SIZEOF(lrTotalPower_CP)) <> 0 THEN
	//INFO : Negative Value at the moment is not in use about the limitation of the Total power
	IF lrSumToCalculate < 0 THEN
		lrCounterProduction_CP := lrCounterProduction_CP + (lrSumToCalculate * - 1);
	ELSE
		lrCounterConsumption_CP := lrCounterConsumption_CP + lrSumToCalculate;
	END_IF
		lrSumToCalculate := 0;
			lrPastTime := 0;
				lrTotalPower_CP := lrTotalPower;
END_IF

//Calculate the sum after the calculation why we must calculate after the power change
lrSumToCalculate := lrTotalPower * lrPastTime;

(*-------------------------------------------------------------Service from Backend is ready and check the connection to backen for dissabel/enable Function---------------------------------------------------------------*)

//Try to reset the variable for connection on the GVL. When all is normal then the Lynus Mqtt connection function set this variable to true in the next cycle
//When we have no connection to the backend then after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions days the Function is dissabled with all of his functionalities
timResetConnectionOnGVL(IN:= NOT timResetConnectionOnGVL.Q, PT:= T#1H, Q=> , ET=> );
	IF timResetConnectionOnGVL.Q THEN Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := FALSE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions THEN timDissableFunctions.IN := TRUE; ELSE timDissableFunctions.IN := FALSE; END_IF  
			timDissableFunctions(IN:= , PT:= Lynus_Standards.Constants_General.tTimeDissableLynusFunctions, Q=> , ET=> );

(*-----------------------------------------------------------------------------Error ----------------------------------------------------------------------------*)

IF timDissableFunctions.Q THEN fbHouseC.bWarning := TRUE; fbHouseC.iWarningCode := 0; ELSE fbHouseC.bWarning := FALSE; END_IF 	
	IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfHouseConsumption > Constants_Energy.diMaxNumberOfHouseConsumptions OR bError THEN fbHouseC.bError := TRUE; ELSE fbHouseC.bError := FALSE; END_IF 
		IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfHouseConsumption > Constants_Energy.diMaxNumberOfHouseConsumptions THEN fbHouseC.iErrorCode := 1;
		ELSIF bError THEN fbHouseC.iErrorCode := 0; 
		END_IF  

(*------------------------------------------------------------------FB House----------------------------------------------------------------------------*)	
	
fbHouseC(
	bEnable:= bEnable AND NOT timDissableFunctions.Q,
	bError:= , 
	bWriteWithDelay:= TRUE, 
	iErrorCode:= , 
	iWarningCode:= , 
	lrTotalCounterEnergy_Consumption:= lrCounterConsumption_CP * 1000, 
	lrTotalCounterEnergy_Production:= lrCounterProduction_CP * 1000, 
	lrCounterEnergyT1_Consumption:= lrCounterConsumption_CP * 1000, 
	lrCounterEnergyT2_Consumption:= , 
	lrCounterEnergyT1_Production:= lrCounterProduction_CP * 1000, 
	lrCounterEnergyT2_Production:= , 
	lrPowerHouseConsumption:= lrTotalPower * 1000, 
	tTimDelayOutput:= T#5S, 
	stDataHouseCOut=> , 
	stDataHouseCOutDelay=> stDataHouseC);
	
	(*-----------------------------------------------------------Handle data to Global structure for the House consumption-----------------------------------------------------------------*)

CASE iStateGVLData OF
	
	0://Init Step
		byWaitInStep := 0;
			diCounterForGVL := 1;
	
	1://Wait for 4 Steps before clean al Data on GVL
		byWaitInStep := byWaitInStep + 1;
			IF byWaitInStep >= 4 AND fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 2; END_IF
				//To much Devices, back to the Init step
				IF byWaitInStep >= 4 AND NOT fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 0; END_IF	
			
	2://Clear all Data in GVL
		Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diCounterForGVL].bEnabled := FALSE;
			Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diCounterForGVL].byErrorWarning := 0;
				Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diCounterForGVL].lrPowerConsumption := 0;
					Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diCounterForGVL].lrPower := 0;
						Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diCounterForGVL].lrPowerProduction := 0;
		
		diCounterForGVL := diCounterForGVL + 1;
			diCounterForGVL := LIMIT(0,diCounterForGVL,Constants_Energy.diMaxNumberOfHouseConsumptions);
				//Back to the init step
				IF diCounterForGVL >= Constants_Energy.diMaxNumberOfHouseConsumptions THEN iStateGVLData := 0; END_IF
				
END_CASE 	 

IF diNrOfHouseC_OUT > 0 AND fbNumberDevice.bNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diNrOfHouseC_OUT].bEnabled := fbHouseC.stDataHouseCOut.bEnabled;
		Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diNrOfHouseC_OUT].byErrorWarning := fbHouseC.stDataHouseCOut.byErrorWarning;
			Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diNrOfHouseC_OUT].lrPowerConsumption := fbHouseC.stDataHouseCOut.lrPowerConsumption;
				Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diNrOfHouseC_OUT].lrPower := fbHouseC.stDataHouseCOut.lrPower;
					Lynus_Standards.GVL_Energy.stDataHouseConsumptions[diNrOfHouseC_OUT].lrPowerProduction := fbHouseC.stDataHouseCOut.lrPowerProduction;
END_IF 	

(*----------------------------------------------------------Save persistent data----------------------------------------------------------------*)

arrPD[1](lrValue:= BOOL_TO_LREAL(bEnable), bEventBasedActive=> );
arrPD[2](lrValue:= DINT_TO_LREAL(diNrOfEMS_IN), bEventBasedActive=> );
arrPD[3](lrValue:= lrCounterConsumption, bEventBasedActive=> );
arrPD[4](lrValue:= lrCounterProduction, bEventBasedActive=> );
]]></ST>
    </Implementation>
    <LineIds Name="FB_HouseC_Power_Virtual">
      <LineId Id="3" Count="207" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>