<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_KL3403_SimpleProcessImage" Id="{20175cdd-af78-4456-9d97-7d937a8924a4}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'conditionalshow'}
FUNCTION_BLOCK FB_KL3403_SimpleProcessImage
VAR_INPUT
	{attribute 'hide'}
	uiKBusState_IN						: UINT;							//K-Bus State from the K-Bus Box on wich the Terminal is connected. (Connect with FB_K_Bus_state)
	{attribute 'hide'}
	uiCurrentTransformerRatioL1			: UINT;							//Current Transformer Ratio for Channel 1 (L1)
	{attribute 'hide'}
	uiCurrentTransformerRatioL2			: UINT;							//Current Transformer Ratio for Channel 2 (L2)
	{attribute 'hide'}
	uiCurrentTransformerRatioL3			: UINT;							//Current Transformer Ratio for Channel 3 (L3)
	{attribute 'hide'}
	rResolutionCurrent					: REAL := 0.001;				//Resolution for the Current
	{attribute 'hide'}
	rResolutionPower					: REAL := 0.1;					//Resolution for the Power
	{attribute 'hide'}
	rResolutionEnergy					: REAL := 0.01;					//Resolution for the Energy	
END_VAR
VAR_OUTPUT
	{attribute 'hide'}
	stDataL1							: ST_KL3403;					//Data from Channel 1 (L1)
	{attribute 'hide'}
	stDataL2							: ST_KL3403;					//Data from Channel 2 (L2)
	{attribute 'hide'}
	stDataL3							: ST_KL3403;					//Data from Channel 3 (L3)
END_VAR
VAR
	{attribute 'hide'}
	timActive							: TON;							//Timer to activate the Statemachine
	{attribute 'hide'}
	timTimeout							: TON;							//Timeout Timer for the State Machine
	{attribute 'hide'}
	arrDataOk							: ARRAY[1..3] OF BOOL;			//Array with the Information if the Data In deliver all Information from each channel
	{attribute 'hide'}
	bErrorTimeOut						: BOOL;							//timout Error
	{attribute 'hide'}
	iState								: INT;							//Variable for the Statemachine
	{attribute 'hide'}
	iState_CP							: INT;							//Variable for the Statemachine to compare
	byStateCH1		AT%I*				: BYTE;							//State Byte from Channel 1 (L1) 
	byCntrCH1		AT%Q*				: BYTE;							//Control Byte from Channel 1 (L1) 
	iDataInCH1		AT%I*				: INT;							//Input Data from Channel 1 (L1) 
	byStateCH2		AT%I*				: BYTE;							//State Byte from Channel 1 (L2) 
	byCntrCH2		AT%Q*				: BYTE;							//Control Byte from Channel 1 (L2) 
	iDataInCH2		AT%I*				: INT;							//Input Data from Channel 1 (L2) 
	byStateCH3		AT%I*				: BYTE;							//State Byte from Channel 1 (L3) 
	byCntrCH3		AT%Q*				: BYTE;							//Control Byte from Channel 1 (L3) 
	iDataInCH3		AT%I*				: INT;							//Input Data from Channel 1 (L3) 
END_VAR		
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Kai Ebensperger
//Company : Lynus AG
//Date : 04.10.2021
//Version : 1.0.0.0

//With this function is possible to read out all Information from a KL3403
//This Function support only the Simple Process Image and the Ratio in the Terminal register must be Set allways to 1.

(*--------------------------------------------------------------------Limits------------------------------------------------------------------------------*)

uiCurrentTransformerRatioL1 := LIMIT(0,uiCurrentTransformerRatioL1,3000);
	uiCurrentTransformerRatioL2 := LIMIT(0,uiCurrentTransformerRatioL2,3000);
		uiCurrentTransformerRatioL3 := LIMIT(0,uiCurrentTransformerRatioL3,3000);
rResolutionCurrent := LIMIT(0,rResolutionCurrent,1);
	rResolutionPower := LIMIT(0,rResolutionPower,1);	
		rResolutionEnergy := LIMIT(0,rResolutionEnergy,1);

(*--------------------------------------------------------------------Errro-Warning------------------------------------------------------------------------------*)		

//Channel 1 (L1)
IF byStateCH1.6 OR NOT timActive.Q OR byStateCH1.7 OR bErrorTimeOut THEN stDataL1.byErrorWarning := 2; ELSE stDataL1.byErrorWarning := 0; END_IF
//Channel 2 (L2)
IF byStateCH2.6 OR NOT timActive.Q OR byStateCH2.7 OR bErrorTimeOut THEN stDataL2.byErrorWarning := 2; ELSE stDataL2.byErrorWarning := 0; END_IF
//Channel 3 (L3)
IF byStateCH3.6 OR NOT timActive.Q OR byStateCH3.7 OR bErrorTimeOut THEN stDataL3.byErrorWarning := 2; ELSE stDataL3.byErrorWarning := 0; END_IF

(*--------------------------------------------------------------------Activate Process data mode------------------------------------------------------------------------------*)		

byCntrCH1.7 := FALSE; byCntrCH1.6 := FALSE;
byCntrCH2.7 := FALSE; byCntrCH2.6 := FALSE;
byCntrCH3.7 := FALSE; byCntrCH3.6 := FALSE;
		
(*--------------------------------------------------------------------Logic part------------------------------------------------------------------------------*)

//Activate the Statemachine when the K-bus is ready
timActive(IN:= uiKBusState_IN = 0, PT:= T#500MS, Q=> , ET=> );
	IF timActive.Q AND iState = 0 THEN iState := 1; END_IF

//Timeout
IF iState > 0 AND iState = iState_CP THEN timTimeout.IN := TRUE; ELSE timTimeout.IN := FALSE; END_IF 
	timTimeout(IN:= , PT:= T#5S, Q=> , ET=> );
	
//State machine
CASE iState OF
	
	1://Set Control Byte for Current
		iState_CP := iState;
	
		//Bin 0000
		byCntrCH1.0 := FALSE; byCntrCH1.1 := FALSE; byCntrCH1.2 := FALSE; byCntrCH1.3 := FALSE;
		byCntrCH2.0 := FALSE; byCntrCH2.1 := FALSE; byCntrCH2.2 := FALSE; byCntrCH2.3 := FALSE;
		byCntrCH3.0 := FALSE; byCntrCH3.1 := FALSE; byCntrCH3.2 := FALSE; byCntrCH3.3 := FALSE;

		//Next Step
		iState := 2;
			
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
			
	2://Check Status byte for Current and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF NOT byStateCH1.0 AND NOT byStateCH1.1 AND NOT byStateCH1.2 AND NOT byStateCH1.3 THEN
  			stDataL1.rCurrent := INT_TO_REAL(iDataInCH1) * rResolutionCurrent * uiCurrentTransformerRatioL1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF NOT byStateCH2.0 AND NOT byStateCH2.1 AND NOT byStateCH2.2 AND NOT byStateCH2.3 THEN
  			stDataL2.rCurrent := INT_TO_REAL(iDataInCH2) * rResolutionCurrent * uiCurrentTransformerRatioL2;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF NOT byStateCH3.0 AND NOT byStateCH3.1 AND NOT byStateCH3.2 AND NOT byStateCH3.3 THEN
  			stDataL3.rCurrent := INT_TO_REAL(iDataInCH3) * rResolutionCurrent * uiCurrentTransformerRatioL3;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 0001
				byCntrCH1.0 := TRUE; byCntrCH1.1 := FALSE; byCntrCH1.2 := FALSE; byCntrCH1.3 := FALSE;
				byCntrCH2.0 := TRUE; byCntrCH2.1 := FALSE; byCntrCH2.2 := FALSE; byCntrCH2.3 := FALSE;
				byCntrCH3.0 := TRUE; byCntrCH3.1 := FALSE; byCntrCH3.2 := FALSE; byCntrCH3.3 := FALSE;	
					iState := 3; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
		
	3://Check Status byte for Voltage and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF byStateCH1.0 AND NOT byStateCH1.1 AND NOT byStateCH1.2 AND NOT byStateCH1.3 THEN
  			stDataL1.rVoltage := INT_TO_REAL(iDataInCH1) * 0.1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF byStateCH2.0 AND NOT byStateCH2.1 AND NOT byStateCH2.2 AND NOT byStateCH2.3 THEN
  			stDataL2.rVoltage := INT_TO_REAL(iDataInCH2) * 0.1;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF byStateCH3.0 AND NOT byStateCH3.1 AND NOT byStateCH3.2 AND NOT byStateCH3.3 THEN
  			stDataL3.rVoltage := INT_TO_REAL(iDataInCH3) * 0.1;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 0010
				byCntrCH1.0 := FALSE; byCntrCH1.1 := TRUE; byCntrCH1.2 := FALSE; byCntrCH1.3 := FALSE;
				byCntrCH2.0 := FALSE; byCntrCH2.1 := TRUE; byCntrCH2.2 := FALSE; byCntrCH2.3 := FALSE;
				byCntrCH3.0 := FALSE; byCntrCH3.1 := TRUE; byCntrCH3.2 := FALSE; byCntrCH3.3 := FALSE;	
					iState := 4; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF		
	
	4://Check Status byte for Power and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF NOT byStateCH1.0 AND byStateCH1.1 AND NOT byStateCH1.2 AND NOT byStateCH1.3 THEN
  			stDataL1.rPower := INT_TO_REAL(iDataInCH1) * rResolutionPower * uiCurrentTransformerRatioL1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF NOT byStateCH2.0 AND byStateCH2.1 AND NOT byStateCH2.2 AND NOT byStateCH2.3 THEN
  			stDataL2.rPower := INT_TO_REAL(iDataInCH2) * rResolutionPower * uiCurrentTransformerRatioL2;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF NOT byStateCH3.0 AND byStateCH3.1 AND NOT byStateCH3.2 AND NOT byStateCH3.3 THEN
  			stDataL3.rPower := INT_TO_REAL(iDataInCH3) * rResolutionPower * uiCurrentTransformerRatioL3;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 0011
				byCntrCH1.0 := TRUE; byCntrCH1.1 := TRUE; byCntrCH1.2 := FALSE; byCntrCH1.3 := FALSE;
				byCntrCH2.0 := TRUE; byCntrCH2.1 := TRUE; byCntrCH2.2 := FALSE; byCntrCH2.3 := FALSE;
				byCntrCH3.0 := TRUE; byCntrCH3.1 := TRUE; byCntrCH3.2 := FALSE; byCntrCH3.3 := FALSE;	
					iState := 5; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
	
	5://Check Status byte for Power factor and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF byStateCH1.0 AND byStateCH1.1 AND NOT byStateCH1.2 AND NOT byStateCH1.3 THEN
  			stDataL1.rPowerfactor := INT_TO_REAL(iDataInCH1) * 0.01;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF byStateCH2.0 AND byStateCH2.1 AND NOT byStateCH2.2 AND NOT byStateCH2.3 THEN
  			stDataL2.rPowerfactor := INT_TO_REAL(iDataInCH2) * 0.01;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF byStateCH3.0 AND byStateCH3.1 AND NOT byStateCH3.2 AND NOT byStateCH3.3 THEN
  			stDataL3.rPowerfactor := INT_TO_REAL(iDataInCH3) * 0.01;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 0100
				byCntrCH1.0 := FALSE; byCntrCH1.1 := FALSE; byCntrCH1.2 := TRUE; byCntrCH1.3 := FALSE;
				byCntrCH2.0 := FALSE; byCntrCH2.1 := FALSE; byCntrCH2.2 := TRUE; byCntrCH2.3 := FALSE;
				byCntrCH3.0 := FALSE; byCntrCH3.1 := FALSE; byCntrCH3.2 := TRUE; byCntrCH3.3 := FALSE;	
					iState := 6; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF		
		
	6://Check Status byte for Energy and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF NOT byStateCH1.0 AND NOT byStateCH1.1 AND byStateCH1.2 AND NOT byStateCH1.3 THEN
  			stDataL1.rEnergy := INT_TO_REAL(iDataInCH1) * rResolutionEnergy * uiCurrentTransformerRatioL1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF NOT byStateCH2.0 AND NOT byStateCH2.1 AND byStateCH2.2 AND NOT byStateCH2.3 THEN
  			stDataL2.rEnergy := INT_TO_REAL(iDataInCH2) * rResolutionEnergy * uiCurrentTransformerRatioL2;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF NOT byStateCH3.0 AND NOT byStateCH3.1 AND byStateCH3.2 AND NOT byStateCH3.3 THEN
  			stDataL3.rEnergy := INT_TO_REAL(iDataInCH3) * rResolutionEnergy * uiCurrentTransformerRatioL3;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 0101
				byCntrCH1.0 := TRUE; byCntrCH1.1 := FALSE; byCntrCH1.2 := TRUE; byCntrCH1.3 := FALSE;
				byCntrCH2.0 := TRUE; byCntrCH2.1 := FALSE; byCntrCH2.2 := TRUE; byCntrCH2.3 := FALSE;
				byCntrCH3.0 := TRUE; byCntrCH3.1 := FALSE; byCntrCH3.2 := TRUE; byCntrCH3.3 := FALSE;	
					iState := 7; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
	
	7://Check Status byte for Peak Value current and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF byStateCH1.0 AND NOT byStateCH1.1 AND byStateCH1.2 AND NOT byStateCH1.3 THEN
  			stDataL1.rPeakValueCurrent := INT_TO_REAL(iDataInCH1) * rResolutionCurrent * uiCurrentTransformerRatioL1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF byStateCH2.0 AND NOT byStateCH2.1 AND byStateCH2.2 AND NOT byStateCH2.3 THEN
  			stDataL2.rPeakValueCurrent := INT_TO_REAL(iDataInCH2) * rResolutionCurrent * uiCurrentTransformerRatioL2;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF byStateCH3.0 AND NOT byStateCH3.1 AND byStateCH3.2 AND NOT byStateCH3.3 THEN
  			stDataL3.rPeakValueCurrent := INT_TO_REAL(iDataInCH3) * rResolutionCurrent * uiCurrentTransformerRatioL3;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 0110
				byCntrCH1.0 := FALSE; byCntrCH1.1 := TRUE; byCntrCH1.2 := TRUE; byCntrCH1.3 := FALSE;
				byCntrCH2.0 := FALSE; byCntrCH2.1 := TRUE; byCntrCH2.2 := TRUE; byCntrCH2.3 := FALSE;
				byCntrCH3.0 := FALSE; byCntrCH3.1 := TRUE; byCntrCH3.2 := TRUE; byCntrCH3.3 := FALSE;	
					iState := 8; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF
	
	8://Check Status byte for Peak Value voltage and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF NOT byStateCH1.0 AND byStateCH1.1 AND byStateCH1.2 AND NOT byStateCH1.3 THEN
  			stDataL1.rPeakValueVoltage := INT_TO_REAL(iDataInCH1) * 0.1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF NOT byStateCH2.0 AND byStateCH2.1 AND byStateCH2.2 AND NOT byStateCH2.3 THEN
  			stDataL2.rPeakValueVoltage := INT_TO_REAL(iDataInCH2) * 0.1;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF NOT byStateCH3.0 AND byStateCH3.1 AND byStateCH3.2 AND NOT byStateCH3.3 THEN
  			stDataL3.rPeakValueVoltage := INT_TO_REAL(iDataInCH3) * 0.1;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 0111
				byCntrCH1.0 := TRUE; byCntrCH1.1 := TRUE; byCntrCH1.2 := TRUE; byCntrCH1.3 := FALSE;
				byCntrCH2.0 := TRUE; byCntrCH2.1 := TRUE; byCntrCH2.2 := TRUE; byCntrCH2.3 := FALSE;
				byCntrCH3.0 := TRUE; byCntrCH3.1 := TRUE; byCntrCH3.2 := TRUE; byCntrCH3.3 := FALSE;	
					iState := 9; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
		
	9://Check Status byte for Peak Value power and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF byStateCH1.0 AND byStateCH1.1 AND byStateCH1.2 AND NOT byStateCH1.3 THEN
  			stDataL1.rPeakValuePower := INT_TO_REAL(iDataInCH1) * rResolutionPower * uiCurrentTransformerRatioL1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF byStateCH2.0 AND byStateCH2.1 AND byStateCH2.2 AND NOT byStateCH2.3 THEN
  			stDataL2.rPeakValuePower := INT_TO_REAL(iDataInCH2) * rResolutionPower * uiCurrentTransformerRatioL2;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF byStateCH3.0 AND byStateCH3.1 AND byStateCH3.2 AND NOT byStateCH3.3 THEN
  			stDataL3.rPeakValuePower := INT_TO_REAL(iDataInCH3) * rResolutionPower * uiCurrentTransformerRatioL3;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 1000
				byCntrCH1.0 := FALSE; byCntrCH1.1 := FALSE; byCntrCH1.2 := FALSE; byCntrCH1.3 := TRUE;
				byCntrCH2.0 := FALSE; byCntrCH2.1 := FALSE; byCntrCH2.2 := FALSE; byCntrCH2.3 := TRUE;
				byCntrCH3.0 := FALSE; byCntrCH3.1 := FALSE; byCntrCH3.2 := FALSE; byCntrCH3.3 := TRUE;	
					iState := 10; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
	
	10://Check Status byte for Frequency and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF NOT byStateCH1.0 AND NOT byStateCH1.1 AND NOT byStateCH1.2 AND byStateCH1.3 THEN
  			stDataL1.rFrequency := INT_TO_REAL(iDataInCH1) * 0.1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF NOT byStateCH2.0 AND NOT byStateCH2.1 AND NOT byStateCH2.2 AND byStateCH2.3 THEN
  			stDataL2.rFrequency := INT_TO_REAL(iDataInCH2) * 0.1;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF NOT byStateCH3.0 AND NOT byStateCH3.1 AND NOT byStateCH3.2 AND byStateCH3.3 THEN
  			stDataL3.rFrequency := INT_TO_REAL(iDataInCH3) * 0.1;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 1001
				byCntrCH1.0 := TRUE; byCntrCH1.1 := FALSE; byCntrCH1.2 := FALSE; byCntrCH1.3 := TRUE;
				byCntrCH2.0 := TRUE; byCntrCH2.1 := FALSE; byCntrCH2.2 := FALSE; byCntrCH2.3 := TRUE;
				byCntrCH3.0 := TRUE; byCntrCH3.1 := FALSE; byCntrCH3.2 := FALSE; byCntrCH3.3 := TRUE;	
					iState := 11; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF
	
	11://Check Status byte for Min value current and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF byStateCH1.0 AND NOT byStateCH1.1 AND NOT byStateCH1.2 AND byStateCH1.3 THEN
  			stDataL1.rMinValueCurrent := INT_TO_REAL(iDataInCH1) * rResolutionCurrent * uiCurrentTransformerRatioL1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF byStateCH2.0 AND NOT byStateCH2.1 AND NOT byStateCH2.2 AND byStateCH2.3 THEN
  			stDataL2.rMinValueCurrent := INT_TO_REAL(iDataInCH2) * rResolutionCurrent * uiCurrentTransformerRatioL2;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF byStateCH3.0 AND NOT byStateCH3.1 AND NOT byStateCH3.2 AND byStateCH3.3 THEN
  			stDataL3.rMinValueCurrent := INT_TO_REAL(iDataInCH3) * rResolutionCurrent * uiCurrentTransformerRatioL3;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 1010
				byCntrCH1.0 := FALSE; byCntrCH1.1 := TRUE; byCntrCH1.2 := FALSE; byCntrCH1.3 := TRUE;
				byCntrCH2.0 := FALSE; byCntrCH2.1 := TRUE; byCntrCH2.2 := FALSE; byCntrCH2.3 := TRUE;
				byCntrCH3.0 := FALSE; byCntrCH3.1 := TRUE; byCntrCH3.2 := FALSE; byCntrCH3.3 := TRUE;	
					iState := 12; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
		
	12://Check Status byte for Min value voltage and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF NOT byStateCH1.0 AND byStateCH1.1 AND NOT byStateCH1.2 AND byStateCH1.3 THEN
  			stDataL1.rMinValueVoltage := INT_TO_REAL(iDataInCH1) * 0.1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF NOT byStateCH2.0 AND byStateCH2.1 AND NOT byStateCH2.2 AND byStateCH2.3 THEN
  			stDataL2.rMinValueVoltage := INT_TO_REAL(iDataInCH2) * 0.1;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF NOT byStateCH3.0 AND byStateCH3.1 AND NOT byStateCH3.2 AND byStateCH3.3 THEN
  			stDataL3.rMinValueVoltage := INT_TO_REAL(iDataInCH3) * 0.1;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Bin 1011
				byCntrCH1.0 := TRUE; byCntrCH1.1 := TRUE; byCntrCH1.2 := FALSE; byCntrCH1.3 := TRUE;
				byCntrCH2.0 := TRUE; byCntrCH2.1 := TRUE; byCntrCH2.2 := FALSE; byCntrCH2.3 := TRUE;
				byCntrCH3.0 := TRUE; byCntrCH3.1 := TRUE; byCntrCH3.2 := FALSE; byCntrCH3.3 := TRUE;	
					iState := 13; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
		
	13://Check Status byte for Min value power and wirte to the Output Structure
		iState_CP := iState;
			
		//Channel 1 (L1)		
		IF byStateCH1.0 AND byStateCH1.1 AND NOT byStateCH1.2 AND byStateCH1.3 THEN
  			stDataL1.rMinValuePower := INT_TO_REAL(iDataInCH1) * rResolutionPower * uiCurrentTransformerRatioL1;
				arrDataOk[1] := TRUE;
		END_IF 
		//Channel 2 (L2)		
		IF byStateCH2.0 AND byStateCH2.1 AND NOT byStateCH2.2 AND byStateCH2.3 THEN
  			stDataL2.rMinValuePower := INT_TO_REAL(iDataInCH2) * rResolutionPower * uiCurrentTransformerRatioL2;
				arrDataOk[2] := TRUE;
		END_IF 
		//Channel 3 (L3)		
		IF byStateCH3.0 AND byStateCH3.1 AND NOT byStateCH3.2 AND byStateCH3.3 THEN
  			stDataL3.rMinValuePower := INT_TO_REAL(iDataInCH3) * rResolutionPower * uiCurrentTransformerRatioL3;
				arrDataOk[3] := TRUE;
		END_IF 	
		
		//Next Step and prepear controll Byte
		IF arrDataOk[1] AND arrDataOk[2] AND arrDataOk[3] THEN 
			arrDataOk[1] := FALSE; arrDataOk[2] := FALSE; arrDataOk[3] := FALSE;
				//Start from New	
				iState := 1;
					bErrorTimeOut := FALSE; 
		END_IF
		
		//Timout Error
		IF timTimeout.Q THEN iState := 300; END_IF	
		
	300://Error
		bErrorTimeOut := TRUE;
		
		//Start from new with the Statemachine
		iState := 1;

END_CASE







]]></ST>
    </Implementation>
    <LineIds Name="FB_KL3403_SimpleProcessImage">
      <LineId Id="33" Count="2" />
      <LineId Id="9" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="56" Count="6" />
      <LineId Id="64" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="84" Count="3" />
      <LineId Id="90" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="102" Count="1" />
      <LineId Id="101" Count="0" />
      <LineId Id="109" Count="1" />
      <LineId Id="81" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="76" Count="1" />
      <LineId Id="125" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="68" Count="3" />
      <LineId Id="74" Count="0" />
      <LineId Id="127" Count="1" />
      <LineId Id="330" Count="0" />
      <LineId Id="96" Count="3" />
      <LineId Id="94" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="129" Count="2" />
      <LineId Id="119" Count="2" />
      <LineId Id="95" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="142" Count="0" />
      <LineId Id="145" Count="2" />
      <LineId Id="159" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="149" Count="2" />
      <LineId Id="162" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="203" Count="0" />
      <LineId Id="331" Count="0" />
      <LineId Id="172" Count="1" />
      <LineId Id="170" Count="1" />
      <LineId Id="169" Count="0" />
      <LineId Id="156" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="166" Count="1" />
      <LineId Id="176" Count="19" />
      <LineId Id="204" Count="0" />
      <LineId Id="332" Count="0" />
      <LineId Id="196" Count="6" />
      <LineId Id="153" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="206" Count="21" />
      <LineId Id="333" Count="0" />
      <LineId Id="228" Count="6" />
      <LineId Id="205" Count="0" />
      <LineId Id="175" Count="0" />
      <LineId Id="237" Count="21" />
      <LineId Id="334" Count="0" />
      <LineId Id="259" Count="6" />
      <LineId Id="235" Count="1" />
      <LineId Id="268" Count="21" />
      <LineId Id="335" Count="0" />
      <LineId Id="290" Count="6" />
      <LineId Id="266" Count="1" />
      <LineId Id="301" Count="21" />
      <LineId Id="336" Count="0" />
      <LineId Id="323" Count="6" />
      <LineId Id="300" Count="0" />
      <LineId Id="297" Count="0" />
      <LineId Id="339" Count="29" />
      <LineId Id="337" Count="1" />
      <LineId Id="371" Count="29" />
      <LineId Id="369" Count="1" />
      <LineId Id="403" Count="29" />
      <LineId Id="402" Count="0" />
      <LineId Id="401" Count="0" />
      <LineId Id="435" Count="29" />
      <LineId Id="433" Count="0" />
      <LineId Id="465" Count="0" />
      <LineId Id="467" Count="29" />
      <LineId Id="466" Count="0" />
      <LineId Id="497" Count="0" />
      <LineId Id="499" Count="21" />
      <LineId Id="524" Count="1" />
      <LineId Id="529" Count="0" />
      <LineId Id="526" Count="2" />
      <LineId Id="498" Count="0" />
      <LineId Id="434" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="138" Count="1" />
      <LineId Id="73" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="111" Count="6" />
      <LineId Id="65" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>