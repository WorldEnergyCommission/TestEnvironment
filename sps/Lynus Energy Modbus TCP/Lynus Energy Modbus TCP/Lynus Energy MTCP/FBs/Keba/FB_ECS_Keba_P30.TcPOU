<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_ECS_Keba_P30" Id="{a6a3b787-d268-4ed2-b314-3ca892c8f6b5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ECS_Keba_P30
VAR_INPUT PERSISTENT
	///{#lynus.ag#()} //Enable the Fuctionblock and his logic
	bEnable: BOOL;
	///With True its possible to invert all received power data from the electric meter
	bPowerDataInvers: BOOL;
	///Electric Fuse Line on wich the ECS is connected => 1 2 3 (If 0 then this charging station is not connected to a Electric Fuse Line)
	byElectricFuseLine: BYTE;
	///Failsafe Current when the connection between PLC and Charging station is interrupted. 0mA = CS Off, 6000mA - 32000mA
	uiFailsafeCurrent: UINT;
	///Failsafe Timeout when the connection between PLC and Charging station is interrupted. 10 - 600 sec
	uiFailsafeTimeOut: UINT := 10;
	///Number of EMS what control this Device.
	diNrOfEMS_IN: DINT;
	///Number of the electric meter for incoming power data. (Power Data for this Device)
	diNrOfEM_IN_CS: DINT;
	///IP Adress from the Keba charging station
	sIPAdress: STRING(15);
	///{#lynus.ag#()} //Setup charging station
	stSetupECS: ST_Setup_ECS;
END_VAR
VAR_OUTPUT
	///{#lynus.ag#()} //Electric charging station output data
	stDataECS: ST_ECS_Output;
	///Active Number from the Electric charging Function for using on other functions
	diNrOfECS_OUT: DINT;
	///Total Electric Power in kW read out directly from the Charging station. (Real time)
	lrTotalPowerECSRealTime: LREAL;
END_VAR
VAR
	///Function block for electric charging station
	{attribute 'hide' := ''}
	fbCS: FB_ElectricChargingStation;
	///Function block to calcualte the number of the Device
	{attribute 'hide' := ''}
	fbNumberDevice: FB_NumberOfDevice;
	///Digital Input from external loock signal
	fbDIExternalLock: FB_XL1XXX_DI;
	///Modbus Read Function (FC3)
	{attribute 'hide' := ''}
	fbMBRead_FC3: FB_MBReadRegs;
	///Modbus Write Function (FC6)
	{attribute 'hide' := ''}
	fbMBWrite_FC6: FB_MBWriteSingleReg;
	///Convert Word to Dword
	{attribute 'hide' := ''}
	fbConvertWordToDword: FB_CV_WORD_TO_DWORD;
	///Timer for Delay between Requests
	{attribute 'hide' := ''}
	timDelay: TON;
	///Timer for Timeout
	{attribute 'hide' := ''}
	timTimeout: TON;
	///Timer to dissable the Function after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days without connection to the Lynus Cloud
	{attribute 'hide' := ''}
	timDissableFunctions: TON;
	///Timer to try reset the connection Flag on the GVL. (When somebody delete the Connection Function and make only a onlinechange)
	{attribute 'hide' := ''}
	timResetConnectionOnGVL: TON;
	///Charging Time
	{attribute 'hide' := ''}
	timChTimeSocket: TON;
	///Timer to start the state machine with Daley after enabling or after the system ist restartet
	{attribute 'hide' := ''}
	timDelayStart: TON;
	///Timer to Close the Socket after to much Errors
	{attribute 'hide' := ''}
	timCloseSocket: TON;
	///Internal positive Edge
	{attribute 'hide' := ''}
	FPError_FC_3: R_TRIG;
	///Internal positive Edge
	{attribute 'hide' := ''}
	FPError_FC_6: R_TRIG;
	///Internal positive Edge
	{attribute 'hide' := ''}
	FPEnable: R_TRIG;
	///Function to save persistent data
	{attribute 'hide' := ''}
	arrPD: ARRAY[1..16] OF FB_PersistentData_Number;
	///Function to save persistent string data
	{attribute 'hide' := ''}
	fbPDString: FB_PersistentData_String;
	///Buffer with Data from FC3
	{attribute 'hide' := ''}
	arrBuffer_FC3: ARRAY[1..2] OF WORD;
	///Error State from the charging station
	{attribute 'hide' := ''}
	bErrorCS: BOOL;
	///Modbus TCP Function Error Counter																	
	{attribute 'hide' := ''}
	byMBTCPErrorCounter: BYTE;
	///Wait in Step before start to clean data on PLC
	{attribute 'hide' := ''}
	byWaitInStep: BYTE;
	///State machine to handle the data on the GVL
	{attribute 'hide' := ''}
	iStateGVLData: INT;
	///State machine for read out Data over Modbus TCP
	{attribute 'hide' := ''}
	iStateModbusRead: INT;
	///State machine for write Data over Modbus TCP
	{attribute 'hide' := ''}
	iStateModbusWrite: INT;
	///State machine for error out Data over Modbus TCP	
	{attribute 'hide' := ''}
	iStateModbusError: INT;
	///Variable to compare the state machine variable to set or reset the timeout timer
	{attribute 'hide' := ''}
	iStateModbus_CP: INT;
	///Number of active batterys
	{attribute 'hide' := ''}
	diNumberOfActiveBatterys: DINT;
	///Number of battery inverters that work in Emergency Power operation 
	{attribute 'hide' := ''}
	diNumberOfBatteryInverterInEPO: DINT;
	///Loop to clean old data on GVL
	{attribute 'hide' := ''}
	diLPForGVL: DINT;
	///Counter to clean old data on GVL
	{attribute 'hide' := ''}
	diCounterForGVL: DINT;
	///Sum of the SOC from all batterys
	{attribute 'hide' := ''}
	dwSumSOC: DWORD;
	///Charging State from the Keba Charger
	{attribute 'hide' := ''}
	dwChargingState: DWORD;
	///Cable State from the Keba Charger
	{attribute 'hide' := ''}
	dwCableState: DWORD;
	///Error Code from the Keba Charger
	{attribute 'hide' := ''}
	dwErrorCode: DWORD;
	///Power from the ECS in W 
	{attribute 'hide' := ''}
	rPowerECS: REAL;
	///Energy Counter Consumption in Wh
	{attribute 'hide' := ''}
	lrTotalCounterEnergy_Consumption: LREAL;
	///Charged Energy from the active Session in Wh
	{attribute 'hide' := ''}
	lrChargedEnergySession: LREAL;
	///Loop to check some data from batterys
	{attribute 'hide' := ''}
	liLPBatteryData: LINT;
	///Loop to check if 1 or more battery inverters build a island grid
	{attribute 'hide' := ''}
	liLPInEPO: LINT;
END_VAR
VAR PERSISTENT
	///Number of EMS what control this Device to compare with the original
	{attribute 'conditionalshow' := ''}
	diNrOfEMS_IN_CP: DINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Kai Ebensperger
//Company : Lynus AG
//Date : 15.07.2022
//Version : 1.0.0.0

//With this Funcition its possible to communicate with a Keba P30 Charging station over Modbus TCP.
//Support the C-Series from Version 3.10.16 or higher
//Support the X-Series from Version 1.11 or higher
//Its possible to controll the charging station over the charge current
//When the Function send 0 Ampere is switched of, then the charging station is blocked and its not possible to charge
//The Communication is not so fast because in the Documentation they write that we can read every 500MS but we can write onle ever 5 seconds.
//We can read only 1 Register at each command. Its not possible to read more Registers with 1 command
//The Unit ID is always 255
//Also the Settings for Fail Save is includes in ths Fuction. The Failsave Current is set to uiFailsafeCurrent.
//Failsafe takes effect when the connection between the PLC and the charging station is interrupted. Timout is uiFailsafeTimeOut in seconds.

//Versions that are supported : 1.3

//NOTE for diNr.....Designation => 
//_IN = Here Data come in from other Functions or go out to other functions about the GVL
//_OUT = Here Data go out to other functions about the GVL

(*--------------------------------------------------------------------------------------------Limits-------------------------------------------------------------------------------------*)

diNrOfEMS_IN := LIMIT(0,diNrOfEMS_IN,Constants_Energy.diMaxNumberOfEMS);
	diNrOfEM_IN_CS := LIMIT(0,diNrOfEM_IN_CS,Constants_Energy.diMaxNumberOfElectricMeters);
		byElectricFuseLine := LIMIT(0,byElectricFuseLine,30);
			IF uiFailsafeCurrent > 0 THEN 
				uiFailsafeCurrent := LIMIT(6000,uiFailsafeCurrent,32000);
			END_IF 
				uiFailsafeTimeOut := LIMIT(10,uiFailsafeTimeOut,600);	
		
(*------------------------------------------------------------------Power Data----------------------------------------------------------------------------*)

IF diNrOfEM_IN_CS <> 0 THEN
	//Energy Session Input data
	fbCS.bCalculateEnergySession := FALSE;
	fbCS.arrSocketPowerECS[1] := 0;
	fbCS.arrSocketPowerECS[2] := 0;
	fbCS.arrSocketPowerECS[3] := 0;
	fbCS.arrSocketPowerECS[4] := 0;
	fbCS.arrSocketEnergySession[1] := 0;
	fbCS.arrSocketEnergySession[2] := 0;
	fbCS.arrSocketEnergySession[3] := 0;
	fbCS.arrSocketEnergySession[4] := 0;
		IF NOT bPowerDataInvers THEN
			//Energy meter input data for cs Function block
			fbCS.lrCounterEnergyT1_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Production * 1000;
			fbCS.lrCounterEnergyT2_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Production * 1000;
			fbCS.lrCounterEnergyT1_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
			fbCS.lrCounterEnergyT2_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
			fbCS.lrTotalCounterEnergy_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Production * 1000;
			fbCS.lrTotalCounterEnergy_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Consumption * 1000;
				fbCS.lrTotalPowerECS := (Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrPower * 1000) * - 1;
			ELSE
			//Energy meter input data for cs Function block
			fbCS.lrCounterEnergyT1_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
			fbCS.lrCounterEnergyT2_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Consumption * 1000;
			fbCS.lrCounterEnergyT1_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Production * 1000;
			fbCS.lrCounterEnergyT2_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Production * 1000;
			fbCS.lrTotalCounterEnergy_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Consumption * 1000;
			fbCS.lrTotalCounterEnergy_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Production * 1000;
				fbCS.lrTotalPowerECS := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrPower * 1000;
		END_IF
ELSE
	//Energy meter input data for cs Function block
	fbCS.lrCounterEnergyT1_Consumption := lrTotalCounterEnergy_Consumption;
	fbCS.lrCounterEnergyT2_Consumption := 0;
	fbCS.lrCounterEnergyT1_Production := 0;
	fbCS.lrCounterEnergyT2_Production := 0;
	fbCS.lrTotalCounterEnergy_Consumption := lrTotalCounterEnergy_Consumption;
	fbCS.lrTotalCounterEnergy_Production := 0;
		fbCS.lrTotalPowerECS := rPowerECS;
	//Energy Session Input data
	fbCS.bCalculateEnergySession := FALSE;
	fbCS.arrSocketPowerECS[1] := rPowerECS;
	fbCS.arrSocketPowerECS[2] := 0;
	fbCS.arrSocketPowerECS[3] := 0;
	fbCS.arrSocketPowerECS[4] := 0;
	fbCS.arrSocketEnergySession[1] := lrChargedEnergySession;
	fbCS.arrSocketEnergySession[2] := 0;
	fbCS.arrSocketEnergySession[3] := 0;
	fbCS.arrSocketEnergySession[4] := 0;
END_IF			

(*-------------------------------------------------------------Calcualte the number of ECS---------------------------------------------------------------*)

fbNumberDevice(
	diActualNumberOfDevices:= Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS, 
	diMaxNumberOfDevices:= Constants_Energy.diMaxNumberOfElectricChargingStations, 
	udiCounterOnlineChange:= TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, 
	bNumberIsCalculatet=> , 
	bFPNumberIsCalculatet=> , 
	bOnlineChange=> , 
	diNumberForThisDevice=> diNrOfECS_OUT, 
	diNumberOfTotalDevices=> );

//Write new Numer on GVL
IF fbNumberDevice.bFPNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS := fbNumberDevice.diNumberOfTotalDevices;	
END_IF 

//Delete old Number on GVL
IF fbNumberDevice.bOnlineChange THEN 
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS := diNrOfECS_OUT;	
		iStateGVLData := 1;
END_IF

(*-------------------------------------------------------------Service from Backend is ready and check the connection to backen for dissabel/enable Function---------------------------------------------------------------*)

//Try to reset the variable for connection on the GVL. When all is normal then the Lynus Mqtt connection function set this variable to true in the next cycle
//When we have no connection to the backend then after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions days the Function is dissabled with all of his functionalities
timResetConnectionOnGVL(IN:= NOT timResetConnectionOnGVL.Q, PT:= T#1H, Q=> , ET=> );
	IF timResetConnectionOnGVL.Q THEN Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := FALSE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions THEN timDissableFunctions.IN := TRUE; ELSE timDissableFunctions.IN := FALSE; END_IF  
			timDissableFunctions(IN:= , PT:= Lynus_Standards.Constants_General.tTimeDissableLynusFunctions, Q=> , ET=> );
			
(*--------------------------------------------------------------------------------------------State Machine Read--------------------------------------------------------------------------------------*)

//Timer for Delay
timDelay(IN:= , PT:= T#750MS, Q=> , ET=> );

//Timer for Timeout in Statemachine
IF (iStateModbusRead > 0 AND iStateModbusRead <= 7 AND iStateModbusRead = iStateModbus_CP) OR
		(iStateModbusWrite > 0 AND iStateModbusWrite <= 2 AND iStateModbusWrite = iStateModbus_CP) THEN
			timTimeout.IN := TRUE;
ELSE	
			timTimeout.IN := FALSE;
END_IF
	//Timeout Timer is dissabled when the Init Step is aktiv or the function is not enabled
	IF (iStateModbusRead = 0 AND iStateModbusWrite = 0) OR NOT bEnable THEN timTimeout.IN := FALSE; END_IF
		timTimeout(IN:= , PT:= T#10S, Q=> , ET=> );

//Enable with Delay that not all sockets have to be created at the same time
timDelayStart(IN:= bEnable, PT:= T#20MS * diNrOfECS_OUT, Q=> , ET=> );
	FPEnable(CLK:= timDelayStart.Q, Q=> );

IF FPEnable.Q AND iStateModbusRead = 0 AND iStateModbusWrite = 0 THEN iStateModbusRead := 1; END_IF		
		
//Not Enabled
IF NOT bEnable THEN iStateModbusRead := 0; iStateModbusError := 0; iStateModbusWrite := 0; END_IF		
		
CASE iStateModbusRead OF

	0://Init Step 
		iStateModbus_CP := 0;
			timDelay.IN := FALSE;
				fbMBRead_FC3.bExecute := FALSE;
					fbMBWrite_FC6.bExecute := FALSE;
						rPowerECS := 0;
							dwChargingState := 0;
								dwCableState := 0;	
									lrChargedEnergySession := 0;
	
	1://Charging State (Register 1000) !!!!Maybe 0 or 1....test it. Then change also the other Register Adresses!!!!!
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 2;
			fbMBRead_FC3.nMBAddr := 1000;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := 255;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Charging State
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
				dwChargingState := fbConvertWordToDword.dwOutputValue;
			
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 2;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
		
	2://Cable State (Register 1004)
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 2;
			fbMBRead_FC3.nMBAddr := 1004;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := 255;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Cable State
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
				dwCableState := fbConvertWordToDword.dwOutputValue;
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 3;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
		
	3://Error Code (Register 1006)
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 2;
			fbMBRead_FC3.nMBAddr := 1006;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := 255;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Error Code
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
				dwErrorCode := fbConvertWordToDword.dwOutputValue;
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 4;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
		
	4://Active Power (Register 1020)
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 2;
			fbMBRead_FC3.nMBAddr := 1020;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := 255;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Active Power in mW
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
				rPowerECS := DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue);
					rPowerECS := rPowerECS / 1000;	
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 5;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
	
	5://Total Energy (Register 1036)
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 2;
			fbMBRead_FC3.nMBAddr := 1036;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := 255;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Total Energy in Wh
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
				lrTotalCounterEnergy_Consumption := DWORD_TO_LREAL(fbConvertWordToDword.dwOutputValue);
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 6;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
		
	6://Charged Energy from current charging session (Register 1502)
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 2;
			fbMBRead_FC3.nMBAddr := 1502;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := 255;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Total Energy in Wh
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
				lrChargedEnergySession := DWORD_TO_LREAL(fbConvertWordToDword.dwOutputValue);
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 7;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
		
	7://Wait 1 Step to reset the delay counter befor start to write
		iStateModbus_CP := iStateModbusRead;
		
			iStateModbusWrite := 1;
				//-1 because 0 is the Init Step for Read
				iStateModbusRead := - 1;
				
			//Error on Master, changes on Inputs or Timeout
		 	IF timTimeout.Q THEN 
				iStateModbusError := 300;	 
			END_IF
	
END_CASE

(*------------------------------------------------------------------Error and Warning----------------------------------------------------------------------------*)	
 
IF dwChargingState = 4 OR dwErrorCode <> 0 THEN bErrorCS := TRUE; ELSE bErrorCS := FALSE; END_IF

IF timDissableFunctions.Q THEN fbCS.bWarning := TRUE; fbCS.iWarningCode := 0; ELSE fbCS.bWarning := FALSE; END_IF   
	IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS > Constants_Energy.diMaxNumberOfElectricChargingStations OR bErrorCS OR byMBTCPErrorCounter > 10 THEN 
		fbCS.bError := TRUE;
	ELSE 
		fbCS.bError := FALSE;
			fbCS.iErrorCode := 0;
	END_IF

IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS > Constants_Energy.diMaxNumberOfElectricChargingStations THEN fbCS.iErrorCode := 1;
ELSIF bErrorCS OR byMBTCPErrorCounter > 10 THEN fbCS.iErrorCode := 0; END_IF

(*------------------------------------------------------------------Logic----------------------------------------------------------------------------*)

//Calcualte the total SOC if we have more then 1 battery in our system
diNumberOfActiveBatterys := 0;
	dwSumSOC := 0;
		FOR liLPBatteryData := 1 TO Constants_Energy.diMaxNumberOfBatterys BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_IN,liLPBatteryData].bEnabled THEN diNumberOfActiveBatterys := diNumberOfActiveBatterys + 1; END_IF
				dwSumSOC := dwSumSOC + Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_IN,liLPBatteryData].dwSOC;
		END_FOR
	
IF diNumberOfActiveBatterys > 0 THEN
	fbCS.dwBatterySOC := DINT_TO_DWORD(DWORD_TO_DINT(dwSumSOC) / diNumberOfActiveBatterys);
ELSE
	fbCS.dwBatterySOC := 100;	//When we have no battery in the ems system
END_IF

//Check if one or more Batterysystems or batteryinverter make island mode
diNumberOfBatteryInverterInEPO := 0;
	FOR liLPInEPO := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
		IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_IN,liLPInEPO].bWorkOnIslandMode THEN fbCS.bEPOIsActive := TRUE; diNumberOfBatteryInverterInEPO := diNumberOfBatteryInverterInEPO + 1; END_IF
	END_FOR 
		IF diNumberOfBatteryInverterInEPO <= 0 THEN fbCS.bEPOIsActive := FALSE; END_IF

//Digital input for external lock signal
fbDIExternalLock(bInvers:= FALSE, bSignal=> );

//Car connected to the ECS
IF dwCableState = 5 OR dwCableState = 7 THEN fbCS.bCarConnected := TRUE; ELSE fbCS.bCarConnected := FALSE; END_IF

//Charging time
IF dwChargingState = 3 OR dwCableState = 7 THEN timChTimeSocket.IN := TRUE; ELSE timChTimeSocket.IN := FALSE; END_IF

IF timChTimeSocket.IN THEN fbCS.arrSocketChargingTimeInput[1] := TIME_TO_REAL(timChTimeSocket.ET) / 60000; END_IF
fbCS.arrSocketChargingTimeInput[2] := 0;
fbCS.arrSocketChargingTimeInput[3] := 0;
fbCS.arrSocketChargingTimeInput[4] := 0;

timChTimeSocket(IN:= , PT:= T#24H, Q=> , ET=> );

//Mode 3 State
//Default set to No Informantion
fbCS.arrSocketMode3StateECS[1] := '';
	//Ready or Free
	IF dwChargingState = 2 THEN fbCS.arrSocketMode3StateECS[1] := 'A'; END_IF
	//Car Connected
	IF dwCableState = 5 OR dwCableState = 7 THEN fbCS.arrSocketMode3StateECS[1] := 'B1'; END_IF
	//Charging
	IF dwChargingState = 3 OR dwCableState = 7 THEN fbCS.arrSocketMode3StateECS[1] := 'C2'; END_IF
	//Error
	IF dwChargingState = 4 OR dwErrorCode <> 0 THEN fbCS.arrSocketMode3StateECS[1] := 'F'; END_IF 

fbCS.arrSocketMode3StateECS[2] := '';
fbCS.arrSocketMode3StateECS[3] := '';
fbCS.arrSocketMode3StateECS[4] := '';

//SOC Car
fbCS.arrSOCCar[1] := 0;
fbCS.arrSOCCar[2] := 0;
fbCS.arrSOCCar[3] := 0;
fbCS.arrSOCCar[4] := 0;

//Functionblock ECS
fbCS(
	bEnable:= bEnable AND NOT timDissableFunctions.Q, 
	bError:= ,
	bWarning := ,
	bEPOIsActive:= , 
	bExternalLock:= fbDIExternalLock.bSignal, 
	bCarConnected:= , 
	bWriteWithDelay:= TRUE, 
	bCalculateEnergySession:= ,
	iErrorCode:= , 
	iWarningCode:= , 
	arrSocketChargingTimeInput:= ,
	arrSOCCar:= , 
	dwBatterySOC:= , 
	lrTotalCounterEnergy_Consumption:= , 
	lrTotalCounterEnergy_Production:= , 
	lrCounterEnergyT1_Consumption:= , 
	lrCounterEnergyT2_Consumption:= , 
	lrCounterEnergyT1_Production:= , 
	lrCounterEnergyT2_Production:= , 
	lrTotalPowerECS:= , 
	arrSocketEnergySession:= ,
	rTargetPower:= Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].rTargetPowerEMS, 
	rSupplyVoltage:= 692, 
	rMinCurrent:= 6, 
	tTimDelayOutput:= T#5S, 
	tDelayError:= T#5S,
	arrSocketMode3StateECS:= ,
	arrSocketPowerECS:= ,
	stSetupECS:= stSetupECS, 
	stDataECSOut=> , 
	stDataECSOutDelay=> stDataECS);

//Real time Power for Output
lrTotalPowerECSRealTime := fbCS.stDataECSOut.lrTotalPower;
	
(*------------------------------------------------------------------------------------------State Machine Write---------------------------------------------------------------------------------------------*)	

CASE iStateModbusWrite OF	

	1://Set the charging current (Reg 5004)
		iStateModbus_CP := iStateModbusWrite;
		
			fbMBWrite_FC6.nMBAddr := 5004;
				fbMBWrite_FC6.bExecute := TRUE;
					fbMBWrite_FC6.nUnitID := 255;
						//Charge Current in mA
						fbMBWrite_FC6.nValue := REAL_TO_WORD(fbCS.stDataECSOut.rTargetChargeCurrent * 1000);
		
		IF fbMBWrite_FC6.bBusy THEN timDelay.IN := TRUE; END_IF

		//Wait for Delay and then next step
		IF NOT fbMBWrite_FC6.bBusy AND NOT fbMBWrite_FC6.bError AND timDelay.Q THEN
			fbMBWrite_FC6.bExecute := FALSE;
				timDelay.IN := FALSE;
					//Go to Next Step
					iStateModbusWrite := 2;
		END_IF
				
		//Error or Timout
		IF FPError_FC_6.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF
	
	2://Enable/Dissable Charging station (Reg 5014)
		iStateModbus_CP := iStateModbusWrite;
		
			fbMBWrite_FC6.nMBAddr := 5014;
				fbMBWrite_FC6.bExecute := TRUE;
					fbMBWrite_FC6.nUnitID := 255;
						//Enable and Dissable the Charging station
						IF fbCS.stDataECSOut.rTargetChargeCurrent <> 0 THEN 
							//Enable
							fbMBWrite_FC6.nValue := 1;
						ELSE
							//Dissable
							fbMBWrite_FC6.nValue := 0;
						END_IF
		
		IF fbMBWrite_FC6.bBusy THEN timDelay.IN := TRUE; END_IF

		//Wait for Delay and then next step
		IF NOT fbMBWrite_FC6.bBusy AND NOT fbMBWrite_FC6.bError AND timDelay.Q THEN
			fbMBWrite_FC6.bExecute := FALSE;
				timDelay.IN := FALSE;
					//Go to Next Step
					iStateModbusWrite := 3;
		END_IF
				
		//Error or Timout
		IF FPError_FC_6.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF
		
	3://Failsafe current (Reg 5016)
		iStateModbus_CP := iStateModbusWrite;
		
			fbMBWrite_FC6.nMBAddr := 5016;
				fbMBWrite_FC6.bExecute := TRUE;
					fbMBWrite_FC6.nUnitID := 255;
						//Failsafe current in mA
						fbMBWrite_FC6.nValue := uiFailsafeCurrent;
	
		IF fbMBWrite_FC6.bBusy THEN timDelay.IN := TRUE; END_IF

		//Wait for Delay and then next step
		IF NOT fbMBWrite_FC6.bBusy AND NOT fbMBWrite_FC6.bError AND timDelay.Q THEN
			fbMBWrite_FC6.bExecute := FALSE;
				timDelay.IN := FALSE;
					//Go to Next Step
					iStateModbusWrite := 3;
		END_IF
				
		//Error or Timout
		IF FPError_FC_6.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
		
	4://Failsafe Timeout (Reg 5018)
		iStateModbus_CP := iStateModbusWrite;
		
			fbMBWrite_FC6.nMBAddr := 5018;
				fbMBWrite_FC6.bExecute := TRUE;
					fbMBWrite_FC6.nUnitID := 255;
						//Failsafe Timeout in sec.
						fbMBWrite_FC6.nValue := uiFailsafeTimeOut;
	
		IF fbMBWrite_FC6.bBusy THEN timDelay.IN := TRUE; END_IF

		//Wait for Delay and then next step
		IF NOT fbMBWrite_FC6.bBusy AND NOT fbMBWrite_FC6.bError AND timDelay.Q THEN
			fbMBWrite_FC6.bExecute := FALSE;
				timDelay.IN := FALSE;
					byMBTCPErrorCounter := 0; 
						//Restart from new with the Read out part
						iStateModbusRead := 1;
							iStateModbusWrite := 0;
		END_IF
				
		//Error or Timout
		IF FPError_FC_6.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
		
END_CASE	
	
(*------------------------------------------------------------------------------------------State Machine Error---------------------------------------------------------------------------------------------*)	

CASE iStateModbusError OF
	
	300://Error
		iStateModbus_CP := iStateModbusError;
			timDelay.IN := FALSE;
				fbMBRead_FC3.bExecute := FALSE;
					fbMBWrite_FC6.bExecute := FALSE;
						byMBTCPErrorCounter := byMBTCPErrorCounter + 1;
							byMBTCPErrorCounter := LIMIT(0,byMBTCPErrorCounter,11); 		
								//Restart from new with the Read out part after an Error
								IF byMBTCPErrorCounter < 10 THEN
									iStateModbusRead := 1;	
										iStateModbusError := 0;
											iStateModbusWrite := 0;
								ELSE
									//Wait here in the Error State for the Delay Timer and then we dont have a Timeout Error
									iStateModbusRead := - 1;
										iStateModbusWrite := - 1;
											//Start from New when the Delay is paste
											IF timCloseSocket.Q THEN
												iStateModbusRead := 1;	
													iStateModbusError := 0;
														iStateModbusWrite := 0;	
															byMBTCPErrorCounter := 0;
											END_IF
								END_IF
						
END_CASE

//Timer to close the Socket after to much TCP Errors and reopen a new one
timCloseSocket(IN:= byMBTCPErrorCounter > 10 AND fbCS.stDataECSOut.bEnabled, PT:= T#1M, Q=> , ET=> );

(*------------------------------------------------------------------------------------------Modbus TCP Functions---------------------------------------------------------------------------------------------*)

fbMBRead_FC3(sIPAddr:= sIPAdress, nTCPPort:= 502,cbLength:= SIZEOF(arrBuffer_FC3), pDestAddr:= ADR(arrBuffer_FC3), tTimeout:= T#5S );
	FPError_FC_3(CLK:= fbMBRead_FC3.bError, Q=> );		

fbMBWrite_FC6(sIPAddr:= sIPAdress, nTCPPort:= 502, tTimeout:= T#5S);	
	FPError_FC_6(CLK:= fbMBWrite_FC6.bError, Q=> );

(*-----------------------------------------------------------Handle data to Global structure for electric charging stations-----------------------------------------------------------------*)

//Delte al old Data on GVL after a online change or change on the variable diNrOfEMS_IDOD
IF diNrOfEMS_IN <> diNrOfEMS_IN_CP AND iStateGVLData = 0 THEN iStateGVLData := 10; END_IF 

CASE iStateGVLData OF
	
	0://Init Step
		byWaitInStep := 0;
			diCounterForGVL := 1;
	
	1://Wait for 4 Steps before clean al Data on GVL
		byWaitInStep := byWaitInStep + 1;
			IF byWaitInStep >= 4 AND fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 2; END_IF
				//To much Devices, back to the Init step
				IF byWaitInStep >= 4 AND NOT fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 0; END_IF	
			
	2://Clear all Data in GVL
		FOR diLPForGVL := 1 TO Constants_Energy.diMaxNumberOfEMS BY 1 DO 
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].bEnabled := FALSE;
				Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].bIsControllable := FALSE;
					Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byErrorWarning := 0;
						Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byPriority := 0;
							Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPower := 0;
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPowerConsumption := 0;
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPowerProduction := 0;
										Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].rMaxPower := 0;
											Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byElectricFuseLine := 0;
												//Set also the target value from ems back here to 0 and not in EMS function because EMS is in Standy when we have a online change (Problem when we delete a ems function and make a online change)
												Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].rTargetPowerEMS := 0;	
		END_FOR
		
			//Counter for ECS
			diCounterForGVL := diCounterForGVL + 1;
				diCounterForGVL := LIMIT(0,diCounterForGVL,Constants_Energy.diMaxNumberOfElectricChargingStations);
					//Back to the init step
					IF diCounterForGVL >= Constants_Energy.diMaxNumberOfElectricChargingStations THEN iStateGVLData := 0; END_IF

	10://Clear old Data on GVL 		
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].bEnabled := FALSE;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].bIsControllable := FALSE;
				Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byErrorWarning := 0;
					Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byPriority := 0;
						Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPower := 0;
							Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPowerConsumption := 0;
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPowerProduction := 0;
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].rMaxPower := 0;
										Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byElectricFuseLine := 0;
									
		diNrOfEMS_IN_CP := diNrOfEMS_IN;
			//Back to the init step
			iStateGVLData := 0;

END_CASE 	 

IF diNrOfECS_OUT > 0 AND fbNumberDevice.bNumberIsCalculatet AND diNrOfEMS_IN > 0 THEN
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].bEnabled := fbCS.stDataECSOut.bEnabled;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].bIsControllable := TRUE;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byErrorWarning := fbCS.stDataECSOut.byErrorWarning;
				Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byPriority := fbCS.stDataECSOut.byPriority;
					Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPower := fbCS.stDataECSOut.lrTotalPower;
						Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPowerConsumption := fbCS.stDataECSOut.lrTotalPowerConsumption;
							Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPowerProduction := fbCS.stDataECSOut.lrTotalPowerProduction;
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].rMaxPower := fbCS.stDataECSOut.rMaxPower;	
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byElectricFuseLine := byElectricFuseLine;
END_IF 

(*----------------------------------------------------------Save persistent data----------------------------------------------------------------*)

arrPD[1](lrValue:= BOOL_TO_LREAL(bEnable), bEventBasedActive=> );
arrPD[2](lrValue:= BOOL_TO_LREAL(bPowerDataInvers), bEventBasedActive=> );
arrPD[3](lrValue:= DINT_TO_LREAL(diNrOfEMS_IN), bEventBasedActive=> );
arrPD[4](lrValue:= DINT_TO_LREAL(diNrOfEM_IN_CS), bEventBasedActive=> );
arrPD[5](lrValue:= BOOL_TO_LREAL(stSetupECS.bManualyOn), bEventBasedActive=> );
arrPD[6](lrValue:= BOOL_TO_LREAL(stSetupECS.bOnEmergPowerOff), bEventBasedActive=> );
arrPD[7](lrValue:= BYTE_TO_LREAL(stSetupECS.byCSMinPower), bEventBasedActive=> );
arrPD[8](lrValue:= BYTE_TO_LREAL(stSetupECS.byDisableSOC), bEventBasedActive=> );
arrPD[9](lrValue:= BYTE_TO_LREAL(stSetupECS.byEnableSOC), bEventBasedActive=> );
arrPD[10](lrValue:= BYTE_TO_LREAL(stSetupECS.byManualyTargetPower), bEventBasedActive=> );
arrPD[11](lrValue:= BYTE_TO_LREAL(stSetupECS.byPriority), bEventBasedActive=> );
arrPD[12](lrValue:= REAL_TO_LREAL(stSetupECS.rMaxPower), bEventBasedActive=> );
arrPD[13](lrValue:= DINT_TO_LREAL(diNrOfEMS_IN_CP), bEventBasedActive=> );
arrPD[14](lrValue:= BYTE_TO_LREAL(byElectricFuseLine), bEventBasedActive=> );
arrPD[15](lrValue:= UINT_TO_LREAL(uiFailsafeCurrent), bEventBasedActive=> );
arrPD[16](lrValue:= UINT_TO_LREAL(uiFailsafeTimeOut), bEventBasedActive=> );
fbPDString(sText:= sIPAdress, bEventBasedActive=> );
]]></ST>
    </Implementation>
    <LineIds Name="FB_ECS_Keba_P30">
      <LineId Id="3" Count="682" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>