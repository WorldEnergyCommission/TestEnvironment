<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_PhoenixContact_EM_EEM_EM375" Id="{67e7a2f4-36da-4f4d-b8b0-fca33e4874a7}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PhoenixContact_EM_EEM_EM375
VAR_INPUT PERSISTENT
	///Enable the function
	bEnable: BOOL;
	///Unit ID
	byUnitID: BYTE := 1;
	///IP Adress from the Meter					
	sIPAdress: STRING(15);
END_VAR
VAR_OUTPUT
	///Output structure with Data from Electric Meter (Power Data)
	stDataEMPower: ST_ElectricMeter_Output_Power;
	///Output structure with Data from Electric Meter (Counter Data)
	stDataEMCounter: ST_ElectricMeter_Output_Counter;
	///Output structure with Data from Electric Meter (Power Data RealTime)
	stDataEMPowerRealTime: ST_ElectricMeter_Output_Power;
	///Output structure with Data from Electric Meter (Counter Data RealTime)
	stDataEMCounterRealTime: ST_ElectricMeter_Output_Counter;
	///Active Number from the Electric Meter for using on other functions
	diNrOfEM_OUT: DINT;
END_VAR
VAR
	///Electric Meter Function
	{attribute 'conditionalshow' := ''}
	fbEM: FB_ElectricMeter;
	///Function block to calcualte the number of the Device
	{attribute 'hide' := ''}
	fbNumberDevice: FB_NumberOfDevice;
	///Modbus Read Function (FC3)
	{attribute 'hide' := ''}
	fbMBRead_FC3: FB_MBReadRegs;
	///Convert function
	{attribute 'hide' := ''}
	fbConvertData: FB_CV_WORD_TO_DWORD;
	///Timer to dissable the Function after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days without connection to the Lynus Cloud
	{attribute 'hide' := ''}
	timDissableFunctions: TON;
	///Timer to try reset the connection Flag on the GVL. (When somebody delete the Connection Function and make only a onlinechange)
	{attribute 'hide' := ''}
	timResetConnectionOnGVL: TON;
	///Timer for Delay between Requests
	{attribute 'hide' := ''}
	timDelay: TON;
	///Timer for Timeout
	{attribute 'hide' := ''}
	timTimeout: TON;
	///Timer to Close the Socket after to much Errors
	{attribute 'hide' := ''}
	timCloseSocket: TON;
	///Internal positive Edge
	{attribute 'hide' := ''}
	FPEnable: R_TRIG;
	///Internal positive Edge
	{attribute 'hide' := ''}
	FPError_FC_3: R_TRIG;
	///Function to save persistent data
	{attribute 'hide' := ''}
	PD_String: FB_PersistentData_String;
	///Function to save persistent data
	{attribute 'hide' := ''}
	arrPD: ARRAY[1..2] OF FB_PersistentData_Number;
	///Buffer with Data from FC3
	{attribute 'hide' := ''}
	arrBuffer_FC3: ARRAY[1..62] OF WORD;
	///Error from Table A-17
	{attribute 'hide' := ''}
	bErrorFromDevice: BOOL;
	///Wait in Step before start to clean data on PLC
	{attribute 'hide' := ''}
	byWaitInStep: BYTE;
	///Modbus TCP Function Error	Counter
	{attribute 'hide' := ''}
	byMBTCPErrorCounter: BYTE;
	///State machine to handle the data on the GVL
	{attribute 'hide' := ''}
	iStateGVLData: INT;
	///State variable for Statemachine
	{attribute 'hide' := ''}
	iStateModbusRead: INT;
	///State variable for Statemachine
	{attribute 'hide' := ''}
	iStateModbusError: INT;
	///Compare State variable
	{attribute 'hide' := ''}
	iStateModbus_CP: INT;
	///Counter to clean old data on GVL
	{attribute 'hide' := ''}
	diCounterForGVL: DINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Kai Ebensperger
//Company : Lynus AG
//Date : 19.09.2021
//Version : 1.0.0.0

//With this function block its possible to read out a Electric Meter EEM-EM375 from the Factory Phönix Contact.
//This Function Block read out the Default Values from the Electric Meter from Table A-2 and Table A-3 and Table A-17 for Errormessage
//Version according to which was implemented : Revision 00

//NOTE for diNr.....Designation => 
//_IN = Here Data come in from other Functions or go out to other functions about the GVL
//_OUT = Here Data go out to other functions about the GVL

(*-------------------------------------------------------------Calcualte the number of EM---------------------------------------------------------------*)

fbNumberDevice(
	diActualNumberOfDevices:= Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters, 
	diMaxNumberOfDevices:= Constants_Energy.diMaxNumberOfElectricMeters, 
	udiCounterOnlineChange:= TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, 
	bNumberIsCalculatet=> , 
	bFPNumberIsCalculatet=> , 
	bOnlineChange=> , 
	diNumberForThisDevice=> diNrOfEM_OUT, 
	diNumberOfTotalDevices=> );

//Write new Numer on GVL
IF fbNumberDevice.bFPNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters := fbNumberDevice.diNumberOfTotalDevices;	
END_IF

//Delete old Number on GVL
IF fbNumberDevice.bOnlineChange THEN 
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters := diNrOfEM_OUT;	
		iStateGVLData := 1; 
END_IF

(*-------------------------------------------------------------Service from Backend is ready and check the connection to backen for dissabel/enable Function---------------------------------------------------------------*)

//Try to reset the variable for connection on the GVL. When all is normal then the Lynus Mqtt connection function set this variable to true in the next cycle
//When we have no connection to the backend then after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions days the Function is dissabled with all of his functionalities
timResetConnectionOnGVL(IN:= NOT timResetConnectionOnGVL.Q, PT:= T#1H, Q=> , ET=> );
	IF timResetConnectionOnGVL.Q THEN Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := FALSE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions THEN timDissableFunctions.IN := TRUE; ELSE timDissableFunctions.IN := FALSE; END_IF  
			timDissableFunctions(IN:= , PT:= Lynus_Standards.Constants_General.tTimeDissableLynusFunctions, Q=> , ET=> );

(*------------------------------------------------------------------------------------------State Machine Read---------------------------------------------------------------------------------------------*)

//Start the Statemachine
FPEnable(CLK:= bEnable, Q=> );
	IF FPEnable.Q AND iStateModbusRead = 0 AND iStateModbusRead = 0 AND iStateModbusError = 0 THEN 
			iStateModbusRead := 1; 
	END_IF
		IF NOT bEnable THEN iStateModbusRead := 0; iStateModbusError := 0; END_IF

//Timer for delay
timDelay(IN:= , PT:= T#150MS, Q=> , ET=> );

//Timer for Timeout in Statemachine
IF iStateModbusRead > 0 AND iStateModbusRead <= 2 AND iStateModbusRead = iStateModbus_CP THEN
		timTimeout.IN := TRUE;
ELSE	
		timTimeout.IN := FALSE;
END_IF 
	IF iStateModbusRead = 0 THEN timTimeout.IN := FALSE; END_IF
		timTimeout(IN:= , PT:= T#20S, Q=> , ET=> );			
			
CASE iStateModbusRead OF
	
	0://Init State
		iStateModbus_CP := 0;
			timDelay.IN := FALSE;
				fbMBRead_FC3.bExecute := FALSE;

	1://Read out Table A-2
		iStateModbus_CP := iStateModbusRead;
		
		fbMBRead_FC3.nQuantity := 62;
			fbMBRead_FC3.nMBAddr := 50512;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := byUnitID;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Actual Values from Meter form Table A-2
			fbConvertData(wInputValue_1:= arrBuffer_FC3[3], wInputValue_2:= arrBuffer_FC3[4], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrVoltageL1L2 := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 100;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[5], wInputValue_2:= arrBuffer_FC3[6], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrVoltageL2L3 := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 100;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[7], wInputValue_2:= arrBuffer_FC3[8], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrVoltageL3L1 := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 100;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[9], wInputValue_2:= arrBuffer_FC3[10], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrVoltageL1N := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 100;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[11], wInputValue_2:= arrBuffer_FC3[12], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrVoltageL2N := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 100;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[13], wInputValue_2:= arrBuffer_FC3[14], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrVoltageL3N := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 100;	
			fbConvertData(wInputValue_1:= arrBuffer_FC3[15], wInputValue_2:= arrBuffer_FC3[16], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrFrequency := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 100;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[17], wInputValue_2:= arrBuffer_FC3[18], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrCurrentL1 := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 1000;				
			fbConvertData(wInputValue_1:= arrBuffer_FC3[19], wInputValue_2:= arrBuffer_FC3[20], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrCurrentL2 := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 1000;	
			fbConvertData(wInputValue_1:= arrBuffer_FC3[21], wInputValue_2:= arrBuffer_FC3[22], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrCurrentL3 := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 1000;		
			fbConvertData(wInputValue_1:= arrBuffer_FC3[25], wInputValue_2:= arrBuffer_FC3[26], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrPowerTotal := DINT_TO_LREAL(DWORD_TO_DINT(fbConvertData.dwOutputValue)) / 0.1;		
			fbConvertData(wInputValue_1:= arrBuffer_FC3[27], wInputValue_2:= arrBuffer_FC3[28], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrReactivePowerTotal := DINT_TO_LREAL(DWORD_TO_DINT(fbConvertData.dwOutputValue)) / 0.1;				
			fbConvertData(wInputValue_1:= arrBuffer_FC3[29], wInputValue_2:= arrBuffer_FC3[30], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrApparentPowerTotal := DWORD_TO_LREAL(fbConvertData.dwOutputValue) / 0.1;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[33], wInputValue_2:= arrBuffer_FC3[34], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrPowerL1 := DINT_TO_LREAL(DWORD_TO_DINT(fbConvertData.dwOutputValue)) / 0.1;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[35], wInputValue_2:= arrBuffer_FC3[36], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrPowerL2 := DINT_TO_LREAL(DWORD_TO_DINT(fbConvertData.dwOutputValue)) / 0.1;				
			fbConvertData(wInputValue_1:= arrBuffer_FC3[37], wInputValue_2:= arrBuffer_FC3[38], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrPowerL3 := DINT_TO_LREAL(DWORD_TO_DINT(fbConvertData.dwOutputValue)) / 0.1;	
				
			//Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;
					iStateModbusRead := 2;
		END_IF
		
		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
				iStateModbusRead := - 1;
		END_IF
	
	2://Read out Table A-3
		iStateModbus_CP := iStateModbusRead;
		
		fbMBRead_FC3.nQuantity := 22;
			fbMBRead_FC3.nMBAddr := 50768;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := byUnitID;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Counters from Meter form Table A-3
			fbConvertData(wInputValue_1:= arrBuffer_FC3[3], wInputValue_2:= arrBuffer_FC3[4], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrCounterEnergyT1_Consumption := DWORD_TO_LREAL(fbConvertData.dwOutputValue);
					fbEM.lrTotalCounterEnergy_Consumption := fbEM.lrCounterEnergyT1_Consumption;
			fbConvertData(wInputValue_1:= arrBuffer_FC3[9], wInputValue_2:= arrBuffer_FC3[10], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				fbEM.lrCounterEnergyT1_Production := DWORD_TO_LREAL(fbConvertData.dwOutputValue);
					fbEM.lrTotalCounterEnergy_Production := fbEM.lrCounterEnergyT1_Production;
				
			//Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;
					iStateModbusRead := 3;
		END_IF
		
		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
				iStateModbusRead := - 1;
		END_IF		
		
	3://Read out Table A-17
		iStateModbus_CP := iStateModbusRead;
		
		fbMBRead_FC3.nQuantity := 2;
			fbMBRead_FC3.nMBAddr := 1300;
				fbMBRead_FC3.bExecute := TRUE;
					fbMBRead_FC3.nUnitID := byUnitID;
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Meter Error Message form Table A-17
			fbConvertData(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue=> );
				IF fbConvertData.dwOutputValue <> 0 THEN bErrorFromDevice := TRUE; ELSE bErrorFromDevice := FALSE; END_IF  
				
			//Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;
					iStateModbusRead := 1;
		END_IF
		
		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
				iStateModbusRead := - 1;
		END_IF
		
END_CASE

(*----------------------------------------------------------------------------------------Electric Meter Function----------------------------------------------------------------------------------------------*)

//Error
IF timDissableFunctions.Q THEN fbEM.bWarning := TRUE; fbEM.iWarningCode := 0; ELSE fbEM.bWarning := FALSE; END_IF 
	IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters > Constants_Energy.diMaxNumberOfElectricMeters OR byMBTCPErrorCounter > 10 OR bErrorFromDevice THEN fbEM.bError := TRUE; ELSE fbEM.bError := FALSE; END_IF
		IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfElectricMeters > Constants_Energy.diMaxNumberOfElectricMeters THEN fbEM.iErrorCode := 1;
		ELSIF  byMBTCPErrorCounter > 10 OR bErrorFromDevice THEN fbEM.iErrorCode := 0;
		END_IF

IF iStateModbusRead <> 2 THEN fbEM.bReadOutDataDone := TRUE; ELSE fbEM.bReadOutDataDone := FALSE; END_IF  		
		
//Function
fbEM(
	bEnable:= bEnable AND NOT timDissableFunctions.Q, 
	bError:= , 
	bEnableReadOutFunction:= FALSE, 
	bWriteWithDelay:= TRUE, 
	bPowerDataInvers:= FALSE,
	bReadOutDataDone:= ,
	iTimeReadOutInterval:= 0, 
	iErrorCode:= , 
	iWarningCode:= , 
	lrTotalCounterEnergy_Consumption:= , 
	lrTotalCounterEnergy_Production:= , 
	lrCounterEnergyT1_Consumption:= , 
	lrCounterEnergyT2_Consumption:= 0, 
	lrCounterEnergyT1_Production:= , 
	lrCounterEnergyT2_Production:= 0, 
	lrCurrentL1:= , 
	lrVoltageL1N:= , 
	lrVoltageL1L2:= , 
	lrPowerL1:= , 
	lrCurrentL2:= , 
	lrVoltageL2N:= , 
	lrVoltageL2L3:= , 
	lrPowerL2:= , 
	lrCurrentL3:= , 
	lrVoltageL3N:= , 
	lrVoltageL3L1:= , 
	lrPowerL3:= , 
	lrPowerTotal:= , 
	lrFrequency:= , 
	lrReactivePowerTotal:= , 
	lrApparentPowerTotal:= , 
	tTimDelayOutput:= T#5S, 
	stDataEMOutPower=> stDataEMPowerRealTime, 
	stDataEMOutPowerDelay=> stDataEMPower, 
	stDataEMOutCounter=> stDataEMCounterRealTime,
	stDataEMOutCounterDelay=> stDataEMCounter,
	bReadOutMeter=> );

(*------------------------------------------------------------------------------------------State Machine Error---------------------------------------------------------------------------------------------*)	

CASE iStateModbusError OF
	
	300://Error
		iStateModbus_CP := iStateModbusError;
			timDelay.IN := FALSE;
				fbMBRead_FC3.bExecute := FALSE;
					byMBTCPErrorCounter := byMBTCPErrorCounter + 1;
						byMBTCPErrorCounter := LIMIT(0,byMBTCPErrorCounter,11);
							//Restart from new with the Read out part after an Error
							IF byMBTCPErrorCounter < 10 THEN
								iStateModbusRead := 1;	
									iStateModbusError := 0;
							ELSE
								//Wait here in the Error State for the Delay Timer and then we dont have a Timeout Error
								iStateModbusRead := - 1;
									//Start from New when the Delay is paste
									IF timCloseSocket.Q THEN
										iStateModbusRead := 1;	
											iStateModbusError := 0;
												byMBTCPErrorCounter := 0;
									END_IF
							END_IF
						
END_CASE

//Timer to close the Socket after to much TCP Errors and reopen a new one
timCloseSocket(IN:= byMBTCPErrorCounter > 10 AND bEnable, PT:= T#1M, Q=> , ET=> );

(*------------------------------------------------------------------------------------------Modbus TCP Functions---------------------------------------------------------------------------------------------*)

fbMBRead_FC3(sIPAddr:= sIPAdress, nTCPPort:= 502, nUnitID := byUnitID, cbLength:= SIZEOF(arrBuffer_FC3), pDestAddr:= ADR(arrBuffer_FC3), tTimeout:= T#2S );
	FPError_FC_3(CLK:= fbMBRead_FC3.bError, Q=> );
	
(*-----------------------------------------------------------Handle data to Global structure for Electric Meter-----------------------------------------------------------------*)

CASE iStateGVLData OF
	
	0://Init Step
		byWaitInStep := 0;
			diCounterForGVL := 1;
	
	1://Wait for 4 Steps before clean al Data on GVL
		byWaitInStep := byWaitInStep + 1;
			IF byWaitInStep >= 4 AND fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 2; END_IF
				//To much Devices, back to the Init step
				IF byWaitInStep >= 4 AND NOT fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 0; END_IF	
			
	2://Clear all Data in GVL
		Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].bEnabled := FALSE;	
			Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].byErrorWarning := 0;
				Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrCounterEnergyT1_Consumption := 0;
					Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrCounterEnergyT1_Production := 0;
						Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrCounterEnergyT2_Consumption := 0;
							Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrCounterEnergyT2_Production := 0;
								Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrPower := 0;
									Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrPowerConsumption := 0;
										Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrPowerProduction := 0;
											Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrTotalCounterEnergy_Consumption := 0;
												Lynus_Standards.GVL_Energy.stDataElectricMeters[diCounterForGVL].lrTotalCounterEnergy_Production := 0;
		
		//Electric Meters
		diCounterForGVL := diCounterForGVL + 1;
			diCounterForGVL := LIMIT(0,diCounterForGVL,Constants_Energy.diMaxNumberOfElectricMeters);
				//Back to the init step
				IF diCounterForGVL >= Constants_Energy.diMaxNumberOfElectricMeters THEN iStateGVLData := 0; END_IF

END_CASE 	 

//Write Data on GVL for Electric Meter
IF diNrOfEM_OUT > 0 AND fbNumberDevice.bNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].bEnabled := fbEM.stDataEMOutPower.bEnabled;
		Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].byErrorWarning := fbEM.stDataEMOutPower.byErrorWarning;
			Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrCounterEnergyT1_Consumption := fbEM.stDataEMOutCounter.lrCounterEnergyT1_Consumption;
				Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrCounterEnergyT1_Production := fbEM.stDataEMOutCounter.lrCounterEnergyT1_Production;
					Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrCounterEnergyT2_Consumption := fbEM.stDataEMOutCounter.lrCounterEnergyT2_Consumption;
						Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrCounterEnergyT2_Production := fbEM.stDataEMOutCounter.lrCounterEnergyT2_Production;		
							Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrPower := fbEM.stDataEMOutPower.lrPowerTotal;
								Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrPowerConsumption := fbEM.stDataEMOutPower.lrPowerConsumption;
									Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrPowerProduction := fbEM.stDataEMOutPower.lrPowerProduction;
										Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrTotalCounterEnergy_Consumption := fbEM.stDataEMOutCounter.lrTotalCounterEnergy_Consumption;
											Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_OUT].lrTotalCounterEnergy_Production := fbEM.stDataEMOutCounter.lrTotalCounterEnergy_Production;
END_IF

(*----------------------------------------------------------Save persistent data----------------------------------------------------------------*)

arrPD[1](lrValue:= BOOL_TO_LREAL(bEnable), bEventBasedActive=> );
arrPD[2](lrValue:= BYTE_TO_LREAL(byUnitID), bEventBasedActive=> );
PD_String(sText:= sIPAdress, bEventBasedActive=> );]]></ST>
    </Implementation>
    <LineIds Name="FB_PhoenixContact_EM_EEM_EM375">
      <LineId Id="3" Count="332" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>