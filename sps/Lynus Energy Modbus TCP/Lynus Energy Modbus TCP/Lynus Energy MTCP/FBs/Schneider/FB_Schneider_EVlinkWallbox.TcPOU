<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_Schneider_EVlinkWallbox" Id="{0cc5023b-a58c-4a8a-b57b-78fb7dc61876}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Schneider_EVlinkWallbox
VAR_INPUT PERSISTENT
	bEnable										: BOOL;																			// Enable the Fuctionblock and his logic
	bEnableWrite								: BOOL;																			// Enable Write function 
	bPowerDataInvers							: BOOL;																			//With True its possible to invert all received power data from the electric meter
	byElectricFuseLine							: BYTE; 																		//Electric Fuse Line on wich the ECS is connected => 1 2 3 (If 0 then this charging station is not connected to a Electric Fuse Line)
	rMinCurrent									: REAL:=6;																		// min Current e.g. 6A	max 32A	
	diNrOfEMS_IN								: DINT;																			//Number of EMS what control this Device.
	diNrOfEM_IN_CS								: DINT;																			//Number of the electric meter for incoming power data. (Power Data for this Device)
	sIPAdress									: STRING(15);																	//IP Adress from the charging station
	stSetupECS									: ST_Setup_ECS;																	//{#lynus.ag#()} //Setup charging station
END_VAR
VAR_OUTPUT
	stDataECS									: ST_ECS_Output;																//{#lynus.ag#()} //Electric charging station output data
	diNrOfECS_OUT								: DINT;																			//Active Number from the Electric charging Function for using on other functions
	lrTotalPowerECSRealTime						: LREAL;																		//Total Electric Power in kW read out directly from the Charging station. (Real time)
	stDataElectric								: ST_ElectricMeter_Output_Power;												// Electrict data from the charging station
	str_Mode3State								: STRING(2);																	//Mode 3 State
	bErrorCS									: BOOL;																			//Error State from the charging station
	lrTotalCounterEnergy_Consumption			: LREAL;																		//Energy Counter Consumption in Wh
	bCarConnected								: BOOL;																			// Car Connected

END_VAR
VAR
	{attribute 'hide'}
	fbCS										: FB_ElectricChargingStation;													//Function block for electric charging station
	{attribute 'hide'}
	fbNumberDevice								: FB_NumberOfDevice;															//Function block to calcualte the number of the Device
	{attribute 'hide'}
	fbMBRead_FC3								: FB_MBReadRegs;																//Modbus Read Function (FC3)
	{attribute 'hide'}
	fbMBWrite_FC16								: FB_MBWriteRegs;																//Modbus Write Function (FC16)
	{attribute 'hide'}
	fbConvertWordToByte							: FB_CV_WORD_TO_BYTE;															//Convert Word To Byte
	{attribute 'hide'}
	fbConvertDwordToWord						: FB_CV_DWORD_TO_WORD;															//Convert Dword to Word
	{attribute 'hide'}
	fbConvertWordToDword						: FB_CV_WORD_TO_DWORD;															//Convert Word to Dword
	{attribute 'hide'}
	fbConvertWordToUlint						: FB_CV_WORD_TO_ULINT;															//Convert Word to ULINT
	{attribute 'hide'}
	timDelay									: TON;																			//Timer for Delay between Requests
	{attribute 'hide'}
	timTimeout									: TON;																			//Timer for Timeout
	{attribute 'hide'}
	timDissableFunctions						: TON;																			//Timer to dissable the Function after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days without connection to the Lynus Cloud
	{attribute 'hide'}
	timResetConnectionOnGVL						: TON;																			//Timer to try reset the connection Flag on the GVL. (When somebody delete the Connection Function and make only a onlinechange)
	{attribute 'hide'}
	timChTimeSocket1							: TON;																			//Charging Time for socket 1
	{attribute 'hide'}
	timChTimeSocket2							: TON;																			//Charging Time for socket 2
	{attribute 'hide'}
	timDelayStart								: TON;																			//Timer to start the state machine with Daley after enabling or after the system ist restartet
	{attribute 'hide'}
	FPError_FC_3								: R_TRIG;																		//Internal positive Edge
	{attribute 'hide'}
	FPError_FC_16								: R_TRIG;																		//Internal positive Edge
	{attribute 'hide'}
	FPEnable									: R_TRIG;																		//Internal positive Edge
	{attribute 'hide'}
	stConvertFloat								: ST_UN_FLOAT_CONVERT_DWORD_REAL;												//Convert float
	{attribute 'hide'}
	stConvertFloat2								: ST_UN_FLOAT_CONVERT_ULINT_LREAL;												//Convert float
	{attribute 'hide'}
	arrPD										: ARRAY[1..18] OF FB_PersistentData_Number;										//Function to save persistent data
	{attribute 'hide'}
	fbPDString									: FB_PersistentData_String;														//Function to save persistent string data
	{attribute 'hide'}
	arrBuffer_FC3								: ARRAY[1..30] OF WORD;															//Buffer with Data from FC3
	{attribute 'hide'}
	arrBuffer_FC16								: ARRAY[1..2] OF WORD;															//Buffer with Data from FC16
	{attribute 'hide'}
	bMBTCPError									: BOOL;																			//Modbus TCP Function Error
	{attribute 'hide'}
	byWaitInStep								: BYTE;																			//Wait in Step before start to clean data on PLC
	{attribute 'hide'}
	iStateGVLData								: INT;																			//State machine to handle the data on the GVL
	{attribute 'hide'}
	iStateModbusRead							: INT;																			//State machine for read out Data over Modbus RTU
	{attribute 'hide'}
	iStateModbusWrite							: INT;																			//State machine for write Data over Modbus RTU
	{attribute 'hide'}
	iStateModbusError							: INT;																			//State machine for error out Data over Modbus RTU	
	{attribute 'hide'}
	iStateModbus_CP								: INT;																			//Variable to compare the state machine variable to set or reset the timeout timer
	{attribute 'hide'}
	diNumberOfActiveBatterys					: DINT;																			//Number of active batterys
	{attribute 'hide'}
	diNumberOfBatteryInverterInEPO				: DINT;																			//Number of battery inverters that work in Emergency Power operation 
	{attribute 'hide'}
	diLPForGVL									: DINT;																			//Loop to clean old data on GVL
	{attribute 'hide'}
	diCounterForGVL								: DINT;																			//Counter to clean old data on GVL
	{attribute 'hide'}
	dwSumSOC									: DWORD;																		//Sum of the SOC from all batterys
	{attribute 'hide'}
	lrTotalCounterEnergy_Production				: LREAL;																		//Energy Counter Production in Wh 
	{attribute 'hide'}
	rPowerECS									: REAL;																			//Power from the ECS in kW 
	iSuccessCounterRead							:ARRAY[1..2] OF INT;
	iSuccessCounterWrite						:ARRAY[1..2] OF INT;
END_VAR
VAR PERSISTENT
	{attribute 'conditionalshow'}
	diNrOfEMS_IN_CP								: DINT;																			//Number of EMS what control this Device to compare with the original
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Stefan Lackner
//Company : EfficientIO
//Date : 03.03.2023
//Version : 0.0.0.1

//With this Funcition its possible to communicate with a Schneider EVLink Wallbox over Modbus TCP.
//Its possible to controll the charging station over the charg current
//When the Function send 0 Ampere is switched of, then the charging station is blocked and its not possible to charge
//This Function Block supports Charging stations with maximal 1 sockets

//NOTE for diNr.....Designation => 
//_IN = Here Data come in from other Functions or go out to other functions about the GVL
//_OUT = Here Data go out to other functions about the GVL
(*--------------------------------------------------------------------------------------------Limits-------------------------------------------------------------------------------------*)

diNrOfEMS_IN := LIMIT(0,diNrOfEMS_IN,Constants_Energy.diMaxNumberOfEMS);
diNrOfEM_IN_CS := LIMIT(0,diNrOfEM_IN_CS,Constants_Energy.diMaxNumberOfElectricMeters);
byElectricFuseLine := LIMIT(0,byElectricFuseLine,30);
rMinCurrent	:= LIMIT (0,rMinCurrent,32);


(*------------------------------------------------------------------Power Data----------------------------------------------------------------------------*)

IF diNrOfEM_IN_CS <> 0 THEN
	//Energy Session Input data
	fbCS.bCalculateEnergySession := FALSE;
	IF NOT bPowerDataInvers THEN
		//Energy meter input data for cs Function block
		fbCS.lrCounterEnergyT1_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Production * 1000;
		fbCS.lrCounterEnergyT2_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Production * 1000;
		fbCS.lrCounterEnergyT1_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
		fbCS.lrCounterEnergyT2_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
		fbCS.lrTotalCounterEnergy_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Production * 1000;
		fbCS.lrTotalCounterEnergy_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Consumption * 1000;
		fbCS.lrTotalPowerECS := (Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrPower * 1000) * - 1;
	ELSE
		//Energy meter input data for cs Function block
		fbCS.lrCounterEnergyT1_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
		fbCS.lrCounterEnergyT2_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Consumption * 1000;
		fbCS.lrCounterEnergyT1_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Production * 1000;
		fbCS.lrCounterEnergyT2_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Production * 1000;
		fbCS.lrTotalCounterEnergy_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Consumption * 1000;
		fbCS.lrTotalCounterEnergy_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Production * 1000;
		fbCS.lrTotalPowerECS := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrPower * 1000;
	END_IF
ELSE
	//Energy meter input data for cs Function block
	fbCS.lrCounterEnergyT1_Consumption := lrTotalCounterEnergy_Consumption;
	fbCS.lrCounterEnergyT2_Consumption := 0;
	fbCS.lrCounterEnergyT1_Production := lrTotalCounterEnergy_Production;
	fbCS.lrCounterEnergyT2_Production := 0;
	fbCS.lrTotalCounterEnergy_Consumption := lrTotalCounterEnergy_Consumption;
	fbCS.lrTotalCounterEnergy_Production := lrTotalCounterEnergy_Production;
	fbCS.lrTotalPowerECS := rPowerECS;
	//Energy Session Input data
	fbCS.bCalculateEnergySession := TRUE;
	fbCS.arrSocketPowerECS[1] := rPowerECS;
	fbCS.arrSocketPowerECS[2] := 0;
	fbCS.arrSocketPowerECS[3] := 0;
	fbCS.arrSocketPowerECS[4] := 0;
	fbCS.arrSocketEnergySession[1] := lrTotalCounterEnergy_Consumption;
	fbCS.arrSocketEnergySession[2] := 0;
	fbCS.arrSocketEnergySession[3] := 0;
	fbCS.arrSocketEnergySession[4] := 0;
END_IF			

(*-------------------------------------------------------------Calcualte the number of ECS---------------------------------------------------------------*)

fbNumberDevice(
	diActualNumberOfDevices:= Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS, 
	diMaxNumberOfDevices:= Constants_Energy.diMaxNumberOfElectricChargingStations, 
	udiCounterOnlineChange:= TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, 
	bNumberIsCalculatet=> , 
	bFPNumberIsCalculatet=> , 
	bOnlineChange=> , 
	diNumberForThisDevice=> diNrOfECS_OUT, 
	diNumberOfTotalDevices=> );

//Write new Numer on GVL
IF fbNumberDevice.bFPNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS := fbNumberDevice.diNumberOfTotalDevices;	
END_IF 

//Delete old Number on GVL
IF fbNumberDevice.bOnlineChange THEN 
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS := diNrOfECS_OUT;	
		iStateGVLData := 1;
END_IF

(*-------------------------------------------------------------Service from Backend is ready and check the connection to backen for dissabel/enable Function---------------------------------------------------------------*)

//Try to reset the variable for connection on the GVL. When all is normal then the Lynus Mqtt connection function set this variable to true in the next cycle
//When we have no connection to the backend then after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions days the Function is dissabled with all of his functionalities
timResetConnectionOnGVL(IN:= NOT timResetConnectionOnGVL.Q, PT:= T#1H, Q=> , ET=> );
IF timResetConnectionOnGVL.Q THEN Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := FALSE; END_IF
IF NOT Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions THEN timDissableFunctions.IN := TRUE; ELSE timDissableFunctions.IN := FALSE; END_IF  
timDissableFunctions(IN:= , PT:= Lynus_Standards.Constants_General.tTimeDissableLynusFunctions, Q=> , ET=> );
			
(*--------------------------------------------------------------------------------------------State Machine Read--------------------------------------------------------------------------------------*)

//Timer for Delay
timDelay(IN:= , PT:= T#350MS, Q=> , ET=> );

//Timer for Timeout in Statemachine
IF (iStateModbusRead > 0 AND iStateModbusRead <= 5 AND iStateModbusRead = iStateModbus_CP) OR
	(iStateModbusWrite > 0 AND iStateModbusWrite <= 2 AND iStateModbusWrite = iStateModbus_CP) 
THEN
	timTimeout.IN := TRUE;
ELSE	
	timTimeout.IN := FALSE;
END_IF
//Timeout Timer is dissabled when the Init Step is aktiv or the function is not enabled
IF (iStateModbusRead = 0 AND iStateModbusWrite = 0) OR NOT bEnable THEN timTimeout.IN := FALSE; END_IF
timTimeout(IN:= , PT:= T#10S, Q=> , ET=> );

//Enable with Delay that not all sockets have to be created at the same time
timDelayStart(IN:= bEnable, PT:= T#20MS * diNrOfECS_OUT, Q=> , ET=> );
FPEnable(CLK:= timDelayStart.Q, Q=> );

IF FPEnable.Q AND iStateModbusRead = 0 AND iStateModbusWrite = 0 THEN iStateModbusRead := 1; END_IF		
		
//Not Enabled
IF NOT bEnable THEN iStateModbusRead := 0; iStateModbusError := 0; iStateModbusWrite := 0; END_IF		
		
CASE iStateModbusRead OF

	0://Init Step 
		iStateModbus_CP := 0;
		timDelay.IN := FALSE;
		fbMBRead_FC3.bExecute := FALSE;
		fbMBWrite_FC16.bExecute := FALSE;
		rPowerECS := 0;	
		str_Mode3State := ''; 
		
	1://Read Out the mode 3 State from the charging station (Register 6)
		iStateModbus_CP := iStateModbusRead;
		
		//Reset Write
		fbMBWrite_FC16.bExecute := FALSE;
		
		//Start Read
		fbMBRead_FC3.nQuantity := 6;
		fbMBRead_FC3.nMBAddr := 1;
		fbMBRead_FC3.bExecute := TRUE;
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Mode 3 state
			// fbConvertWordToByte(wInputValue:= arrBuffer_FC3[6], eByteOrderForConvert:= eByteOrder.eBigEndian, byOutputValue_1=> , byOutputValue_2=> );
			CASE arrBuffer_FC3[6] OF   // fbConvertWordToByte.byOutputValue_1
				0:	str_Mode3State:='F';		// 0 – Electric Vehicle Supply Equipment not available - state F
				1:	str_Mode3State:='A';		// 1 - Electric Vehicle Supply Equipment available - state A
				2:	str_Mode3State:='A+';		// 2 - Plug detected - state A+
				3:	str_Mode3State:='??';		// 
				4:	str_Mode3State:='B';		// 4 - EV connected – state B
				5:	str_Mode3State:='C-';		// 5 - EV connected – state C-
				6:	str_Mode3State:='D-';		// 6 - EV connected, ventilation required – state D-
				7:	str_Mode3State:='B+';		// 7 - Electric Vehicle Supply Equipment ready - state B+
				8:	str_Mode3State:='C';		// 8 - EV ready - state C
				9:	str_Mode3State:='C+';		// 9 - Charging EV - state C+
				10:	str_Mode3State:='D';		// 10 - EV ready, ventilation required - state D
				11:	str_Mode3State:='D+';		// 11 - Charging EV, ventilation required - state D+
				12:	str_Mode3State:='St';		// 12 - Stop charging
				13:	str_Mode3State:='Al';		// 13 – Alarm
				14:	str_Mode3State:='E';		// 14 - Shortcut – state E
				15:	str_Mode3State:='Co';		// 15 - Digital Com by Electric Vehicle Supply Equipment state
			END_CASE
			iSuccessCounterRead[iStateModbusRead]:=iSuccessCounterRead[iStateModbusRead]+1;
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
			timDelay.IN := FALSE;		
			iStateModbusRead := 2;
		END_IF	
	
		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF
			
	2://Power Data  (Register 350 - 370)
		iStateModbus_CP := iStateModbusRead;
		
		//Start Read
		fbMBRead_FC3.nQuantity := 24;
		fbMBRead_FC3.nMBAddr := 350;
		fbMBRead_FC3.bExecute := TRUE;
		
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
			
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
	
			// current phase 1
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.bEnabled:=TRUE;			
			stDataElectric.lrCurrentL1:=REAL_TO_LREAL(stConvertFloat.rValueFloat);
			// current phase 2
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[3], wInputValue_2:= arrBuffer_FC3[4], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.lrCurrentL2:=REAL_TO_LREAL(stConvertFloat.rValueFloat);
			// current phase 3
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[5], wInputValue_2:= arrBuffer_FC3[6], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.lrCurrentL3:=REAL_TO_LREAL(stConvertFloat.rValueFloat);
			//energy in Wh
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[7], wInputValue_2:= arrBuffer_FC3[8], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			
			lrTotalCounterEnergy_Consumption := DWORD_TO_LREAL(fbConvertWordToDword.dwOutputValue);
			//Power Data in kW
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[9], wInputValue_2:= arrBuffer_FC3[10], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			rPowerECS := INT_TO_REAL(REAL_TO_INT(stConvertFloat.rValueFloat*10))/10;
			stDataElectric.bEnabled:=TRUE;
			stDataElectric.lrPowerTotal:=REAL_TO_LREAL(rPowerECS);
			// voltage phase 1 - phase 2
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[11], wInputValue_2:= arrBuffer_FC3[12], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.lrVoltageL1L2:=REAL_TO_LREAL(stConvertFloat.rValueFloat);			
			// voltage phase 2 - phase 3
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[13], wInputValue_2:= arrBuffer_FC3[14], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.lrVoltageL2L3:=REAL_TO_LREAL(stConvertFloat.rValueFloat);			
			// voltage phase 3 - phase 1
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[15], wInputValue_2:= arrBuffer_FC3[16], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.lrVoltageL3L1:=REAL_TO_LREAL(stConvertFloat.rValueFloat);			
			// voltage phase 1 - Neutral
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[17], wInputValue_2:= arrBuffer_FC3[18], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.lrVoltageL1N:=REAL_TO_LREAL(stConvertFloat.rValueFloat);			
			// voltage phase 2 - Neutral
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[19], wInputValue_2:= arrBuffer_FC3[20], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.lrVoltageL2N:=REAL_TO_LREAL(stConvertFloat.rValueFloat);		
			// voltage phase 3 - Neutral
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[21], wInputValue_2:= arrBuffer_FC3[22], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
			stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
			stDataElectric.lrVoltageL3N:=REAL_TO_LREAL(stConvertFloat.rValueFloat);					
			
			(*
			350	StationMeter Phase1Current_I1	word
			352	StationMeter Phase2Current_I2	word
			354	StationMeter Phase3Current_I3	word
			356	StationMeter ActiveEnergy	word  [Ws]
			358	StationMeter ActivePowerTotal	word
			360	StationMeter L1_L2 Voltage	word
			362	StationMeter L2_L3 Voltage	word
			364	StationMeter L3_L1 Voltage	word
			366	StationMeter L1_N Voltage	word
			368	StationMeter L2_N Voltage	word
			370	StationMeter L3_N Voltage	word
			*)
	
			iSuccessCounterRead[iStateModbusRead]:=iSuccessCounterRead[iStateModbusRead]+1;
			
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
			timDelay.IN := FALSE;		
			iStateModbusRead := 5;
		END_IF	
	
		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF
			
		
	5://Wait 1 Step to reset the delay counter befor start to write
		iStateModbus_CP := iStateModbusRead;
		IF bEnableWrite THEN 	
			iStateModbusWrite := 1;
			//-1 because 0 is the Init Step for Read
			iStateModbusRead := - 1;
		ELSE
			iStateModbusRead := 1;
			iStateModbusWrite := 0;		
		END_IF
		//Error on Master, changes on Inputs or Timeout
		IF timTimeout.Q THEN 
			iStateModbusError := 300;	 
		END_IF
END_CASE


(*------------------------------------------------------------------Error and Warning----------------------------------------------------------------------------*)	
 
IF str_Mode3State = 'A1' THEN bErrorCS := TRUE; ELSE bErrorCS := FALSE; END_IF  

IF timDissableFunctions.Q THEN fbCS.bWarning := TRUE; fbCS.iWarningCode := 0; ELSE fbCS.bWarning := FALSE; END_IF   
IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS > Constants_Energy.diMaxNumberOfElectricChargingStations OR bErrorCS OR bMBTCPError THEN 
	fbCS.bError := TRUE;
ELSE 
	fbCS.bError := FALSE;
	fbCS.iErrorCode := 0;
END_IF

IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS > Constants_Energy.diMaxNumberOfElectricChargingStations THEN fbCS.iErrorCode := 1;
ELSIF bErrorCS OR bMBTCPError THEN fbCS.iErrorCode := 0; END_IF

(*------------------------------------------------------------------Logic----------------------------------------------------------------------------*)


//Car connected to the ECS  
IF  str_Mode3State = 'B' OR str_Mode3State = 'C-' OR str_Mode3State = 'D-' OR str_Mode3State = 'C' OR str_Mode3State = 'C+' OR str_Mode3State = 'D' OR str_Mode3State = 'D+' THEN 
	fbCS.bCarConnected := TRUE; 
	bCarConnected := TRUE;
ELSE 
	fbCS.bCarConnected := FALSE;
	bCarConnected := FALSE; 
END_IF 

//Min Current
fbCS.rMinCurrent := rMinCurrent;

//Charging time
IF str_Mode3State = 'C+' OR str_Mode3State = 'D+' THEN timChTimeSocket1.IN := TRUE; ELSE timChTimeSocket1.IN := FALSE; END_IF


IF timChTimeSocket1.IN THEN fbCS.arrSocketChargingTimeInput[1] := TIME_TO_REAL(timChTimeSocket1.ET) / 60000; END_IF
fbCS.arrSocketChargingTimeInput[2] := 0;
fbCS.arrSocketChargingTimeInput[3] := 0;
fbCS.arrSocketChargingTimeInput[4] := 0;

timChTimeSocket1(IN:= , PT:= T#24H, Q=> , ET=> );


//Mode 3 State
fbCS.arrSocketMode3StateECS[1] := str_Mode3State;
fbCS.arrSocketMode3StateECS[2] := '';
fbCS.arrSocketMode3StateECS[3] := '';
fbCS.arrSocketMode3StateECS[4] := '';

//SOC Car
fbCS.arrSOCCar[1] := 0;
fbCS.arrSOCCar[2] := 0;
fbCS.arrSOCCar[3] := 0;
fbCS.arrSOCCar[4] := 0;

//Functionblock ECS
fbCS(
	bEnable:= bEnable AND NOT timDissableFunctions.Q, 
	bError:= ,
	bWarning := ,
	bEPOIsActive:= , 
	bExternalLock:= , 
	bCarConnected:= , 
	bWriteWithDelay:= TRUE, 
	bCalculateEnergySession:= ,
	iErrorCode:= , 
	iWarningCode:= , 
	arrSocketChargingTimeInput:= ,
	arrSOCCar:= , 
	dwBatterySOC:= 100, 
	lrTotalCounterEnergy_Consumption:= , 
	lrTotalCounterEnergy_Production:= , 
	lrCounterEnergyT1_Consumption:= , 
	lrCounterEnergyT2_Consumption:= , 
	lrCounterEnergyT1_Production:= , 
	lrCounterEnergyT2_Production:= , 
	lrTotalPowerECS:= , 
	arrSocketEnergySession:= ,
	rTargetPower:= Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].rTargetPowerEMS, 
	rSupplyVoltage:= 692, 
	rMinCurrent:= , 
	tTimDelayOutput:= T#5S, 
	tDelayError:= T#5S,
	arrSocketMode3StateECS:= ,
	arrSocketPowerECS:= ,
	stSetupECS:= stSetupECS, 
	stDataECSOut=> , 
	stDataECSOutDelay=> stDataECS);

//Real time Power for Output
lrTotalPowerECSRealTime := fbCS.stDataECSOut.lrTotalPower;
	
(*------------------------------------------------------------------------------------------State Machine Write---------------------------------------------------------------------------------------------*)	

CASE iStateModbusWrite OF	

	1://Set the charging current (Reg 301)
		iStateModbus_CP := iStateModbusWrite;
		
		fbMBWrite_FC16.nQuantity := 1;
		fbMBWrite_FC16.nMBAddr := 301;
		fbMBWrite_FC16.bExecute := TRUE;
		
		//Prepear the sending Data. Charging power 0..100%
		IF fbCS.stDataECSOut.rTargetPower >= 0 AND fbCS.stDataECSOut.rTargetPower <= 100 THEN 
			arrBuffer_FC16[1] := REAL_TO_WORD(fbCS.stDataECSOut.rTargetChargeCurrent);	 				
		END_IF
		IF fbMBWrite_FC16.bBusy THEN timDelay.IN := TRUE; END_IF

		//Wait for Delay and then next step
		IF NOT fbMBWrite_FC16.bBusy AND NOT fbMBWrite_FC16.bError AND timDelay.Q THEN
			fbMBWrite_FC16.bExecute := FALSE;
			timDelay.IN := FALSE;
			bMBTCPError := FALSE; 
			iSuccessCounterWrite[iStateModbusWrite]:=iSuccessCounterWrite[iStateModbusWrite]+1;
			iStateModbusWrite := 2;
		END_IF
				
		//Error or Timout
		IF FPError_FC_16.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF		
	2:	// write Livebit (1) to register 932	
		iStateModbus_CP := iStateModbusWrite;
		
		fbMBWrite_FC16.nQuantity := 1;
		fbMBWrite_FC16.nMBAddr := 932;
		fbMBWrite_FC16.bExecute := TRUE;
		
		//Prepear the sending Data. Allways write 1 into the regiseter 
		arrBuffer_FC16[1]:=1;
						
		
		IF fbMBWrite_FC16.bBusy THEN timDelay.IN := TRUE; END_IF

		//Wait for Delay and then next step
		IF NOT fbMBWrite_FC16.bBusy AND NOT fbMBWrite_FC16.bError AND timDelay.Q THEN
			fbMBWrite_FC16.bExecute := FALSE;
			timDelay.IN := FALSE;
			bMBTCPError := FALSE; 
			iSuccessCounterWrite[iStateModbusWrite]:=iSuccessCounterWrite[iStateModbusWrite]+1;
			//Restart from new with the Read out part
			iStateModbusRead := 1;
			iStateModbusWrite := 0;
		END_IF
		//Error or Timout
		IF FPError_FC_16.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF		
		
END_CASE	
	
(*------------------------------------------------------------------------------------------State Machine Error---------------------------------------------------------------------------------------------*)	

CASE iStateModbusError OF
	
	300://Error
		iStateModbus_CP := iStateModbusError;
		timDelay.IN := FALSE;
		fbMBRead_FC3.bExecute := FALSE;
		fbMBWrite_FC16.bExecute := FALSE;
		bMBTCPError := TRUE; 		
		//Restart from new with the Read out part after an Error
		iStateModbusRead := 1;	
		iStateModbusError := 0;
		iStateModbusWrite := 0;
						
END_CASE

(*------------------------------------------------------------------------------------------Modbus TCP Functions---------------------------------------------------------------------------------------------*)

fbMBRead_FC3(	sIPAddr:= sIPAdress, 
				nTCPPort:= 502,
				cbLength:= SIZEOF(arrBuffer_FC3), 
				pDestAddr:= ADR(arrBuffer_FC3), 
				tTimeout:= T#5S );

FPError_FC_3(CLK:= fbMBRead_FC3.bError, Q=> );		

fbMBWrite_FC16(	sIPAddr:= sIPAdress, 
				nTCPPort:= 502, 
				cbLength:= SIZEOF(arrBuffer_FC16), 
				pSrcAddr:= ADR(arrBuffer_FC16), 
				tTimeout:= T#5S);	

FPError_FC_16(CLK:= fbMBWrite_FC16.bError, Q=> );

(*-----------------------------------------------------------Handle data to Global structure for electric charging stations-----------------------------------------------------------------*)

//Delte al old Data on GVL after a online change or change on the variable diNrOfEMS_IDOD
IF diNrOfEMS_IN <> diNrOfEMS_IN_CP AND iStateGVLData = 0 THEN iStateGVLData := 10; END_IF 

CASE iStateGVLData OF
	
	0://Init Step
		byWaitInStep := 0;
		diCounterForGVL := 1;
	
	1://Wait for 4 Steps before clean al Data on GVL
		byWaitInStep := byWaitInStep + 1;
		IF byWaitInStep >= 4 AND fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 2; END_IF
		//To much Devices, back to the Init step
		IF byWaitInStep >= 4 AND NOT fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 0; END_IF	
			
	2://Clear all Data in GVL
		FOR diLPForGVL := 1 TO Constants_Energy.diMaxNumberOfEMS BY 1 DO 
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].bEnabled := FALSE;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].bIsControllable := FALSE;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byErrorWarning := 0;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byPriority := 0;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPower := 0;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPowerConsumption := 0;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPowerProduction := 0;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].rMaxPower := 0;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byElectricFuseLine := 0;
			//Set also the target value from ems back here to 0 and not in EMS function because EMS is in Standy when we have a online change (Problem when we delete a ems function and make a online change)
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].rTargetPowerEMS := 0;	
		END_FOR
		
		//Counter for ECS
		diCounterForGVL := diCounterForGVL + 1;
		diCounterForGVL := LIMIT(0,diCounterForGVL,Constants_Energy.diMaxNumberOfElectricChargingStations);
		//Back to the init step
		IF diCounterForGVL >= Constants_Energy.diMaxNumberOfElectricChargingStations THEN iStateGVLData := 0; END_IF

	10://Clear old Data on GVL 		
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].bEnabled := FALSE;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].bIsControllable := FALSE;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byErrorWarning := 0;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byPriority := 0;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPower := 0;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPowerConsumption := 0;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPowerProduction := 0;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].rMaxPower := 0;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byElectricFuseLine := 0;
									
		diNrOfEMS_IN_CP := diNrOfEMS_IN;
		//Back to the init step
		iStateGVLData := 0;

END_CASE 	 

IF diNrOfECS_OUT > 0 AND fbNumberDevice.bNumberIsCalculatet AND diNrOfEMS_IN > 0 THEN
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].bEnabled := fbCS.stDataECSOut.bEnabled;
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].bIsControllable := TRUE;
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byErrorWarning := fbCS.stDataECSOut.byErrorWarning;
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byPriority := fbCS.stDataECSOut.byPriority;
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPower := fbCS.stDataECSOut.lrTotalPower;
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPowerConsumption := fbCS.stDataECSOut.lrTotalPowerConsumption;
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPowerProduction := fbCS.stDataECSOut.lrTotalPowerProduction;
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].rMaxPower := fbCS.stDataECSOut.rMaxPower;	
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byElectricFuseLine := byElectricFuseLine;
END_IF 

(*----------------------------------------------------------Save persistent data----------------------------------------------------------------*)

arrPD[1](lrValue:= BOOL_TO_LREAL(bEnable), bEventBasedActive=> );
arrPD[2](lrValue:= BOOL_TO_LREAL(bPowerDataInvers), bEventBasedActive=> );
arrPD[3](lrValue:= DINT_TO_LREAL(diNrOfEMS_IN), bEventBasedActive=> );
arrPD[4](lrValue:= DINT_TO_LREAL(diNrOfEM_IN_CS), bEventBasedActive=> );
arrPD[5](lrValue:= BOOL_TO_LREAL(stSetupECS.bManualyOn), bEventBasedActive=> );
arrPD[6](lrValue:= BOOL_TO_LREAL(stSetupECS.bOnEmergPowerOff), bEventBasedActive=> );
arrPD[7](lrValue:= BYTE_TO_LREAL(stSetupECS.byCSMinPower), bEventBasedActive=> );
arrPD[8](lrValue:= BYTE_TO_LREAL(stSetupECS.byDisableSOC), bEventBasedActive=> );
arrPD[9](lrValue:= BYTE_TO_LREAL(stSetupECS.byEnableSOC), bEventBasedActive=> );
arrPD[10](lrValue:= BYTE_TO_LREAL(stSetupECS.byManualyTargetPower), bEventBasedActive=> );
arrPD[11](lrValue:= BYTE_TO_LREAL(stSetupECS.byPriority), bEventBasedActive=> );
arrPD[12](lrValue:= REAL_TO_LREAL(stSetupECS.rMaxPower), bEventBasedActive=> );
arrPD[13](lrValue:= DINT_TO_LREAL(diNrOfEMS_IN_CP), bEventBasedActive=> );
arrPD[14](lrValue:= BYTE_TO_LREAL(byElectricFuseLine), bEventBasedActive=> );
fbPDString(sText:= sIPAdress, bEventBasedActive=> );
]]></ST>
    </Implementation>
    <LineIds Name="FB_Schneider_EVlinkWallbox">
      <LineId Id="4710" Count="555" />
      <LineId Id="1079" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>