<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_ECS_Alfen_NG9xx_Platform" Id="{5cd4d295-a4f7-4024-8bb0-3c9a9a2b6b62}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ECS_Alfen_NG9xx_Platform
VAR_INPUT PERSISTENT
	bEnable										: BOOL;																			//{#lynus.ag#()} //Enable the Fuctionblock and his logic
	bPowerDataInvers							: BOOL;																			//With True its possible to invert all received power data from the electric meter
	byElectricFuseLine							: BYTE; 																		//Electric Fuse Line on wich the ECS is connected => 1 2 3 (If 0 then this charging station is not connected to a Electric Fuse Line)
	byUnitID_Socket1							: BYTE;																			//Unit ID for Socket 1
	byUnitID_Socket2							: BYTE;																			//Unit ID for Socket 2
	byNumberOfSockets							: BYTE;																			//Give information about the number of sockets. (max 2,  min 1)
	byNumberOfConnectionWire					: BYTE;																			//Give a information about the Number of Connection Wires to the charging station. (max 2,  min 1)
	diNrOfEMS_IN								: DINT;																			//Number of EMS what control this Device.
	diNrOfEM_IN_CS								: DINT;																			//Number of the electric meter for incoming power data. (Power Data for this Device)
	sIPAdress									: STRING(15);																	//IP Adress from the Alfen charging station
	stSetupECS									: ST_Setup_ECS;																	//{#lynus.ag#()} //Setup charging station
END_VAR
VAR_OUTPUT
	stDataECS									: ST_ECS_Output;																//{#lynus.ag#()} //Electric charging station output data
	diNrOfECS_OUT								: DINT;																			//Active Number from the Electric charging Function for using on other functions
	lrTotalPowerECSRealTime						: LREAL;																		//Total Electric Power in kW read out directly from the Charging station. (Real time)
END_VAR
VAR
	{attribute 'hide'}
	fbCS										: FB_ElectricChargingStation;													//Function block for electric charging station
	{attribute 'hide'}
	fbNumberDevice								: FB_NumberOfDevice;															//Function block to calcualte the number of the Device
	fbDIExternalLock							: FB_XL1XXX_DI;																	//Digital Input from external loock signal
	{attribute 'hide'}
	fbMBRead_FC3								: FB_MBReadRegs;																//Modbus Read Function (FC3)
	{attribute 'hide'}
	fbMBWrite_FC16								: FB_MBWriteRegs;																//Modbus Write Function (FC16)
	{attribute 'hide'}
	fbConvertWordToByte							: FB_CV_WORD_TO_BYTE;															//Convert Word To Byte
	{attribute 'hide'}
	fbConvertDwordToWord						: FB_CV_DWORD_TO_WORD;															//Convert Dword to Word
	{attribute 'hide'}
	fbConvertWordToDword						: FB_CV_WORD_TO_DWORD;															//Convert Word to Dword
	{attribute 'hide'}
	fbConvertWordToUlint						: FB_CV_WORD_TO_ULINT;															//Convert Word to ULINT
	{attribute 'hide'}
	timDelay									: TON;																			//Timer for Delay between Requests
	{attribute 'hide'}
	timTimeout									: TON;																			//Timer for Timeout
	{attribute 'hide'}
	timDissableFunctions						: TON;																			//Timer to dissable the Function after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days without connection to the Lynus Cloud
	{attribute 'hide'}
	timResetConnectionOnGVL						: TON;																			//Timer to try reset the connection Flag on the GVL. (When somebody delete the Connection Function and make only a onlinechange)
	{attribute 'hide'}
	timChTimeSocket1							: TON;																			//Charging Time for socket 1
	{attribute 'hide'}
	timChTimeSocket2							: TON;																			//Charging Time for socket 2
	{attribute 'hide'}
	timDelayStart								: TON;																			//Timer to start the state machine with Daley after enabling or after the system ist restartet
	{attribute 'hide'}
	FPError_FC_3								: R_TRIG;																		//Internal positive Edge
	{attribute 'hide'}
	FPError_FC_16								: R_TRIG;																		//Internal positive Edge
	{attribute 'hide'}
	FPEnable									: R_TRIG;																		//Internal positive Edge
	{attribute 'hide'}
	stConvertFloat								: ST_UN_FLOAT_CONVERT_DWORD_REAL;												//Convert float
	{attribute 'hide'}
	stConvertFloat2								: ST_UN_FLOAT_CONVERT_ULINT_LREAL;												//Convert float
	{attribute 'hide'}
	arrPD										: ARRAY[1..18] OF FB_PersistentData_Number;										//Function to save persistent data
	{attribute 'hide'}
	fbPDString									: FB_PersistentData_String;														//Function to save persistent string data
	{attribute 'hide'}
	arrBuffer_FC3								: ARRAY[1..5] OF WORD;															//Buffer with Data from FC3
	{attribute 'hide'}
	arrBuffer_FC16								: ARRAY[1..2] OF WORD;															//Buffer with Data from FC16
	{attribute 'hide'}
	arrMode3State								: ARRAY[1..2] OF STRING(2);														//Mode 3 State
	{attribute 'hide'}
	bErrorCS									: BOOL;																			//Error State from the charging station
	{attribute 'hide'}
	bMBTCPError									: BOOL;																			//Modbus TCP Function Error
	{attribute 'hide'}
	bySocketInProgress							: BYTE;																			//Shows the Socket in Progress when we have more then 1 Socket																		
	{attribute 'hide'}
	byWaitInStep								: BYTE;																			//Wait in Step before start to clean data on PLC
	{attribute 'hide'}
	iStateGVLData								: INT;																			//State machine to handle the data on the GVL
	{attribute 'hide'}
	iStateModbusRead							: INT;																			//State machine for read out Data over Modbus RTU
	{attribute 'hide'}
	iStateModbusWrite							: INT;																			//State machine for write Data over Modbus RTU
	{attribute 'hide'}
	iStateModbusError							: INT;																			//State machine for error out Data over Modbus RTU	
	{attribute 'hide'}
	iStateModbus_CP								: INT;																			//Variable to compare the state machine variable to set or reset the timeout timer
	{attribute 'hide'}
	diNumberOfActiveBatterys					: DINT;																			//Number of active batterys
	{attribute 'hide'}
	diNumberOfBatteryInverterInEPO				: DINT;																			//Number of battery inverters that work in Emergency Power operation 
	{attribute 'hide'}
	diLPForGVL									: DINT;																			//Loop to clean old data on GVL
	{attribute 'hide'}
	diCounterForGVL								: DINT;																			//Counter to clean old data on GVL
	{attribute 'hide'}
	dwSumSOC									: DWORD;																		//Sum of the SOC from all batterys
	{attribute 'hide'}
	lrTotalCounterEnergy_Consumption_S1			: LREAL;																		//Energy Counter Consumption in Wh Socket 1
	{attribute 'hide'}
	lrTotalCounterEnergy_Consumption_S2			: LREAL;																		//Energy Counter Consumption in Wh Socket 2
	{attribute 'hide'}
	lrTotalCounterEnergy_Production_S1			: LREAL;																		//Energy Counter Production in Wh Socket 1
	{attribute 'hide'}
	lrTotalCounterEnergy_Production_S2			: LREAL;																		//Energy Counter Production in Wh Socket 2
	{attribute 'hide'}
	rPowerECS_S1								: REAL;																			//Power from the ECS in W Socket 1
	{attribute 'hide'}
	rPowerECS_S2								: REAL;																			//Power from the ECS in W Socket 2
	{attribute 'hide'}	
	liLPBatteryData								: LINT;																			//Loop to check some data from batterys
	{attribute 'hide'}
	liLPInEPO									: LINT;																			//Loop to check if 1 or more battery inverters build a island grid
END_VAR
VAR PERSISTENT
	{attribute 'conditionalshow'}
	diNrOfEMS_IN_CP								: DINT;																			//Number of EMS what control this Device to compare with the original
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Kai Ebensperger
//Company : Lynus AG
//Date : 04.10.2021
//Version : 1.0.0.0

//With this Funcition its possible to communicate with a Alfen Electric charging station from the NG9xx Platform over Modbus TCP.
//Its possible to controll the charging station over the charg current
//When the Function send 0 Ampere is switched of, then the charging station is blocked and its not possible to charge
//This Function Block supports Charging stations with maximal 2 sockets
//This function controll to the charging station with 2 sockets the current / 2
//When we have 2 Connection Wires and 2 sockets on the charging station, than the function send the full current. Attention : Then on the max Power must be Insert the maxpower in kW * 2

//Versions that are supported : 2.3 Date : 30.10.2020

//NOTE for diNr.....Designation => 
//_IN = Here Data come in from other Functions or go out to other functions about the GVL
//_OUT = Here Data go out to other functions about the GVL

(*--------------------------------------------------------------------------------------------Limits-------------------------------------------------------------------------------------*)

byNumberOfSockets := LIMIT(1,byNumberOfSockets,2);
	byNumberOfConnectionWire := LIMIT(1,byNumberOfConnectionWire,2);
		diNrOfEMS_IN := LIMIT(0,diNrOfEMS_IN,Constants_Energy.diMaxNumberOfEMS);
			diNrOfEM_IN_CS := LIMIT(0,diNrOfEM_IN_CS,Constants_Energy.diMaxNumberOfElectricMeters);
				byUnitID_Socket1 := LIMIT(1,byUnitID_Socket1,1);
					byUnitID_Socket2 := LIMIT(2,byUnitID_Socket2,2);
						byElectricFuseLine := LIMIT(0,byElectricFuseLine,30);

(*------------------------------------------------------------------Power Data----------------------------------------------------------------------------*)

IF diNrOfEM_IN_CS <> 0 THEN
	//Energy Session Input data
	fbCS.bCalculateEnergySession := FALSE;
	fbCS.arrSocketPowerECS[1] := 0;
	fbCS.arrSocketPowerECS[2] := 0;
	fbCS.arrSocketPowerECS[3] := 0;
	fbCS.arrSocketPowerECS[4] := 0;
	fbCS.arrSocketEnergySession[1] := 0;
	fbCS.arrSocketEnergySession[2] := 0;
	fbCS.arrSocketEnergySession[3] := 0;
	fbCS.arrSocketEnergySession[4] := 0;
		IF NOT bPowerDataInvers THEN
			//Energy meter input data for cs Function block
			fbCS.lrCounterEnergyT1_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Production * 1000;
			fbCS.lrCounterEnergyT2_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Production * 1000;
			fbCS.lrCounterEnergyT1_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
			fbCS.lrCounterEnergyT2_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
			fbCS.lrTotalCounterEnergy_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Production * 1000;
			fbCS.lrTotalCounterEnergy_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Consumption * 1000;
				fbCS.lrTotalPowerECS := (Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrPower * 1000) * - 1;
			ELSE
			//Energy meter input data for cs Function block
			fbCS.lrCounterEnergyT1_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Consumption * 1000;
			fbCS.lrCounterEnergyT2_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Consumption * 1000;
			fbCS.lrCounterEnergyT1_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT1_Production * 1000;
			fbCS.lrCounterEnergyT2_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrCounterEnergyT2_Production * 1000;
			fbCS.lrTotalCounterEnergy_Consumption := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Consumption * 1000;
			fbCS.lrTotalCounterEnergy_Production := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrTotalCounterEnergy_Production * 1000;
				fbCS.lrTotalPowerECS := Lynus_Standards.GVL_Energy.stDataElectricMeters[diNrOfEM_IN_CS].lrPower * 1000;
		END_IF
ELSE
	//Energy meter input data for cs Function block
	fbCS.lrCounterEnergyT1_Consumption := lrTotalCounterEnergy_Consumption_S1 + lrTotalCounterEnergy_Consumption_S2;
	fbCS.lrCounterEnergyT2_Consumption := 0;
	fbCS.lrCounterEnergyT1_Production := lrTotalCounterEnergy_Production_S1 + lrTotalCounterEnergy_Production_S2;
	fbCS.lrCounterEnergyT2_Production := 0;
	fbCS.lrTotalCounterEnergy_Consumption := lrTotalCounterEnergy_Consumption_S1 + lrTotalCounterEnergy_Consumption_S2;
	fbCS.lrTotalCounterEnergy_Production := lrTotalCounterEnergy_Production_S1 + lrTotalCounterEnergy_Production_S2;
		fbCS.lrTotalPowerECS := rPowerECS_S1 + rPowerECS_S2;
	//Energy Session Input data
	fbCS.bCalculateEnergySession := TRUE;
	fbCS.arrSocketPowerECS[1] := rPowerECS_S1;
	fbCS.arrSocketPowerECS[2] := rPowerECS_S2;
	fbCS.arrSocketPowerECS[3] := 0;
	fbCS.arrSocketPowerECS[4] := 0;
	fbCS.arrSocketEnergySession[1] := lrTotalCounterEnergy_Consumption_S1;
	fbCS.arrSocketEnergySession[2] := lrTotalCounterEnergy_Consumption_S2;
	fbCS.arrSocketEnergySession[3] := 0;
	fbCS.arrSocketEnergySession[4] := 0;
END_IF			

(*-------------------------------------------------------------Calcualte the number of ECS---------------------------------------------------------------*)

fbNumberDevice(
	diActualNumberOfDevices:= Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS, 
	diMaxNumberOfDevices:= Constants_Energy.diMaxNumberOfElectricChargingStations, 
	udiCounterOnlineChange:= TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, 
	bNumberIsCalculatet=> , 
	bFPNumberIsCalculatet=> , 
	bOnlineChange=> , 
	diNumberForThisDevice=> diNrOfECS_OUT, 
	diNumberOfTotalDevices=> );

//Write new Numer on GVL
IF fbNumberDevice.bFPNumberIsCalculatet THEN
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS := fbNumberDevice.diNumberOfTotalDevices;	
END_IF 

//Delete old Number on GVL
IF fbNumberDevice.bOnlineChange THEN 
	Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS := diNrOfECS_OUT;	
		iStateGVLData := 1;
END_IF

(*-------------------------------------------------------------Service from Backend is ready and check the connection to backen for dissabel/enable Function---------------------------------------------------------------*)

//Try to reset the variable for connection on the GVL. When all is normal then the Lynus Mqtt connection function set this variable to true in the next cycle
//When we have no connection to the backend then after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions days the Function is dissabled with all of his functionalities
timResetConnectionOnGVL(IN:= NOT timResetConnectionOnGVL.Q, PT:= T#1H, Q=> , ET=> );
	IF timResetConnectionOnGVL.Q THEN Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := FALSE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions THEN timDissableFunctions.IN := TRUE; ELSE timDissableFunctions.IN := FALSE; END_IF  
			timDissableFunctions(IN:= , PT:= Lynus_Standards.Constants_General.tTimeDissableLynusFunctions, Q=> , ET=> );
			
(*--------------------------------------------------------------------------------------------State Machine Read--------------------------------------------------------------------------------------*)

//Timer for Delay
timDelay(IN:= , PT:= T#350MS, Q=> , ET=> );

//Timer for Timeout in Statemachine
IF (iStateModbusRead > 0 AND iStateModbusRead <= 5 AND iStateModbusRead = iStateModbus_CP) OR
		(iStateModbusWrite > 0 AND iStateModbusWrite <= 1 AND iStateModbusWrite = iStateModbus_CP) THEN
			timTimeout.IN := TRUE;
ELSE	
			timTimeout.IN := FALSE;
END_IF
	//Timeout Timer is dissabled when the Init Step is aktiv or the function is not enabled
	IF (iStateModbusRead = 0 AND iStateModbusWrite = 0) OR NOT bEnable THEN timTimeout.IN := FALSE; END_IF
		timTimeout(IN:= , PT:= T#10S, Q=> , ET=> );

//Enable with Delay that not all sockets have to be created at the same time
timDelayStart(IN:= bEnable, PT:= T#20MS * diNrOfECS_OUT, Q=> , ET=> );
	FPEnable(CLK:= timDelayStart.Q, Q=> );

IF FPEnable.Q AND iStateModbusRead = 0 AND iStateModbusWrite = 0 THEN iStateModbusRead := 1; bySocketInProgress := 1; END_IF		
		
//Not Enabled
IF NOT bEnable THEN iStateModbusRead := 0; iStateModbusError := 0; iStateModbusWrite := 0; END_IF		
		
CASE iStateModbusRead OF

	0://Init Step 
		iStateModbus_CP := 0;
			timDelay.IN := FALSE;
				fbMBRead_FC3.bExecute := FALSE;
					fbMBWrite_FC16.bExecute := FALSE;
						bySocketInProgress := 0;
							rPowerECS_S1 := 0;	
								rPowerECS_S2 := 0;	
		arrMode3State[1] := ''; arrMode3State[2] := '';
	
	1://Read Out the mode 3 State from the charging station (Register 1201)
		iStateModbus_CP := iStateModbusRead;
		
		//Reset Write
		fbMBWrite_FC16.bExecute := FALSE;
			
		//Start Read
		fbMBRead_FC3.nQuantity := 5;
			fbMBRead_FC3.nMBAddr := 1201;
				fbMBRead_FC3.bExecute := TRUE;
					IF bySocketInProgress = 1 THEN fbMBRead_FC3.nUnitID := byUnitID_Socket1;
					ELSIF bySocketInProgress = 2 THEN fbMBRead_FC3.nUnitID := byUnitID_Socket2; 
					END_IF
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Mode 3 state
			fbConvertWordToByte(wInputValue:= arrBuffer_FC3[1], eByteOrderForConvert:= eByteOrder.eBigEndian, byOutputValue_1=> , byOutputValue_2=> );	
				bySocketInProgress := LIMIT(1,bySocketInProgress,2);
					IF fbConvertWordToByte.byOutputValue_1 = 16#41 AND fbConvertWordToByte.byOutputValue_2 = 16#00 THEN arrMode3State[bySocketInProgress] := 'A';
					ELSIF fbConvertWordToByte.byOutputValue_1 = 16#42 AND fbConvertWordToByte.byOutputValue_2 = 16#31 THEN arrMode3State[bySocketInProgress] := 'B1';
					ELSIF fbConvertWordToByte.byOutputValue_1 = 16#42 AND fbConvertWordToByte.byOutputValue_2 = 16#32 THEN arrMode3State[bySocketInProgress] := 'B2';  			
					ELSIF fbConvertWordToByte.byOutputValue_1 = 16#43 AND fbConvertWordToByte.byOutputValue_2 = 16#31 THEN arrMode3State[bySocketInProgress] := 'C1';
					ELSIF fbConvertWordToByte.byOutputValue_1 = 16#43 AND fbConvertWordToByte.byOutputValue_2 = 16#32 THEN arrMode3State[bySocketInProgress] := 'C2';
					ELSIF fbConvertWordToByte.byOutputValue_1 = 16#44 AND fbConvertWordToByte.byOutputValue_2 = 16#31 THEN arrMode3State[bySocketInProgress] := 'D1';
					ELSIF fbConvertWordToByte.byOutputValue_1 = 16#44 AND fbConvertWordToByte.byOutputValue_2 = 16#32 THEN arrMode3State[bySocketInProgress] := 'D2';
					ELSIF fbConvertWordToByte.byOutputValue_1 = 16#45 AND fbConvertWordToByte.byOutputValue_2 = 16#00 THEN arrMode3State[bySocketInProgress] := 'E';
					ELSIF fbConvertWordToByte.byOutputValue_1 = 16#46 AND fbConvertWordToByte.byOutputValue_2 = 16#00 THEN arrMode3State[bySocketInProgress] := 'F';
					END_IF
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 2;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF
		
	2://Power Data in W (Register 344)
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 2;
			fbMBRead_FC3.nMBAddr := 344;
				fbMBRead_FC3.bExecute := TRUE;
					IF bySocketInProgress = 1 THEN fbMBRead_FC3.nUnitID := byUnitID_Socket1;
					ELSIF bySocketInProgress = 2 THEN fbMBRead_FC3.nUnitID := byUnitID_Socket2; 
					END_IF
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Power Data in kW
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], eByteOrderForConvert:= eByteOrder.eBigEndian, dwOutputValue =>);
				stConvertFloat.dwRawValue := fbConvertWordToDword.dwOutputValue;
					IF bySocketInProgress = 1 THEN 
						rPowerECS_S1 := stConvertFloat.rValueFloat;
					ELSIF bySocketInProgress = 2 THEN
						rPowerECS_S2 := stConvertFloat.rValueFloat;
					END_IF
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 3;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF
	
	3://Energy Data kWh. Delivered Sum (Register 374)
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 4;
			fbMBRead_FC3.nMBAddr := 374;
				fbMBRead_FC3.bExecute := TRUE;
					IF bySocketInProgress = 1 THEN fbMBRead_FC3.nUnitID := byUnitID_Socket1;
					ELSIF bySocketInProgress = 2 THEN fbMBRead_FC3.nUnitID := byUnitID_Socket2; 
					END_IF
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Power Data in kW
			fbConvertWordToUlint(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], wInputValue_3:= arrBuffer_FC3[3], wInputValue_4:= arrBuffer_FC3[4], eByteOrderForConvert:= eByteOrder.eBigEndian, uliOutputValue =>);
				stConvertFloat2.uliRawValue := fbConvertWordToUlint.uliOutputValue;
					IF bySocketInProgress = 1 THEN
						lrTotalCounterEnergy_Consumption_S1 := stConvertFloat2.lrValueFloat;
					ELSIF bySocketInProgress = 2 THEN	
						lrTotalCounterEnergy_Consumption_S2 := stConvertFloat2.lrValueFloat;
					END_IF
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 4;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF
		
	4://Energy Data kWh. Consumed Sum (Register 390)
		iStateModbus_CP := iStateModbusRead;

		//Start Read
		fbMBRead_FC3.nQuantity := 4;
			fbMBRead_FC3.nMBAddr := 390;
				fbMBRead_FC3.bExecute := TRUE;
					IF bySocketInProgress = 1 THEN fbMBRead_FC3.nUnitID := byUnitID_Socket1;
					ELSIF bySocketInProgress = 2 THEN fbMBRead_FC3.nUnitID := byUnitID_Socket2; 
					END_IF
			
		IF fbMBRead_FC3.bBusy THEN timDelay.IN := TRUE; END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timDelay.Q THEN
			//Power Data in kW
			fbConvertWordToUlint(wInputValue_1:= arrBuffer_FC3[1], wInputValue_2:= arrBuffer_FC3[2], wInputValue_3:= arrBuffer_FC3[3], wInputValue_4:= arrBuffer_FC3[4], eByteOrderForConvert:= eByteOrder.eBigEndian, uliOutputValue =>);
				stConvertFloat2.uliRawValue := fbConvertWordToUlint.uliOutputValue;
					IF bySocketInProgress = 1 THEN 
						lrTotalCounterEnergy_Production_S1 := stConvertFloat2.lrValueFloat;
					ELSIF bySocketInProgress = 2 THEN
						lrTotalCounterEnergy_Production_S2 := stConvertFloat2.lrValueFloat;
					END_IF
			//Go to Next Step
			fbMBRead_FC3.bExecute := FALSE;
				timDelay.IN := FALSE;		
					iStateModbusRead := 5;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF	
	
	5://Wait 1 Step to reset the delay counter befor start to write
		iStateModbus_CP := iStateModbusRead;
		
			iStateModbusWrite := 1;
				//-1 because 0 is the Init Step for Read
				iStateModbusRead := - 1;
				
			//Error on Master, changes on Inputs or Timeout
		 	IF timTimeout.Q THEN 
				iStateModbusError := 300;	 
			END_IF
	
END_CASE

//When we have only 1 connector set the mode 3 state from connector 2 to State A.
IF byNumberOfSockets = 1 THEN arrMode3State[2] := 'A'; END_IF 

(*------------------------------------------------------------------Error and Warning----------------------------------------------------------------------------*)	
 
IF arrMode3State[1] = 'F' OR arrMode3State[2] = 'F' THEN bErrorCS := TRUE; ELSE bErrorCS := FALSE; END_IF  

IF timDissableFunctions.Q THEN fbCS.bWarning := TRUE; fbCS.iWarningCode := 0; ELSE fbCS.bWarning := FALSE; END_IF   
	IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS > Constants_Energy.diMaxNumberOfElectricChargingStations OR bErrorCS OR bMBTCPError THEN 
		fbCS.bError := TRUE;
	ELSE 
		fbCS.bError := FALSE;
			fbCS.iErrorCode := 0;
	END_IF

IF Lynus_Standards.GVL_Energy.stNumberOfDevices.diNumberOfECS > Constants_Energy.diMaxNumberOfElectricChargingStations THEN fbCS.iErrorCode := 1;
ELSIF bErrorCS OR bMBTCPError THEN fbCS.iErrorCode := 0; END_IF

(*------------------------------------------------------------------Logic----------------------------------------------------------------------------*)

//Calcualte the total SOC if we have more then 1 battery in our system
diNumberOfActiveBatterys := 0;
	dwSumSOC := 0;
		FOR liLPBatteryData := 1 TO Constants_Energy.diMaxNumberOfBatterys BY 1 DO
			IF Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_IN,liLPBatteryData].bEnabled THEN diNumberOfActiveBatterys := diNumberOfActiveBatterys + 1; END_IF
				dwSumSOC := dwSumSOC + Lynus_Standards.GVL_Energy.stDataOfBatterys[diNrOfEMS_IN,liLPBatteryData].dwSOC;
		END_FOR
	
IF diNumberOfActiveBatterys > 0 THEN
	fbCS.dwBatterySOC := DINT_TO_DWORD(DWORD_TO_DINT(dwSumSOC) / diNumberOfActiveBatterys);
ELSE
	fbCS.dwBatterySOC := 100;	//When we have no battery in the ems system
END_IF

//Check if one or more Batterysystems or batteryinverter make island mode
diNumberOfBatteryInverterInEPO := 0;
	FOR liLPInEPO := 1 TO Constants_Energy.diMaxNumberOfBatteryInverters BY 1 DO
		IF Lynus_Standards.GVL_Energy.stDataOfBatteryInverters[diNrOfEMS_IN,liLPInEPO].bWorkOnIslandMode THEN fbCS.bEPOIsActive := TRUE; diNumberOfBatteryInverterInEPO := diNumberOfBatteryInverterInEPO + 1; END_IF
	END_FOR 
		IF diNumberOfBatteryInverterInEPO <= 0 THEN fbCS.bEPOIsActive := FALSE; END_IF

//Digital input for external lock signal
fbDIExternalLock(bInvers:= FALSE, bSignal=> );

//Car connected to the ECS  
IF arrMode3State[1] = 'B1' OR arrMode3State[1] = 'B2' OR arrMode3State[1] = 'C1' OR arrMode3State[1] = 'C2' OR arrMode3State[1] = 'D1' OR arrMode3State[1] = 'D2' OR
	 arrMode3State[2] = 'B1' OR arrMode3State[2] = 'B2' OR arrMode3State[2] = 'C1' OR arrMode3State[2] = 'C2' OR arrMode3State[2] = 'D1' OR arrMode3State[2] = 'D2' THEN 
		fbCS.bCarConnected := TRUE; 
ELSE 
		fbCS.bCarConnected := FALSE; 
END_IF 

//Min Current
IF byNumberOfSockets <> 1 AND byNumberOfConnectionWire = 1 THEN fbCS.rMinCurrent := 12; ELSE fbCS.rMinCurrent := 6; END_IF

//Charging time
IF arrMode3State[1] = 'C2' OR arrMode3State[1] = 'D2' THEN timChTimeSocket1.IN := TRUE; ELSE timChTimeSocket1.IN := FALSE; END_IF
IF arrMode3State[2] = 'C2' OR arrMode3State[2] = 'D2' THEN timChTimeSocket2.IN := TRUE; ELSE timChTimeSocket2.IN := FALSE; END_IF  

IF timChTimeSocket1.IN THEN fbCS.arrSocketChargingTimeInput[1] := TIME_TO_REAL(timChTimeSocket1.ET) / 60000; END_IF
IF timChTimeSocket2.IN THEN fbCS.arrSocketChargingTimeInput[2] := TIME_TO_REAL(timChTimeSocket2.ET) / 60000; END_IF
fbCS.arrSocketChargingTimeInput[3] := 0;
fbCS.arrSocketChargingTimeInput[4] := 0;

timChTimeSocket1(IN:= , PT:= T#24H, Q=> , ET=> );
timChTimeSocket2(IN:= , PT:= T#24H, Q=> , ET=> );

//Mode 3 State
fbCS.arrSocketMode3StateECS[1] := arrMode3State[1];
fbCS.arrSocketMode3StateECS[2] := arrMode3State[2];
fbCS.arrSocketMode3StateECS[3] := '';
fbCS.arrSocketMode3StateECS[4] := '';

//SOC Car
fbCS.arrSOCCar[1] := 0;
fbCS.arrSOCCar[2] := 0;
fbCS.arrSOCCar[3] := 0;
fbCS.arrSOCCar[4] := 0;

//Functionblock ECS
fbCS(
	bEnable:= bEnable AND NOT timDissableFunctions.Q, 
	bError:= ,
	bWarning := ,
	bEPOIsActive:= , 
	bExternalLock:= fbDIExternalLock.bSignal, 
	bCarConnected:= , 
	bWriteWithDelay:= TRUE, 
	bCalculateEnergySession:= ,
	iErrorCode:= , 
	iWarningCode:= , 
	arrSocketChargingTimeInput:= ,
	arrSOCCar:= , 
	dwBatterySOC:= , 
	lrTotalCounterEnergy_Consumption:= , 
	lrTotalCounterEnergy_Production:= , 
	lrCounterEnergyT1_Consumption:= , 
	lrCounterEnergyT2_Consumption:= , 
	lrCounterEnergyT1_Production:= , 
	lrCounterEnergyT2_Production:= , 
	lrTotalPowerECS:= , 
	arrSocketEnergySession:= ,
	rTargetPower:= Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].rTargetPowerEMS, 
	rSupplyVoltage:= 692, 
	rMinCurrent:= , 
	tTimDelayOutput:= T#5S, 
	tDelayError:= T#5S,
	arrSocketMode3StateECS:= ,
	arrSocketPowerECS:= ,
	stSetupECS:= stSetupECS, 
	stDataECSOut=> , 
	stDataECSOutDelay=> stDataECS);

//Real time Power for Output
lrTotalPowerECSRealTime := fbCS.stDataECSOut.lrTotalPower;
	
(*------------------------------------------------------------------------------------------State Machine Write---------------------------------------------------------------------------------------------*)	

CASE iStateModbusWrite OF	

	1://Set the charging current (Reg 1210)
		iStateModbus_CP := iStateModbusWrite;
		
			fbMBWrite_FC16.nQuantity := 2;
				fbMBWrite_FC16.nMBAddr := 1210;
					fbMBWrite_FC16.bExecute := TRUE;
						IF bySocketInProgress = 1 THEN fbMBWrite_FC16.nUnitID := byUnitID_Socket1;
						ELSIF bySocketInProgress = 2 THEN fbMBWrite_FC16.nUnitID := byUnitID_Socket2; 
						END_IF
		
		//Prepear the sending Data. Charging Current for the charging station. (FLOAT32 format)
		//Charging current
		IF fbCS.stDataECSOut.rTargetChargeCurrent >= 0 AND fbCS.stDataECSOut.rTargetChargeCurrent <= 65535 THEN 
			IF byNumberOfSockets <> 1 AND byNumberOfConnectionWire = 1 THEN 
				stConvertFloat.rValueFloat := fbCS.stDataECSOut.rTargetChargeCurrent / 2;
			ELSE
				stConvertFloat.rValueFloat := fbCS.stDataECSOut.rTargetChargeCurrent;
			END_IF
				fbConvertDwordToWord(dwInputValue:= stConvertFloat.dwRawValue, eByteOrderForConvert:= eByteOrder.eBigEndian, wOutputValue_1=> arrBuffer_FC16[1], wOutputValue_2=> arrBuffer_FC16[2]);	 				
		END_IF	 		  
		
		IF fbMBWrite_FC16.bBusy THEN timDelay.IN := TRUE; END_IF

		//Wait for Delay and then next step
		IF NOT fbMBWrite_FC16.bBusy AND NOT fbMBWrite_FC16.bError AND timDelay.Q THEN
			fbMBWrite_FC16.bExecute := FALSE;
				timDelay.IN := FALSE;
					bMBTCPError := FALSE; 
						//Restart from new with the Read out part
						iStateModbusRead := 1;
							iStateModbusWrite := 0;
								IF byNumberOfSockets > 1 THEN 
									bySocketInProgress := bySocketInProgress + 1;
								END_IF
									IF bySocketInProgress > 2 THEN bySocketInProgress := 1; END_IF
		END_IF
				
		//Error or Timout
		IF FPError_FC_16.Q OR timTimeout.Q THEN
			iStateModbusError := 300;
		END_IF
		
END_CASE	
	
(*------------------------------------------------------------------------------------------State Machine Error---------------------------------------------------------------------------------------------*)	

CASE iStateModbusError OF
	
	300://Error
		iStateModbus_CP := iStateModbusError;
			timDelay.IN := FALSE;
				fbMBRead_FC3.bExecute := FALSE;
					fbMBWrite_FC16.bExecute := FALSE;
						bMBTCPError := TRUE; 		
							//Restart from new with the Read out part after an Error
							iStateModbusRead := 1;	
								iStateModbusError := 0;
									iStateModbusWrite := 0;
						
END_CASE

(*------------------------------------------------------------------------------------------Modbus TCP Functions---------------------------------------------------------------------------------------------*)

fbMBRead_FC3(sIPAddr:= sIPAdress, nTCPPort:= 502,cbLength:= SIZEOF(arrBuffer_FC3), pDestAddr:= ADR(arrBuffer_FC3), tTimeout:= T#5S );
	FPError_FC_3(CLK:= fbMBRead_FC3.bError, Q=> );		

fbMBWrite_FC16(sIPAddr:= sIPAdress, nTCPPort:= 502, cbLength:= SIZEOF(arrBuffer_FC16), pSrcAddr:= ADR(arrBuffer_FC16), tTimeout:= T#5S);	
	FPError_FC_16(CLK:= fbMBWrite_FC16.bError, Q=> );

(*-----------------------------------------------------------Handle data to Global structure for electric charging stations-----------------------------------------------------------------*)

//Delte al old Data on GVL after a online change or change on the variable diNrOfEMS_IDOD
IF diNrOfEMS_IN <> diNrOfEMS_IN_CP AND iStateGVLData = 0 THEN iStateGVLData := 10; END_IF 

CASE iStateGVLData OF
	
	0://Init Step
		byWaitInStep := 0;
			diCounterForGVL := 1;
	
	1://Wait for 4 Steps before clean al Data on GVL
		byWaitInStep := byWaitInStep + 1;
			IF byWaitInStep >= 4 AND fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 2; END_IF
				//To much Devices, back to the Init step
				IF byWaitInStep >= 4 AND NOT fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 0; END_IF	
			
	2://Clear all Data in GVL
		FOR diLPForGVL := 1 TO Constants_Energy.diMaxNumberOfEMS BY 1 DO 
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].bEnabled := FALSE;
				Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].bIsControllable := FALSE;
					Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byErrorWarning := 0;
						Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byPriority := 0;
							Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPower := 0;
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPowerConsumption := 0;
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].lrPowerProduction := 0;
										Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].rMaxPower := 0;
											Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].byElectricFuseLine := 0;
												//Set also the target value from ems back here to 0 and not in EMS function because EMS is in Standy when we have a online change (Problem when we delete a ems function and make a online change)
												Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diLPForGVL,diCounterForGVL].rTargetPowerEMS := 0;	
		END_FOR
		
			//Counter for ECS
			diCounterForGVL := diCounterForGVL + 1;
				diCounterForGVL := LIMIT(0,diCounterForGVL,Constants_Energy.diMaxNumberOfElectricChargingStations);
					//Back to the init step
					IF diCounterForGVL >= Constants_Energy.diMaxNumberOfElectricChargingStations THEN iStateGVLData := 0; END_IF

	10://Clear old Data on GVL 		
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].bEnabled := FALSE;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].bIsControllable := FALSE;
				Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byErrorWarning := 0;
					Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byPriority := 0;
						Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPower := 0;
							Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPowerConsumption := 0;
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].lrPowerProduction := 0;
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].rMaxPower := 0;
										Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN_CP,diNrOfECS_OUT].byElectricFuseLine := 0;
									
		diNrOfEMS_IN_CP := diNrOfEMS_IN;
			//Back to the init step
			iStateGVLData := 0;

END_CASE 	 

IF diNrOfECS_OUT > 0 AND fbNumberDevice.bNumberIsCalculatet AND diNrOfEMS_IN > 0 THEN
	Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].bEnabled := fbCS.stDataECSOut.bEnabled;
		Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].bIsControllable := TRUE;
			Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byErrorWarning := fbCS.stDataECSOut.byErrorWarning;
				Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byPriority := fbCS.stDataECSOut.byPriority;
					Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPower := fbCS.stDataECSOut.lrTotalPower;
						Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPowerConsumption := fbCS.stDataECSOut.lrTotalPowerConsumption;
							Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].lrPowerProduction := fbCS.stDataECSOut.lrTotalPowerProduction;
								Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].rMaxPower := fbCS.stDataECSOut.rMaxPower;	
									Lynus_Standards.GVL_Energy.stDataElectricChargingStations[diNrOfEMS_IN,diNrOfECS_OUT].byElectricFuseLine := byElectricFuseLine;
END_IF 

(*----------------------------------------------------------Save persistent data----------------------------------------------------------------*)

arrPD[1](lrValue:= BOOL_TO_LREAL(bEnable), bEventBasedActive=> );
arrPD[2](lrValue:= BOOL_TO_LREAL(bPowerDataInvers), bEventBasedActive=> );
arrPD[3](lrValue:= DINT_TO_LREAL(diNrOfEMS_IN), bEventBasedActive=> );
arrPD[4](lrValue:= DINT_TO_LREAL(diNrOfEM_IN_CS), bEventBasedActive=> );
arrPD[5](lrValue:= BOOL_TO_LREAL(stSetupECS.bManualyOn), bEventBasedActive=> );
arrPD[6](lrValue:= BOOL_TO_LREAL(stSetupECS.bOnEmergPowerOff), bEventBasedActive=> );
arrPD[7](lrValue:= BYTE_TO_LREAL(stSetupECS.byCSMinPower), bEventBasedActive=> );
arrPD[8](lrValue:= BYTE_TO_LREAL(stSetupECS.byDisableSOC), bEventBasedActive=> );
arrPD[9](lrValue:= BYTE_TO_LREAL(stSetupECS.byEnableSOC), bEventBasedActive=> );
arrPD[10](lrValue:= BYTE_TO_LREAL(stSetupECS.byManualyTargetPower), bEventBasedActive=> );
arrPD[11](lrValue:= BYTE_TO_LREAL(stSetupECS.byPriority), bEventBasedActive=> );
arrPD[12](lrValue:= REAL_TO_LREAL(stSetupECS.rMaxPower), bEventBasedActive=> );
arrPD[13](lrValue:= DINT_TO_LREAL(diNrOfEMS_IN_CP), bEventBasedActive=> );
arrPD[14](lrValue:= BYTE_TO_LREAL(byUnitID_Socket1), bEventBasedActive=> );
arrPD[15](lrValue:= BYTE_TO_LREAL(byUnitID_Socket2), bEventBasedActive=> );
arrPD[16](lrValue:= BYTE_TO_LREAL(byNumberOfSockets), bEventBasedActive=> );
arrPD[17](lrValue:= BYTE_TO_LREAL(byNumberOfConnectionWire), bEventBasedActive=> );
arrPD[18](lrValue:= BYTE_TO_LREAL(byElectricFuseLine), bEventBasedActive=> );
fbPDString(sText:= sIPAdress, bEventBasedActive=> );
]]></ST>
    </Implementation>
    <LineIds Name="FB_ECS_Alfen_NG9xx_Platform">
      <LineId Id="2738" Count="25" />
      <LineId Id="3456" Count="0" />
      <LineId Id="2764" Count="1" />
      <LineId Id="3564" Count="0" />
      <LineId Id="2766" Count="0" />
      <LineId Id="3933" Count="8" />
      <LineId Id="3932" Count="0" />
      <LineId Id="2767" Count="0" />
      <LineId Id="3872" Count="0" />
      <LineId Id="2768" Count="6" />
      <LineId Id="3942" Count="0" />
      <LineId Id="3873" Count="0" />
      <LineId Id="2776" Count="7" />
      <LineId Id="3561" Count="0" />
      <LineId Id="3874" Count="0" />
      <LineId Id="3716" Count="5" />
      <LineId Id="3563" Count="0" />
      <LineId Id="3875" Count="3" />
      <LineId Id="3885" Count="1" />
      <LineId Id="3883" Count="1" />
      <LineId Id="3887" Count="1" />
      <LineId Id="3562" Count="0" />
      <LineId Id="2784" Count="34" />
      <LineId Id="2821" Count="14" />
      <LineId Id="3558" Count="1" />
      <LineId Id="3557" Count="0" />
      <LineId Id="2836" Count="12" />
      <LineId Id="3714" Count="0" />
      <LineId Id="3730" Count="0" />
      <LineId Id="4061" Count="0" />
      <LineId Id="2849" Count="42" />
      <LineId Id="3598" Count="0" />
      <LineId Id="3600" Count="0" />
      <LineId Id="3603" Count="13" />
      <LineId Id="3628" Count="0" />
      <LineId Id="3642" Count="0" />
      <LineId Id="3731" Count="0" />
      <LineId Id="3643" Count="0" />
      <LineId Id="3732" Count="2" />
      <LineId Id="3629" Count="8" />
      <LineId Id="3602" Count="0" />
      <LineId Id="3601" Count="0" />
      <LineId Id="3645" Count="0" />
      <LineId Id="3649" Count="16" />
      <LineId Id="3745" Count="3" />
      <LineId Id="3744" Count="0" />
      <LineId Id="3667" Count="8" />
      <LineId Id="3646" Count="1" />
      <LineId Id="3686" Count="17" />
      <LineId Id="3749" Count="3" />
      <LineId Id="3743" Count="0" />
      <LineId Id="3705" Count="8" />
      <LineId Id="3648" Count="0" />
      <LineId Id="3644" Count="0" />
      <LineId Id="2892" Count="9" />
      <LineId Id="2903" Count="61" />
      <LineId Id="3889" Count="3" />
      <LineId Id="3894" Count="0" />
      <LineId Id="3893" Count="0" />
      <LineId Id="3572" Count="0" />
      <LineId Id="2970" Count="0" />
      <LineId Id="3575" Count="1" />
      <LineId Id="3904" Count="5" />
      <LineId Id="3911" Count="3" />
      <LineId Id="2971" Count="9" />
      <LineId Id="3723" Count="0" />
      <LineId Id="2981" Count="11" />
      <LineId Id="3722" Count="0" />
      <LineId Id="2993" Count="3" />
      <LineId Id="3255" Count="0" />
      <LineId Id="3565" Count="0" />
      <LineId Id="3871" Count="0" />
      <LineId Id="2997" Count="2" />
      <LineId Id="4181" Count="2" />
      <LineId Id="3000" Count="100" />
      <LineId Id="3354" Count="0" />
      <LineId Id="3101" Count="18" />
      <LineId Id="3355" Count="0" />
      <LineId Id="3120" Count="15" />
      <LineId Id="3356" Count="0" />
      <LineId Id="3136" Count="20" />
      <LineId Id="3357" Count="0" />
      <LineId Id="3157" Count="0" />
      <LineId Id="1079" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>