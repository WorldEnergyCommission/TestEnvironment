<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_BLUE_LOG_XMXC" Id="{967a394a-4272-40c7-b9ac-dc0b26bb062d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_BLUE_LOG_XMXC
VAR_INPUT PERSISTENT
	m_Enable					: BOOL;						//Enable the Fuctionblock and his logic
	str_IPAdress				: STRING(15);				//IP Adress of the meter
	arr_byte_ID_PV				: ARRAY [1..9] OF BYTE ;		//Slave ID  PV
	
END_VAR
VAR_OUTPUT

	str_Data_Out			: ARRAY [1..9] OF str_BlueLogDataOut;
	
END_VAR
VAR
	{attribute 'hide'}
	w_Array_Received			: ARRAY[1..100] OF WORD;	// received data
	{attribute 'hide'}
	w_Adress					: WORD;						//modbus adress
	{attribute 'hide'}
	usint_Quantity				: USINT;					//Number of Words to get polled, max 100
	{attribute 'hide'}
	fbConvertWordToDword		: FB_CV_WORD_TO_DWORD;			//Convert Word to Dword
	{attribute 'hide'}
	usintSign					: USINT;						// converstion dword to real	
	{attribute 'hide'}
	intExponent					: INT;							// converstion dword to real
	{attribute 'hide'}
	realMantisse				: REAL;							// converstion dword to real
	{attribute 'hide'}
	timer_Delay					: TON;						//Timer for Delay between Requests
	{attribute 'hide'}
	timer_DelayStart			: TON;						//Timer to start the state machine with Delay after enabling or after the system ist restartet
	{attribute 'hide'}
	timer_TimeOut				: TON;						//Timer for Timeout MB Read
	{attribute 'hide'}
	iStateModbusRead			: INT;						//State machine for read out Data over Modbus RTU
	{attribute 'hide'}
	fbMBRead_FC3				: FB_MBReadRegs  ;		//Modbus Read Function (FC3)
	{attribute 'hide'}
	ftrig_PEnable				: f_trig;					//Internal positive Edge
	{attribute 'hide'}
	iStateModbusError			: INT;						//State machine for error out Data over Modbus TCP/IP	
	{attribute 'hide'}
	FPError_FC_3				: R_TRIG;					//Internal positive Edge
	{attribute 'hide'}
	arrBuffer_FC3				: ARRAY[1..100] OF WORD;		//Buffer with Data from FC3
	{attribute 'hide'}
	timer_Connection_ok			: TON;
	{attribute 'hide'}
	int_Data_Received			: INT;
	{attribute 'hide'}
	m_MBTCPError				: BOOL;
	{attribute 'hide'}
	int_Data_Received_old		: INT;
	{attribute 'hide'}
	timer_Connection_ok_TOF	: TOF;
	{attribute 'hide'}
	m_Poll_ok: BOOL;
	{attribute 'hide'}
	timer_Wait: Ton;
	{attribute 'hide'}
	int_TimeoutError: INT;
	{attribute 'hide'}
	int_FC3Error: INT;
	{attribute 'hide'}
	i: INT;
	{attribute 'hide'}
	x: INT;
	int_Poll_Count: INT:=1;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*--------------------------------------------------------------------------------------------Limits-------------------------------------------------------------------------------------*)
w_Adress := 41000;
usint_Quantity := 72; 
w_Adress := LIMIT(0,w_Adress,65000);
usint_Quantity := LIMIT(1,usint_Quantity,100);
	
(*--------------------------------------------------------------------------------------------State Machine Read--------------------------------------------------------------------------------------*)

//Timer for Delay
timer_Delay(IN:= , PT:= T#50MS, Q=> , ET=> );

//Timeout Timer is dissabled when the Init Step is aktiv or the function is not enabled
IF iStateModbusRead = 0 OR NOT m_Enable THEN 
	timer_Timeout.IN := FALSE; 
END_IF
timer_Timeout(IN:= , PT:= T#1S, Q=> , ET=> );

//Enable with Delay that not all sockets have to be created at the same time
timer_DelayStart(IN:= m_Enable, PT:= T#1S, Q=> , ET=> );
ftrig_PEnable(CLK:= timer_DelayStart.Q, Q=> );

IF ftrig_PEnable.Q AND iStateModbusRead = 0 THEN 
	iStateModbusRead := 1; 
END_IF		
		
//Not Enabled
IF NOT m_Enable THEN 
	iStateModbusRead := 0; 
	iStateModbusError := 0; 
END_IF		
		
CASE iStateModbusRead OF

	0://Init Step 
		timer_Delay.IN := FALSE;
		fbMBRead_FC3.bExecute := FALSE;
		m_Poll_ok:=FALSE;
		int_Data_Received:=0;
		iStateModbusRead := 1;
		int_Poll_Count :=1;

	1: // clean the array
		FOR i:=1 TO 100 BY 1 DO
			w_Array_Received[i] := 0;
		END_FOR
		iStateModbusRead := 2;
		
	2://read the required registers
		//Start Read
		fbMBRead_FC3.nQuantity := usint_Quantity;
		fbMBRead_FC3.nMBAddr := w_Adress;
		fbMBRead_FC3.bExecute := TRUE;
		
		// Poll count 1 to 9 if next poll is not empty
		IF int_Poll_Count >= 9 THEN 
			int_Poll_Count :=1;
		ELSIF arr_byte_ID_PV[int_Poll_Count+1] >0 AND arr_byte_ID_PV[int_Poll_Count+1] <255 THEN
			int_Poll_Count := int_Poll_Count+1; 
		ELSIF arr_byte_ID_PV[int_Poll_Count+1] <=0 OR arr_byte_ID_PV[int_Poll_Count+1] >=255 THEN
			int_Poll_Count := 1; 
		END_IF
		
		
		fbMBRead_FC3.nUnitID := arr_byte_ID_PV[int_Poll_Count];
		timer_Timeout.IN := TRUE;
		IF fbMBRead_FC3.bBusy THEN 
			timer_Delay.IN := TRUE; 
		END_IF
		
		//Wait for Delay, copy Data and then next step
		IF NOT fbMBRead_FC3.bBusy AND NOT fbMBRead_FC3.bError AND timer_Delay.Q THEN
			m_Poll_ok:=TRUE;
			int_Data_Received:=int_Data_Received+1;
			m_MBTCPError := FALSE; 
			
			w_Array_Received := arrBuffer_FC3;
						
			//Go to Next Step
			timer_Timeout.IN := FALSE;
			fbMBRead_FC3.bExecute := FALSE;
			timer_Delay.IN := FALSE;		
			iStateModbusRead := 3;
		END_IF	

		//Error or Timeout
		IF FPError_FC_3.Q THEN 
			iStateModbusError := 300;
			int_FC3Error := int_FC3Error+1;
		ELSIF timer_Timeout.Q THEN  
			timer_Timeout.IN := FALSE; 	
			iStateModbusError := 300;
			int_TimeoutError := int_TimeoutError+1;
		END_IF
		
	3: // convert data
		x:=1;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_RealPower_W := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_ReactivePower_VAr := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_ApparentPower_VA := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=13;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_Frequency_Hz := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=41;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_VoltageL1N_V := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_VoltageL2N_V := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_VoltageL3N_V := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_VoltageL1L2_V := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_VoltageL2L3_V := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_VoltageL3L1_V := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_CurrentL1_A := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_CurrentL2_A := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_CurrentL3_A := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=65;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_EnergyperDay_Wh := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		x:=x+2;
			fbConvertWordToDword(wInputValue_1:= arrBuffer_FC3[x], wInputValue_2:= arrBuffer_FC3[x+1], eByteOrderForConvert:= eByteOrder.eLittleEndian , dwOutputValue=> );
			(* Sign *)
			usintSign:=BOOL_TO_USINT(fbConvertWordToDword.dwOutputValue.31);
			(* Exponent *)
			intExponent:=DWORD_TO_INT(SHR(fbConvertWordToDword.dwOutputValue,23) AND 16#FF);
			(* Mantisse *)
			realMantisse:=DWORD_TO_REAL(fbConvertWordToDword.dwOutputValue AND 16#7FFFFF);
			(* Result *)
		str_Data_Out[int_Poll_Count].real_EnergyTotal_Wh := LREAL_TO_REAL((EXPT((-1),usintSign) * (1+realMantisse/8388608) * EXPT(2,intExponent-127)));
		iStateModbusRead := 4;
	4://Wait and go to step 1
		//1 because 0 is the Init Step for Read
		timer_Wait.IN := TRUE;
		
		IF timer_Wait.Q = TRUE THEN
			iStateModbusRead := 1;
			timer_Wait.IN :=FALSE;
		END_IF

			
		
		//Error on Master, changes on Inputs or Timeout
		IF timer_Timeout.Q THEN 
			iStateModbusError := 300; 
		END_IF
		

	
END_CASE

(* wait timer*)

timer_Wait(PT:=T#3S);


(*------------------------------------------------------------------Error and Warning----------------------------------------------------------------------------*)	
 
timer_Connection_ok			(In:=int_Data_Received<>int_Data_Received_old,PT:=T#10S);
timer_Connection_ok_TOF		(In:=NOT(int_Data_Received<>int_Data_Received_old) AND int_Data_Received>3 ,PT:=T#20S);
int_Data_Received_old:=int_Data_Received;
str_Data_Out[int_Poll_Count].m_PollSuccessful:=NOT timer_Connection_ok.Q AND timer_Connection_ok_TOF.Q ;

(*------------------------------------------------------------------------------------------Modbus TCP Functions---------------------------------------------------------------------------------------------*)

fbMBRead_FC3(	sIPAddr:= str_IPAdress, 
				nTCPPort:= 502,
				cbLength:= SIZEOF(arrBuffer_FC3), 
				pDestAddr:= ADR(arrBuffer_FC3), 
				tTimeout:= T#10S,
				nErrId => str_Data_Out[int_Poll_Count].udint_Error_ID);

				
FPError_FC_3(CLK:= fbMBRead_FC3.bError, Q=> );		

(*------------------------------------------------------------------------------------------State Machine Error---------------------------------------------------------------------------------------------*)	

CASE iStateModbusError OF
	
	300://Error
		timer_Wait.IN :=TRUE;
		timer_Delay.IN := FALSE;
		fbMBRead_FC3.bExecute := FALSE;
		m_MBTCPError := TRUE; 		
		m_Poll_ok:=FALSE;
		int_Data_Received:=0;
				//Restart from new with the Read out part after an Error
		IF timer_Wait.Q = TRUE THEN
			iStateModbusRead := 0;	
			iStateModbusError := 0;
			timer_Wait.IN :=FALSE;
			timer_Timeout.IN := FALSE;
		END_IF		
							
END_CASE]]></ST>
    </Implementation>
    <LineIds Name="FB_BLUE_LOG_XMXC">
      <LineId Id="79" Count="308" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>