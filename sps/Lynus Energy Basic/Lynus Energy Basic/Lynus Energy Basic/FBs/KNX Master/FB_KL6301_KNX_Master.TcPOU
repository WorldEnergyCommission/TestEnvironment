<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_KL6301_KNX_Master" Id="{2a041d66-237c-4217-8de2-760f31866ed0}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_KL6301_KNX_Master
VAR_INPUT PERSISTENT
	stPhysAddrTerminal						: EIB_PHYS_ADDR;								//Physical KNX Adress for the KL6301 Terminal. Must be unique throughout the KNX network.
	arrGroupFilter							: ARRAY[1..8] OF EIB_GROUP_FILTER;				//Group Filter. Here all group addresses per group must be entered which may pass the filter to KL6301. All other group addresses are ignored.
	iKL6301Mode								: INT;											//Work Mode from the KL6301. 0 = 4 Filters with 64 Entrys with FW B0 or higher. 1 = 8 Filters with 32 Entrys with FW B1 or higher. 2 = 8 Filters with 32 Entrys with FW B3 or higher. 100 = Only Monitoring function with FW B1 or higher.	
END_VAR
VAR_INPUT
	uiKBusState_IN							: UINT;											//K-Bus State from the K-Bus Box on wich the Terminal is connected. (Connect with FB_K_Bus_state)
END_VAR
VAR_OUTPUT
	bActive									: BOOL;											//Function is Active
	bReady									: BOOL;											//Function is Ready
	byErrorWarning							: BYTE;											//Error Warning State
	diNrOfKNXMasterLine_OUT					: DINT;											//Active Number from the KNX Master Function for using on other functions
	eMessageKNXMaster						: E_Message_KNXMaster;							//Message from the KNX Master Function
END_VAR
VAR
	{attribute 'hide'}
	fbKNXMaster								: KL6301;										//KNX Master for KL6301
	{attribute 'hide'}
	fbNumberDevice							: FB_NumberOfDevice;							//Function block to calcualte the number of the Device
	{attribute 'hide'}
	fbKNXMessage							: FB_KNXMaster_Messages;						//KNX Messages
	{attribute 'hide'}
	arrPD									: ARRAY[1..36] OF FB_PersistentData_Number;		//FB Persistent Data
	{attribute 'hide'}
	timDissableFunctions					: TON;											//Timer to dissable the Function after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions Days without connection to the Lynus Cloud
	{attribute 'hide'}
	timResetConnectionOnGVL					: TON;											//Timer to try reset the connection Flag on the GVL. (When somebody delete the Connection Function and make only a onlinechange)
	{attribute 'hide'}
	timActive								: TON;											//Timer to activate the Terminal
	{attribute 'hide'}
	fbGetTask								: GETCURTASKINDEX;								//Task Index
	arrKNXKL6301ComIn        	AT%I*	 	: ARRAY[1..24] OF BYTE;							//Input Array for the KL6301 to map on the KL6301 Terminal
	arrKNXKL6301ComOut        	AT%Q*		: ARRAY[1..24] OF BYTE;							//Output Array for the KL6301 to map on the KL6301 Terminal
	{attribute 'hide'}
	stDefaultKNXCom							: EIB_REC;										//Default structure to set the GVL for the KNX communication to default values
	{attribute 'hide'}
	bActivateKL6301							: BOOL;											//Activate the KL6301
	{attribute 'hide'}
	byWaitInStep							: BYTE;											//Wait in Step before start to clean data on PLC
	{attribute 'hide'}
	byLPLimitFilter							: BYTE;											//Loop to ckeck the Limits for the KNX Filters
	{attribute 'hide'}
	iStateGVLData							: INT;											//State machine to handle the data on the GVL
	{attribute 'hide'}
	diCounterForGVL							: DINT;											//Counter to clean old data on GVL
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Creator : Kai Ebensperger
//Company : Lynus AG
//Date : 24.07.2021
//Version : 1.0.0.0

//With this function block we can communicate with a beckhoff KL6301 KNX Terminal.
//This Functionblock receive and send the data to the KNX Bus from ther other KNX Read and Write functions in the plc.
//This Functions block must insert in the same task with all other knx functions from the plc
//In the PLC project this block may only be called once per cycle!
//A PLC project may contain a maximum of 64 KL6301! We limit by ourself in the constants
//On the Inputs the user must set the physical KNX Adress for the Terminal. Must be unique throughout the KNX network.
//In addition, all group addresses that must pass through to the terminal must be entered in the group filters. Depending on the mode of the terminal, you can specify between 4 and 8 groupfilters with 32 or 64 entries each.
//iMode:
//0 - For firmware B0 and higher - 4 filters a 64 entries
//1 - For firmware B1 and higher - 8 filters a 32 entries
//2 - For firmware B3 and higher - 8 filters a 32 entries inverted. For cross communication of telegrams within the EIB/KNX network, which are not connected to the KL6301, it must be ensured that these group addresses are included in the filter, so that the terminal does not send an ACK.
//100 - For firmware B1 and higher - Monitor function, all group address telegrams are received. The telegrams are not acknowledged (no ACK is sent). In monitor mode, it is not possible to send.

//NOTE for diNr.....Designation => 
//_IN = Here Data come in from other Functions or go out to other functions about the GVL
//_OUT = Here Data go out to other functions about the GVL

(*------------------------------------------------------------Limits----------------------------------------------------------------------------------*)

stPhysAddrTerminal.Area := LIMIT(0,stPhysAddrTerminal.Area,15);
	stPhysAddrTerminal.Line := LIMIT(0,stPhysAddrTerminal.Line,15);	
		iKL6301Mode := LIMIT(0,iKL6301Mode,100);
		
//Group Filters
FOR byLPLimitFilter := 1 TO 8 BY 1 DO
	arrGroupFilter[byLPLimitFilter].GROUP_LEN := LIMIT(0,arrGroupFilter[byLPLimitFilter].GROUP_LEN,63);
	arrGroupFilter[byLPLimitFilter].GROUP_ADDR.MAIN := LIMIT(0,arrGroupFilter[byLPLimitFilter].GROUP_ADDR.MAIN,31);
	arrGroupFilter[byLPLimitFilter].GROUP_ADDR.SUB_MAIN := LIMIT(0,arrGroupFilter[byLPLimitFilter].GROUP_ADDR.SUB_MAIN,7);
END_FOR
	
(*-------------------------------------------------------------Calcualte the number of KNX Master---------------------------------------------------------------*)

fbNumberDevice(
	diActualNumberOfDevices:= Lynus_Standards.GVL_Bussystems.diNumberOfKNXMasters, 
	diMaxNumberOfDevices:= Constants_Bussystems.diMaxNumberOfKNXMasterKL6301, 
	udiCounterOnlineChange:= TwinCAT_SystemInfoVarList._AppInfo.OnlineChangeCnt, 
	bNumberIsCalculatet=> , 
	bFPNumberIsCalculatet=> , 
	bOnlineChange=> , 
	diNumberForThisDevice=> diNrOfKNXMasterLine_OUT, 
	diNumberOfTotalDevices=> );

//Write new Numer on GVL
IF fbNumberDevice.bFPNumberIsCalculatet THEN
	Lynus_Standards.GVL_Bussystems.diNumberOfKNXMasters := fbNumberDevice.diNumberOfTotalDevices;	
END_IF 

//Delete old Number on GVL
IF fbNumberDevice.bOnlineChange THEN 
	Lynus_Standards.GVL_Bussystems.diNumberOfKNXMasters := diNrOfKNXMasterLine_OUT;	
		iStateGVLData := 1; 
END_IF	

(*-------------------------------------------------------------Service from Backend is ready and check the connection to backen for dissabel/enable Function---------------------------------------------------------------*)

//Try to reset the variable for connection on the GVL. When all is normal then the Lynus Mqtt connection function set this variable to true in the next cycle
//When we have no connection to the backend then after Lynus_Standards.Constants_General.tTimeDissableLynusFunctions days the Function is dissabled with all of his functionalities
timResetConnectionOnGVL(IN:= NOT timResetConnectionOnGVL.Q, PT:= T#1H, Q=> , ET=> );
	IF timResetConnectionOnGVL.Q THEN Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions := FALSE; END_IF
		IF NOT Lynus_Standards.GVL_Communicator.bStateConnectionToEnableFunctions THEN timDissableFunctions.IN := TRUE; ELSE timDissableFunctions.IN := FALSE; END_IF  
			timDissableFunctions(IN:= , PT:= Lynus_Standards.Constants_General.tTimeDissableLynusFunctions, Q=> , ET=> );
			
(*-------------------------------------------------------------KNX Master---------------------------------------------------------------*)

//Activate the Terminal
timActive(IN:= uiKBusState_IN = 0, PT:= T#500MS, Q=> , ET=> );
	IF timActive.Q THEN bActivateKL6301 := TRUE; END_IF 

fbGetTask(index=> );	
	IF TwinCAT_SystemInfoVarList._TaskInfo[fbGetTask.index].FirstCycle THEN bActivateKL6301 := FALSE; END_IF	
	
IF NOT timDissableFunctions.Q AND diNrOfKNXMasterLine_OUT <> 0 AND fbNumberDevice.bNumberIsCalculatet AND bActivateKL6301 THEN fbKNXMaster.bActivate := TRUE; END_IF
	IF timDissableFunctions.Q OR diNrOfKNXMasterLine_OUT <= 0 OR NOT fbNumberDevice.bNumberIsCalculatet OR NOT bActivateKL6301 THEN fbKNXMaster.bActivate := FALSE; END_IF

fbKNXMaster(
	bActivate:= , 
	idx:= DINT_TO_INT(diNrOfKNXMasterLine_OUT), 
	EIB_PHYS_ADDR:= stPhysAddrTerminal, 
	EIB_GROUP_FILTER:= arrGroupFilter, 
	iMode:= iKL6301Mode, 
	tTimeout:= T#5S, 
	bActive=> bActive, 
	bReady=> bReady, 
	bError=> , 
	iErrorId=> , 
	str_Data_Rec=> Lynus_Standards.GVL_Bussystems.stDataOfKNXMasterKL6301[diNrOfKNXMasterLine_OUT], 
	KL6301_IN:= arrKNXKL6301ComIn, 
	KL6301_OUT:= arrKNXKL6301ComOut);

(*------------------------------------------------------------------Error and Warning----------------------------------------------------------------------------*)
			
IF timDissableFunctions.Q THEN fbKNXMessage.bWarning := TRUE; fbKNXMessage.iWarningCode := 0; ELSE fbKNXMessage.bWarning := FALSE; END_IF   
	IF (Lynus_Standards.GVL_Bussystems.diNumberOfKNXMasters > Constants_Bussystems.diMaxNumberOfKNXMasterKL6301) THEN 
		fbKNXMessage.bErrorIntern := TRUE;
			fbKNXMessage.iErrorCode := 1;
	ELSE
		fbKNXMessage.bErrorIntern := FALSE;
	END_IF	

IF fbKNXMaster.bError THEN 
	fbKNXMessage.bErrorKNX := TRUE;
		fbKNXMessage.iErrorCode := fbKNXMaster.iErrorId;
ELSE
	IF NOT fbKNXMaster.bError THEN 
		fbKNXMessage.bErrorKNX := FALSE;
	END_IF
END_IF	
		
fbKNXMessage(
	bErrorKNX:= , 
	bErrorIntern:= , 
	bWarning:= , 
	iWarningCode:= , 
	iErrorCode:= , 
	byErrorWarning=> byErrorWarning, 
	eMessageKNXMaster=> eMessageKNXMaster);
	
(*-----------------------------------------------------------Handle data to Global structure for KNX Communication-----------------------------------------------------------------*)
	
CASE iStateGVLData OF
	
	0://Init Step
		byWaitInStep := 0;
			diCounterForGVL := 1;
	
	1://Wait for 4 Steps before clean al Data on GVL
		byWaitInStep := byWaitInStep + 1;
			IF byWaitInStep >= 4 AND fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 2; END_IF
				//To much Devices, back to the Init step
				IF byWaitInStep >= 4 AND NOT fbNumberDevice.bNumberIsCalculatet THEN iStateGVLData := 0; END_IF	
			
	2://Clear all Data in GVL
	//Some Parts in the GVL Reset the Slave. Otherwise there will be problems when writing the new addresses to the array in the GVL.
	
	Lynus_Standards.GVL_Bussystems.stDataOfKNXMasterKL6301[diCounterForGVL] := stDefaultKNXCom;
														 		
		diCounterForGVL := diCounterForGVL + 1;
			diCounterForGVL := LIMIT(0,diCounterForGVL,Constants_Bussystems.diMaxNumberOfKNXMasterKL6301);
				//Back to the init step
				IF diCounterForGVL >= Constants_Bussystems.diMaxNumberOfKNXMasterKL6301 THEN iStateGVLData := 0; END_IF

END_CASE 

(*----------------------------------------------------------Save persistent data----------------------------------------------------------------*)

arrPD[1](lrValue:= BYTE_TO_LREAL(stPhysAddrTerminal.Area), bEventBasedActive=> );
arrPD[2](lrValue:= BYTE_TO_LREAL(stPhysAddrTerminal.Device), bEventBasedActive=> );
arrPD[3](lrValue:= BYTE_TO_LREAL(stPhysAddrTerminal.Line), bEventBasedActive=> );
arrPD[4](lrValue:= BYTE_TO_LREAL(arrGroupFilter[1].GROUP_ADDR.MAIN), bEventBasedActive=> );
arrPD[5](lrValue:= BYTE_TO_LREAL(arrGroupFilter[1].GROUP_ADDR.NUMBER), bEventBasedActive=> );
arrPD[6](lrValue:= BYTE_TO_LREAL(arrGroupFilter[1].GROUP_ADDR.SUB_MAIN), bEventBasedActive=> );
arrPD[7](lrValue:= WORD_TO_LREAL(arrGroupFilter[1].GROUP_LEN), bEventBasedActive=> );
arrPD[8](lrValue:= BYTE_TO_LREAL(arrGroupFilter[2].GROUP_ADDR.MAIN), bEventBasedActive=> );
arrPD[9](lrValue:= BYTE_TO_LREAL(arrGroupFilter[2].GROUP_ADDR.NUMBER), bEventBasedActive=> );
arrPD[10](lrValue:= BYTE_TO_LREAL(arrGroupFilter[2].GROUP_ADDR.SUB_MAIN), bEventBasedActive=> );
arrPD[11](lrValue:= WORD_TO_LREAL(arrGroupFilter[2].GROUP_LEN), bEventBasedActive=> );
arrPD[12](lrValue:= BYTE_TO_LREAL(arrGroupFilter[3].GROUP_ADDR.MAIN), bEventBasedActive=> );
arrPD[13](lrValue:= BYTE_TO_LREAL(arrGroupFilter[3].GROUP_ADDR.NUMBER), bEventBasedActive=> );
arrPD[14](lrValue:= BYTE_TO_LREAL(arrGroupFilter[3].GROUP_ADDR.SUB_MAIN), bEventBasedActive=> );
arrPD[15](lrValue:= WORD_TO_LREAL(arrGroupFilter[3].GROUP_LEN), bEventBasedActive=> );
arrPD[16](lrValue:= BYTE_TO_LREAL(arrGroupFilter[4].GROUP_ADDR.MAIN), bEventBasedActive=> );
arrPD[17](lrValue:= BYTE_TO_LREAL(arrGroupFilter[4].GROUP_ADDR.NUMBER), bEventBasedActive=> );
arrPD[18](lrValue:= BYTE_TO_LREAL(arrGroupFilter[4].GROUP_ADDR.SUB_MAIN), bEventBasedActive=> );
arrPD[19](lrValue:= WORD_TO_LREAL(arrGroupFilter[4].GROUP_LEN), bEventBasedActive=> );
arrPD[20](lrValue:= BYTE_TO_LREAL(arrGroupFilter[5].GROUP_ADDR.MAIN), bEventBasedActive=> );
arrPD[21](lrValue:= BYTE_TO_LREAL(arrGroupFilter[5].GROUP_ADDR.NUMBER), bEventBasedActive=> );
arrPD[22](lrValue:= BYTE_TO_LREAL(arrGroupFilter[5].GROUP_ADDR.SUB_MAIN), bEventBasedActive=> );
arrPD[23](lrValue:= WORD_TO_LREAL(arrGroupFilter[5].GROUP_LEN), bEventBasedActive=> );
arrPD[24](lrValue:= BYTE_TO_LREAL(arrGroupFilter[6].GROUP_ADDR.MAIN), bEventBasedActive=> );
arrPD[25](lrValue:= BYTE_TO_LREAL(arrGroupFilter[6].GROUP_ADDR.NUMBER), bEventBasedActive=> );
arrPD[26](lrValue:= BYTE_TO_LREAL(arrGroupFilter[6].GROUP_ADDR.SUB_MAIN), bEventBasedActive=> );
arrPD[27](lrValue:= WORD_TO_LREAL(arrGroupFilter[6].GROUP_LEN), bEventBasedActive=> );
arrPD[28](lrValue:= BYTE_TO_LREAL(arrGroupFilter[7].GROUP_ADDR.MAIN), bEventBasedActive=> );
arrPD[29](lrValue:= BYTE_TO_LREAL(arrGroupFilter[7].GROUP_ADDR.NUMBER), bEventBasedActive=> );
arrPD[30](lrValue:= BYTE_TO_LREAL(arrGroupFilter[7].GROUP_ADDR.SUB_MAIN), bEventBasedActive=> );
arrPD[31](lrValue:= WORD_TO_LREAL(arrGroupFilter[7].GROUP_LEN), bEventBasedActive=> );
arrPD[32](lrValue:= BYTE_TO_LREAL(arrGroupFilter[8].GROUP_ADDR.MAIN), bEventBasedActive=> );
arrPD[33](lrValue:= BYTE_TO_LREAL(arrGroupFilter[8].GROUP_ADDR.NUMBER), bEventBasedActive=> );
arrPD[34](lrValue:= BYTE_TO_LREAL(arrGroupFilter[8].GROUP_ADDR.SUB_MAIN), bEventBasedActive=> );
arrPD[35](lrValue:= WORD_TO_LREAL(arrGroupFilter[8].GROUP_LEN), bEventBasedActive=> );
arrPD[36](lrValue:= INT_TO_LREAL(iKL6301Mode), bEventBasedActive=> );
]]></ST>
    </Implementation>
    <LineIds Name="FB_KL6301_KNX_Master">
      <LineId Id="12" Count="2" />
      <LineId Id="9" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="266" Count="8" />
      <LineId Id="20" Count="2" />
      <LineId Id="15" Count="0" />
      <LineId Id="326" Count="1" />
      <LineId Id="329" Count="0" />
      <LineId Id="328" Count="0" />
      <LineId Id="330" Count="0" />
      <LineId Id="339" Count="0" />
      <LineId Id="331" Count="1" />
      <LineId Id="337" Count="0" />
      <LineId Id="333" Count="2" />
      <LineId Id="338" Count="0" />
      <LineId Id="37" Count="21" />
      <LineId Id="36" Count="0" />
      <LineId Id="63" Count="2" />
      <LineId Id="379" Count="4" />
      <LineId Id="62" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="425" Count="2" />
      <LineId Id="478" Count="0" />
      <LineId Id="483" Count="0" />
      <LineId Id="482" Count="0" />
      <LineId Id="479" Count="1" />
      <LineId Id="473" Count="0" />
      <LineId Id="475" Count="0" />
      <LineId Id="251" Count="0" />
      <LineId Id="253" Count="12" />
      <LineId Id="252" Count="0" />
      <LineId Id="90" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="94" Count="2" />
      <LineId Id="108" Count="0" />
      <LineId Id="97" Count="1" />
      <LineId Id="74" Count="0" />
      <LineId Id="109" Count="4" />
      <LineId Id="119" Count="0" />
      <LineId Id="114" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="103" Count="3" />
      <LineId Id="99" Count="0" />
      <LineId Id="121" Count="1" />
      <LineId Id="116" Count="0" />
      <LineId Id="123" Count="13" />
      <LineId Id="167" Count="0" />
      <LineId Id="280" Count="0" />
      <LineId Id="142" Count="6" />
      <LineId Id="177" Count="0" />
      <LineId Id="176" Count="0" />
      <LineId Id="281" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="283" Count="1" />
      <LineId Id="288" Count="1" />
      <LineId Id="285" Count="0" />
      <LineId Id="290" Count="0" />
      <LineId Id="293" Count="2" />
      <LineId Id="291" Count="0" />
      <LineId Id="298" Count="2" />
      <LineId Id="296" Count="0" />
      <LineId Id="303" Count="2" />
      <LineId Id="301" Count="0" />
      <LineId Id="307" Count="2" />
      <LineId Id="306" Count="0" />
      <LineId Id="312" Count="2" />
      <LineId Id="310" Count="0" />
      <LineId Id="317" Count="2" />
      <LineId Id="315" Count="0" />
      <LineId Id="322" Count="2" />
      <LineId Id="320" Count="0" />
      <LineId Id="325" Count="0" />
      <LineId Id="282" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>